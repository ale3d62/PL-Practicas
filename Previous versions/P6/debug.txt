Grammar:

Rule 0     S' -> S
Rule 1     S -> S2 TYPE emptymain MAIN ( ) { LINES }
Rule 2     emptymain -> <empty>
Rule 3     S2 -> <empty>
Rule 4     S2 -> S2 FUNCTION
Rule 5     FUNCTION -> TYPE ID ARRAY REST ;
Rule 6     FUNCTION -> VOIDTYPE ID emptyF1 ( ARGS ) { LINES } emptyF2
Rule 7     FUNCTION -> TYPE ID emptyF1 ( ARGS ) { LINES } emptyF2
Rule 8     ARGS -> <empty>
Rule 9     ARGS -> TYPE ARG RARGS
Rule 10    RARGS -> <empty>
Rule 11    RARGS -> , TYPE ARG RARGS
Rule 12    emptyF1 -> <empty>
Rule 13    emptyF2 -> <empty>
Rule 14    ARG -> ID
Rule 15    LINES -> <empty>
Rule 16    LINES -> LINES LINE ;
Rule 17    LINE -> PRINT ( STRING PRINTIDS )
Rule 18    LINE -> SCANF ( STRING SCANIDS )
Rule 19    LINE -> DECLAR
Rule 20    LINE -> INSTR
Rule 21    SCANIDS -> <empty>
Rule 22    SCANIDS -> , REFERENCE SCANIDS
Rule 23    PRINTIDS -> <empty>
Rule 24    PRINTIDS -> , INSTR PRINTIDS
Rule 25    INSTR -> FCALL
Rule 26    INSTR -> OROP
Rule 27    INSTR -> ASIG
Rule 28    FCALL -> ID ( FARGS )
Rule 29    FARGS -> <empty>
Rule 30    FARGS -> FARG RFARGS
Rule 31    RFARGS -> <empty>
Rule 32    RFARGS -> , FARG RFARGS
Rule 33    FARG -> VAL
Rule 34    DECLAR -> TYPE POINTERS IDPRIMA
Rule 35    POINTERS -> <empty>
Rule 36    POINTERS -> * POINTERS
Rule 37    IDPRIMA -> empty ELEM REST
Rule 38    REST -> <empty>
Rule 39    REST -> , empty2 ELEM REST
Rule 40    ELEM -> ID = INSTR
Rule 41    ELEM -> ID ARRAY
Rule 42    ARRAY -> <empty>
Rule 43    ARRAY -> [ NUMBER ] ARRAY
Rule 44    empty -> <empty>
Rule 45    empty2 -> <empty>
Rule 46    ASIG -> ID = INSTR
Rule 47    OROP -> ANDOP
Rule 48    OROP -> OROP ORSIMB ANDOP
Rule 49    ANDOP -> NOTOP
Rule 50    ANDOP -> ANDOP ANDSIMB NOTOP
Rule 51    NOTOP -> COMPOP
Rule 52    NOTOP -> ! NOTOP
Rule 53    COMPOP -> ADDOP
Rule 54    COMPOP -> COMPOP COMPSIMB ADDOP
Rule 55    ADDOP -> PRODOP
Rule 56    ADDOP -> ADDOP - PRODOP
Rule 57    ADDOP -> ADDOP + PRODOP
Rule 58    PRODOP -> PAROP
Rule 59    PRODOP -> PRODOP / PAROP
Rule 60    PRODOP -> PRODOP * PAROP
Rule 61    PAROP -> VAL
Rule 62    PAROP -> ( OROP )
Rule 63    VAL -> REFERENCE
Rule 64    VAL -> ID
Rule 65    VAL -> CHAR
Rule 66    VAL -> NUMBERF
Rule 67    VAL -> NUMBER
Rule 68    REFERENCE -> & ID

Terminals, with rules where they appear:

!                    : 52
&                    : 68
(                    : 1 6 7 17 18 28 62
)                    : 1 6 7 17 18 28 62
*                    : 36 60
+                    : 57
,                    : 11 22 24 32 39
-                    : 56
/                    : 59
;                    : 5 16
=                    : 40 46
ANDSIMB              : 50
CHAR                 : 65
COMPSIMB             : 54
ID                   : 5 6 7 14 28 40 41 46 64 68
MAIN                 : 1
NUMBER               : 43 67
NUMBERF              : 66
ORSIMB               : 48
PRINT                : 17
SCANF                : 18
STRING               : 17 18
TYPE                 : 1 5 7 9 11 34
VOIDTYPE             : 6
[                    : 43
]                    : 43
error                : 
{                    : 1 6 7
}                    : 1 6 7

Nonterminals, with rules where they appear:

ADDOP                : 53 54 56 57
ANDOP                : 47 48 50
ARG                  : 9 11
ARGS                 : 6 7
ARRAY                : 5 41 43
ASIG                 : 27
COMPOP               : 51 54
DECLAR               : 19
ELEM                 : 37 39
FARG                 : 30 32
FARGS                : 28
FCALL                : 25
FUNCTION             : 4
IDPRIMA              : 34
INSTR                : 20 24 40 46
LINE                 : 16
LINES                : 1 6 7 16
NOTOP                : 49 50 52
OROP                 : 26 48 62
PAROP                : 58 59 60
POINTERS             : 34 36
PRINTIDS             : 17 24
PRODOP               : 55 56 57 59 60
RARGS                : 9 11
REFERENCE            : 22 63
REST                 : 5 37 39
RFARGS               : 30 32
S                    : 0
S2                   : 1 4
SCANIDS              : 18 22
VAL                  : 33 61
empty                : 37
empty2               : 39
emptyF1              : 6 7
emptyF2              : 6 7
emptymain            : 1


state 0

    (0) S' -> . S
    (1) S -> . S2 TYPE emptymain MAIN ( ) { LINES }
    (3) S2 -> .
    (4) S2 -> . S2 FUNCTION
    TYPE            reduce using rule 3 (S2 -> .)
    VOIDTYPE        reduce using rule 3 (S2 -> .)

    S                              shift and go to state 1
    S2                             shift and go to state 2

state 1

    (0) S' -> S .


state 2

    (1) S -> S2 . TYPE emptymain MAIN ( ) { LINES }
    (4) S2 -> S2 . FUNCTION
    (5) FUNCTION -> . TYPE ID ARRAY REST ;
    (6) FUNCTION -> . VOIDTYPE ID emptyF1 ( ARGS ) { LINES } emptyF2
    (7) FUNCTION -> . TYPE ID emptyF1 ( ARGS ) { LINES } emptyF2
    TYPE            shift and go to state 3
    VOIDTYPE        shift and go to state 5

    FUNCTION                       shift and go to state 4

state 3

    (1) S -> S2 TYPE . emptymain MAIN ( ) { LINES }
    (5) FUNCTION -> TYPE . ID ARRAY REST ;
    (7) FUNCTION -> TYPE . ID emptyF1 ( ARGS ) { LINES } emptyF2
    (2) emptymain -> .
    ID              shift and go to state 7
    MAIN            reduce using rule 2 (emptymain -> .)

    emptymain                      shift and go to state 6

state 4

    (4) S2 -> S2 FUNCTION .
    TYPE            reduce using rule 4 (S2 -> S2 FUNCTION .)
    VOIDTYPE        reduce using rule 4 (S2 -> S2 FUNCTION .)


state 5

    (6) FUNCTION -> VOIDTYPE . ID emptyF1 ( ARGS ) { LINES } emptyF2
    ID              shift and go to state 8


state 6

    (1) S -> S2 TYPE emptymain . MAIN ( ) { LINES }
    MAIN            shift and go to state 9


state 7

    (5) FUNCTION -> TYPE ID . ARRAY REST ;
    (7) FUNCTION -> TYPE ID . emptyF1 ( ARGS ) { LINES } emptyF2
    (42) ARRAY -> .
    (43) ARRAY -> . [ NUMBER ] ARRAY
    (12) emptyF1 -> .
    ,               reduce using rule 42 (ARRAY -> .)
    ;               reduce using rule 42 (ARRAY -> .)
    [               shift and go to state 12
    (               reduce using rule 12 (emptyF1 -> .)

    ARRAY                          shift and go to state 10
    emptyF1                        shift and go to state 11

state 8

    (6) FUNCTION -> VOIDTYPE ID . emptyF1 ( ARGS ) { LINES } emptyF2
    (12) emptyF1 -> .
    (               reduce using rule 12 (emptyF1 -> .)

    emptyF1                        shift and go to state 13

state 9

    (1) S -> S2 TYPE emptymain MAIN . ( ) { LINES }
    (               shift and go to state 14


state 10

    (5) FUNCTION -> TYPE ID ARRAY . REST ;
    (38) REST -> .
    (39) REST -> . , empty2 ELEM REST
    ;               reduce using rule 38 (REST -> .)
    ,               shift and go to state 16

    REST                           shift and go to state 15

state 11

    (7) FUNCTION -> TYPE ID emptyF1 . ( ARGS ) { LINES } emptyF2
    (               shift and go to state 17


state 12

    (43) ARRAY -> [ . NUMBER ] ARRAY
    NUMBER          shift and go to state 18


state 13

    (6) FUNCTION -> VOIDTYPE ID emptyF1 . ( ARGS ) { LINES } emptyF2
    (               shift and go to state 19


state 14

    (1) S -> S2 TYPE emptymain MAIN ( . ) { LINES }
    )               shift and go to state 20


state 15

    (5) FUNCTION -> TYPE ID ARRAY REST . ;
    ;               shift and go to state 21


state 16

    (39) REST -> , . empty2 ELEM REST
    (45) empty2 -> .
    ID              reduce using rule 45 (empty2 -> .)

    empty2                         shift and go to state 22

state 17

    (7) FUNCTION -> TYPE ID emptyF1 ( . ARGS ) { LINES } emptyF2
    (8) ARGS -> .
    (9) ARGS -> . TYPE ARG RARGS
    )               reduce using rule 8 (ARGS -> .)
    TYPE            shift and go to state 23

    ARGS                           shift and go to state 24

state 18

    (43) ARRAY -> [ NUMBER . ] ARRAY
    ]               shift and go to state 25


state 19

    (6) FUNCTION -> VOIDTYPE ID emptyF1 ( . ARGS ) { LINES } emptyF2
    (8) ARGS -> .
    (9) ARGS -> . TYPE ARG RARGS
    )               reduce using rule 8 (ARGS -> .)
    TYPE            shift and go to state 23

    ARGS                           shift and go to state 26

state 20

    (1) S -> S2 TYPE emptymain MAIN ( ) . { LINES }
    {               shift and go to state 27


state 21

    (5) FUNCTION -> TYPE ID ARRAY REST ; .
    TYPE            reduce using rule 5 (FUNCTION -> TYPE ID ARRAY REST ; .)
    VOIDTYPE        reduce using rule 5 (FUNCTION -> TYPE ID ARRAY REST ; .)


state 22

    (39) REST -> , empty2 . ELEM REST
    (40) ELEM -> . ID = INSTR
    (41) ELEM -> . ID ARRAY
    ID              shift and go to state 29

    ELEM                           shift and go to state 28

state 23

    (9) ARGS -> TYPE . ARG RARGS
    (14) ARG -> . ID
    ID              shift and go to state 31

    ARG                            shift and go to state 30

state 24

    (7) FUNCTION -> TYPE ID emptyF1 ( ARGS . ) { LINES } emptyF2
    )               shift and go to state 32


state 25

    (43) ARRAY -> [ NUMBER ] . ARRAY
    (42) ARRAY -> .
    (43) ARRAY -> . [ NUMBER ] ARRAY
    ,               reduce using rule 42 (ARRAY -> .)
    ;               reduce using rule 42 (ARRAY -> .)
    [               shift and go to state 12

    ARRAY                          shift and go to state 33

state 26

    (6) FUNCTION -> VOIDTYPE ID emptyF1 ( ARGS . ) { LINES } emptyF2
    )               shift and go to state 34


state 27

    (1) S -> S2 TYPE emptymain MAIN ( ) { . LINES }
    (15) LINES -> .
    (16) LINES -> . LINES LINE ;
    }               reduce using rule 15 (LINES -> .)
    PRINT           reduce using rule 15 (LINES -> .)
    SCANF           reduce using rule 15 (LINES -> .)
    TYPE            reduce using rule 15 (LINES -> .)
    ID              reduce using rule 15 (LINES -> .)
    !               reduce using rule 15 (LINES -> .)
    (               reduce using rule 15 (LINES -> .)
    CHAR            reduce using rule 15 (LINES -> .)
    NUMBERF         reduce using rule 15 (LINES -> .)
    NUMBER          reduce using rule 15 (LINES -> .)
    &               reduce using rule 15 (LINES -> .)

    LINES                          shift and go to state 35

state 28

    (39) REST -> , empty2 ELEM . REST
    (38) REST -> .
    (39) REST -> . , empty2 ELEM REST
    ;               reduce using rule 38 (REST -> .)
    ,               shift and go to state 16

    REST                           shift and go to state 36

state 29

    (40) ELEM -> ID . = INSTR
    (41) ELEM -> ID . ARRAY
    (42) ARRAY -> .
    (43) ARRAY -> . [ NUMBER ] ARRAY
    =               shift and go to state 37
    ,               reduce using rule 42 (ARRAY -> .)
    ;               reduce using rule 42 (ARRAY -> .)
    [               shift and go to state 12

    ARRAY                          shift and go to state 38

state 30

    (9) ARGS -> TYPE ARG . RARGS
    (10) RARGS -> .
    (11) RARGS -> . , TYPE ARG RARGS
    )               reduce using rule 10 (RARGS -> .)
    ,               shift and go to state 40

    RARGS                          shift and go to state 39

state 31

    (14) ARG -> ID .
    ,               reduce using rule 14 (ARG -> ID .)
    )               reduce using rule 14 (ARG -> ID .)


state 32

    (7) FUNCTION -> TYPE ID emptyF1 ( ARGS ) . { LINES } emptyF2
    {               shift and go to state 41


state 33

    (43) ARRAY -> [ NUMBER ] ARRAY .
    ,               reduce using rule 43 (ARRAY -> [ NUMBER ] ARRAY .)
    ;               reduce using rule 43 (ARRAY -> [ NUMBER ] ARRAY .)


state 34

    (6) FUNCTION -> VOIDTYPE ID emptyF1 ( ARGS ) . { LINES } emptyF2
    {               shift and go to state 42


state 35

    (1) S -> S2 TYPE emptymain MAIN ( ) { LINES . }
    (16) LINES -> LINES . LINE ;
    (17) LINE -> . PRINT ( STRING PRINTIDS )
    (18) LINE -> . SCANF ( STRING SCANIDS )
    (19) LINE -> . DECLAR
    (20) LINE -> . INSTR
    (34) DECLAR -> . TYPE POINTERS IDPRIMA
    (25) INSTR -> . FCALL
    (26) INSTR -> . OROP
    (27) INSTR -> . ASIG
    (28) FCALL -> . ID ( FARGS )
    (47) OROP -> . ANDOP
    (48) OROP -> . OROP ORSIMB ANDOP
    (46) ASIG -> . ID = INSTR
    (49) ANDOP -> . NOTOP
    (50) ANDOP -> . ANDOP ANDSIMB NOTOP
    (51) NOTOP -> . COMPOP
    (52) NOTOP -> . ! NOTOP
    (53) COMPOP -> . ADDOP
    (54) COMPOP -> . COMPOP COMPSIMB ADDOP
    (55) ADDOP -> . PRODOP
    (56) ADDOP -> . ADDOP - PRODOP
    (57) ADDOP -> . ADDOP + PRODOP
    (58) PRODOP -> . PAROP
    (59) PRODOP -> . PRODOP / PAROP
    (60) PRODOP -> . PRODOP * PAROP
    (61) PAROP -> . VAL
    (62) PAROP -> . ( OROP )
    (63) VAL -> . REFERENCE
    (64) VAL -> . ID
    (65) VAL -> . CHAR
    (66) VAL -> . NUMBERF
    (67) VAL -> . NUMBER
    (68) REFERENCE -> . & ID
    }               shift and go to state 45
    PRINT           shift and go to state 47
    SCANF           shift and go to state 48
    TYPE            shift and go to state 43
    ID              shift and go to state 54
    !               shift and go to state 58
    (               shift and go to state 44
    CHAR            shift and go to state 64
    NUMBERF         shift and go to state 65
    NUMBER          shift and go to state 66
    &               shift and go to state 67

    LINE                           shift and go to state 46
    DECLAR                         shift and go to state 49
    INSTR                          shift and go to state 50
    FCALL                          shift and go to state 51
    OROP                           shift and go to state 52
    ASIG                           shift and go to state 53
    ANDOP                          shift and go to state 55
    NOTOP                          shift and go to state 56
    COMPOP                         shift and go to state 57
    ADDOP                          shift and go to state 59
    PRODOP                         shift and go to state 60
    PAROP                          shift and go to state 61
    VAL                            shift and go to state 62
    REFERENCE                      shift and go to state 63

state 36

    (39) REST -> , empty2 ELEM REST .
    ;               reduce using rule 39 (REST -> , empty2 ELEM REST .)


state 37

    (40) ELEM -> ID = . INSTR
    (25) INSTR -> . FCALL
    (26) INSTR -> . OROP
    (27) INSTR -> . ASIG
    (28) FCALL -> . ID ( FARGS )
    (47) OROP -> . ANDOP
    (48) OROP -> . OROP ORSIMB ANDOP
    (46) ASIG -> . ID = INSTR
    (49) ANDOP -> . NOTOP
    (50) ANDOP -> . ANDOP ANDSIMB NOTOP
    (51) NOTOP -> . COMPOP
    (52) NOTOP -> . ! NOTOP
    (53) COMPOP -> . ADDOP
    (54) COMPOP -> . COMPOP COMPSIMB ADDOP
    (55) ADDOP -> . PRODOP
    (56) ADDOP -> . ADDOP - PRODOP
    (57) ADDOP -> . ADDOP + PRODOP
    (58) PRODOP -> . PAROP
    (59) PRODOP -> . PRODOP / PAROP
    (60) PRODOP -> . PRODOP * PAROP
    (61) PAROP -> . VAL
    (62) PAROP -> . ( OROP )
    (63) VAL -> . REFERENCE
    (64) VAL -> . ID
    (65) VAL -> . CHAR
    (66) VAL -> . NUMBERF
    (67) VAL -> . NUMBER
    (68) REFERENCE -> . & ID
    ID              shift and go to state 54
    !               shift and go to state 58
    (               shift and go to state 44
    CHAR            shift and go to state 64
    NUMBERF         shift and go to state 65
    NUMBER          shift and go to state 66
    &               shift and go to state 67

    INSTR                          shift and go to state 68
    FCALL                          shift and go to state 51
    OROP                           shift and go to state 52
    ASIG                           shift and go to state 53
    ANDOP                          shift and go to state 55
    NOTOP                          shift and go to state 56
    COMPOP                         shift and go to state 57
    ADDOP                          shift and go to state 59
    PRODOP                         shift and go to state 60
    PAROP                          shift and go to state 61
    VAL                            shift and go to state 62
    REFERENCE                      shift and go to state 63

state 38

    (41) ELEM -> ID ARRAY .
    ,               reduce using rule 41 (ELEM -> ID ARRAY .)
    ;               reduce using rule 41 (ELEM -> ID ARRAY .)


state 39

    (9) ARGS -> TYPE ARG RARGS .
    )               reduce using rule 9 (ARGS -> TYPE ARG RARGS .)


state 40

    (11) RARGS -> , . TYPE ARG RARGS
    TYPE            shift and go to state 69


state 41

    (7) FUNCTION -> TYPE ID emptyF1 ( ARGS ) { . LINES } emptyF2
    (15) LINES -> .
    (16) LINES -> . LINES LINE ;
    }               reduce using rule 15 (LINES -> .)
    PRINT           reduce using rule 15 (LINES -> .)
    SCANF           reduce using rule 15 (LINES -> .)
    TYPE            reduce using rule 15 (LINES -> .)
    ID              reduce using rule 15 (LINES -> .)
    !               reduce using rule 15 (LINES -> .)
    (               reduce using rule 15 (LINES -> .)
    CHAR            reduce using rule 15 (LINES -> .)
    NUMBERF         reduce using rule 15 (LINES -> .)
    NUMBER          reduce using rule 15 (LINES -> .)
    &               reduce using rule 15 (LINES -> .)

    LINES                          shift and go to state 70

state 42

    (6) FUNCTION -> VOIDTYPE ID emptyF1 ( ARGS ) { . LINES } emptyF2
    (15) LINES -> .
    (16) LINES -> . LINES LINE ;
    }               reduce using rule 15 (LINES -> .)
    PRINT           reduce using rule 15 (LINES -> .)
    SCANF           reduce using rule 15 (LINES -> .)
    TYPE            reduce using rule 15 (LINES -> .)
    ID              reduce using rule 15 (LINES -> .)
    !               reduce using rule 15 (LINES -> .)
    (               reduce using rule 15 (LINES -> .)
    CHAR            reduce using rule 15 (LINES -> .)
    NUMBERF         reduce using rule 15 (LINES -> .)
    NUMBER          reduce using rule 15 (LINES -> .)
    &               reduce using rule 15 (LINES -> .)

    LINES                          shift and go to state 71

state 43

    (34) DECLAR -> TYPE . POINTERS IDPRIMA
    (35) POINTERS -> .
    (36) POINTERS -> . * POINTERS
    ID              reduce using rule 35 (POINTERS -> .)
    *               shift and go to state 73

    POINTERS                       shift and go to state 72

state 44

    (62) PAROP -> ( . OROP )
    (47) OROP -> . ANDOP
    (48) OROP -> . OROP ORSIMB ANDOP
    (49) ANDOP -> . NOTOP
    (50) ANDOP -> . ANDOP ANDSIMB NOTOP
    (51) NOTOP -> . COMPOP
    (52) NOTOP -> . ! NOTOP
    (53) COMPOP -> . ADDOP
    (54) COMPOP -> . COMPOP COMPSIMB ADDOP
    (55) ADDOP -> . PRODOP
    (56) ADDOP -> . ADDOP - PRODOP
    (57) ADDOP -> . ADDOP + PRODOP
    (58) PRODOP -> . PAROP
    (59) PRODOP -> . PRODOP / PAROP
    (60) PRODOP -> . PRODOP * PAROP
    (61) PAROP -> . VAL
    (62) PAROP -> . ( OROP )
    (63) VAL -> . REFERENCE
    (64) VAL -> . ID
    (65) VAL -> . CHAR
    (66) VAL -> . NUMBERF
    (67) VAL -> . NUMBER
    (68) REFERENCE -> . & ID
    !               shift and go to state 58
    (               shift and go to state 44
    ID              shift and go to state 75
    CHAR            shift and go to state 64
    NUMBERF         shift and go to state 65
    NUMBER          shift and go to state 66
    &               shift and go to state 67

    OROP                           shift and go to state 74
    ANDOP                          shift and go to state 55
    NOTOP                          shift and go to state 56
    COMPOP                         shift and go to state 57
    ADDOP                          shift and go to state 59
    PRODOP                         shift and go to state 60
    PAROP                          shift and go to state 61
    VAL                            shift and go to state 62
    REFERENCE                      shift and go to state 63

state 45

    (1) S -> S2 TYPE emptymain MAIN ( ) { LINES } .
    $end            reduce using rule 1 (S -> S2 TYPE emptymain MAIN ( ) { LINES } .)


state 46

    (16) LINES -> LINES LINE . ;
    ;               shift and go to state 76


state 47

    (17) LINE -> PRINT . ( STRING PRINTIDS )
    (               shift and go to state 77


state 48

    (18) LINE -> SCANF . ( STRING SCANIDS )
    (               shift and go to state 78


state 49

    (19) LINE -> DECLAR .
    ;               reduce using rule 19 (LINE -> DECLAR .)


state 50

    (20) LINE -> INSTR .
    ;               reduce using rule 20 (LINE -> INSTR .)


state 51

    (25) INSTR -> FCALL .
    ;               reduce using rule 25 (INSTR -> FCALL .)
    ,               reduce using rule 25 (INSTR -> FCALL .)
    )               reduce using rule 25 (INSTR -> FCALL .)


state 52

    (26) INSTR -> OROP .
    (48) OROP -> OROP . ORSIMB ANDOP
    ;               reduce using rule 26 (INSTR -> OROP .)
    ,               reduce using rule 26 (INSTR -> OROP .)
    )               reduce using rule 26 (INSTR -> OROP .)
    ORSIMB          shift and go to state 79


state 53

    (27) INSTR -> ASIG .
    ;               reduce using rule 27 (INSTR -> ASIG .)
    ,               reduce using rule 27 (INSTR -> ASIG .)
    )               reduce using rule 27 (INSTR -> ASIG .)


state 54

    (28) FCALL -> ID . ( FARGS )
    (46) ASIG -> ID . = INSTR
    (64) VAL -> ID .
    (               shift and go to state 80
    =               shift and go to state 81
    /               reduce using rule 64 (VAL -> ID .)
    *               reduce using rule 64 (VAL -> ID .)
    -               reduce using rule 64 (VAL -> ID .)
    +               reduce using rule 64 (VAL -> ID .)
    COMPSIMB        reduce using rule 64 (VAL -> ID .)
    ANDSIMB         reduce using rule 64 (VAL -> ID .)
    ORSIMB          reduce using rule 64 (VAL -> ID .)
    ;               reduce using rule 64 (VAL -> ID .)
    ,               reduce using rule 64 (VAL -> ID .)
    )               reduce using rule 64 (VAL -> ID .)


state 55

    (47) OROP -> ANDOP .
    (50) ANDOP -> ANDOP . ANDSIMB NOTOP
    ORSIMB          reduce using rule 47 (OROP -> ANDOP .)
    ;               reduce using rule 47 (OROP -> ANDOP .)
    ,               reduce using rule 47 (OROP -> ANDOP .)
    )               reduce using rule 47 (OROP -> ANDOP .)
    ANDSIMB         shift and go to state 82


state 56

    (49) ANDOP -> NOTOP .
    ANDSIMB         reduce using rule 49 (ANDOP -> NOTOP .)
    ORSIMB          reduce using rule 49 (ANDOP -> NOTOP .)
    ;               reduce using rule 49 (ANDOP -> NOTOP .)
    ,               reduce using rule 49 (ANDOP -> NOTOP .)
    )               reduce using rule 49 (ANDOP -> NOTOP .)


state 57

    (51) NOTOP -> COMPOP .
    (54) COMPOP -> COMPOP . COMPSIMB ADDOP
    ANDSIMB         reduce using rule 51 (NOTOP -> COMPOP .)
    ORSIMB          reduce using rule 51 (NOTOP -> COMPOP .)
    ;               reduce using rule 51 (NOTOP -> COMPOP .)
    ,               reduce using rule 51 (NOTOP -> COMPOP .)
    )               reduce using rule 51 (NOTOP -> COMPOP .)
    COMPSIMB        shift and go to state 83


state 58

    (52) NOTOP -> ! . NOTOP
    (51) NOTOP -> . COMPOP
    (52) NOTOP -> . ! NOTOP
    (53) COMPOP -> . ADDOP
    (54) COMPOP -> . COMPOP COMPSIMB ADDOP
    (55) ADDOP -> . PRODOP
    (56) ADDOP -> . ADDOP - PRODOP
    (57) ADDOP -> . ADDOP + PRODOP
    (58) PRODOP -> . PAROP
    (59) PRODOP -> . PRODOP / PAROP
    (60) PRODOP -> . PRODOP * PAROP
    (61) PAROP -> . VAL
    (62) PAROP -> . ( OROP )
    (63) VAL -> . REFERENCE
    (64) VAL -> . ID
    (65) VAL -> . CHAR
    (66) VAL -> . NUMBERF
    (67) VAL -> . NUMBER
    (68) REFERENCE -> . & ID
    !               shift and go to state 58
    (               shift and go to state 44
    ID              shift and go to state 75
    CHAR            shift and go to state 64
    NUMBERF         shift and go to state 65
    NUMBER          shift and go to state 66
    &               shift and go to state 67

    NOTOP                          shift and go to state 84
    COMPOP                         shift and go to state 57
    ADDOP                          shift and go to state 59
    PRODOP                         shift and go to state 60
    PAROP                          shift and go to state 61
    VAL                            shift and go to state 62
    REFERENCE                      shift and go to state 63

state 59

    (53) COMPOP -> ADDOP .
    (56) ADDOP -> ADDOP . - PRODOP
    (57) ADDOP -> ADDOP . + PRODOP
    COMPSIMB        reduce using rule 53 (COMPOP -> ADDOP .)
    ANDSIMB         reduce using rule 53 (COMPOP -> ADDOP .)
    ORSIMB          reduce using rule 53 (COMPOP -> ADDOP .)
    ;               reduce using rule 53 (COMPOP -> ADDOP .)
    ,               reduce using rule 53 (COMPOP -> ADDOP .)
    )               reduce using rule 53 (COMPOP -> ADDOP .)
    -               shift and go to state 85
    +               shift and go to state 86


state 60

    (55) ADDOP -> PRODOP .
    (59) PRODOP -> PRODOP . / PAROP
    (60) PRODOP -> PRODOP . * PAROP
    -               reduce using rule 55 (ADDOP -> PRODOP .)
    +               reduce using rule 55 (ADDOP -> PRODOP .)
    COMPSIMB        reduce using rule 55 (ADDOP -> PRODOP .)
    ANDSIMB         reduce using rule 55 (ADDOP -> PRODOP .)
    ORSIMB          reduce using rule 55 (ADDOP -> PRODOP .)
    ;               reduce using rule 55 (ADDOP -> PRODOP .)
    ,               reduce using rule 55 (ADDOP -> PRODOP .)
    )               reduce using rule 55 (ADDOP -> PRODOP .)
    /               shift and go to state 87
    *               shift and go to state 88


state 61

    (58) PRODOP -> PAROP .
    /               reduce using rule 58 (PRODOP -> PAROP .)
    *               reduce using rule 58 (PRODOP -> PAROP .)
    -               reduce using rule 58 (PRODOP -> PAROP .)
    +               reduce using rule 58 (PRODOP -> PAROP .)
    COMPSIMB        reduce using rule 58 (PRODOP -> PAROP .)
    ANDSIMB         reduce using rule 58 (PRODOP -> PAROP .)
    ORSIMB          reduce using rule 58 (PRODOP -> PAROP .)
    ;               reduce using rule 58 (PRODOP -> PAROP .)
    ,               reduce using rule 58 (PRODOP -> PAROP .)
    )               reduce using rule 58 (PRODOP -> PAROP .)


state 62

    (61) PAROP -> VAL .
    /               reduce using rule 61 (PAROP -> VAL .)
    *               reduce using rule 61 (PAROP -> VAL .)
    -               reduce using rule 61 (PAROP -> VAL .)
    +               reduce using rule 61 (PAROP -> VAL .)
    COMPSIMB        reduce using rule 61 (PAROP -> VAL .)
    ANDSIMB         reduce using rule 61 (PAROP -> VAL .)
    ORSIMB          reduce using rule 61 (PAROP -> VAL .)
    ;               reduce using rule 61 (PAROP -> VAL .)
    ,               reduce using rule 61 (PAROP -> VAL .)
    )               reduce using rule 61 (PAROP -> VAL .)


state 63

    (63) VAL -> REFERENCE .
    /               reduce using rule 63 (VAL -> REFERENCE .)
    *               reduce using rule 63 (VAL -> REFERENCE .)
    -               reduce using rule 63 (VAL -> REFERENCE .)
    +               reduce using rule 63 (VAL -> REFERENCE .)
    COMPSIMB        reduce using rule 63 (VAL -> REFERENCE .)
    ANDSIMB         reduce using rule 63 (VAL -> REFERENCE .)
    ORSIMB          reduce using rule 63 (VAL -> REFERENCE .)
    ;               reduce using rule 63 (VAL -> REFERENCE .)
    ,               reduce using rule 63 (VAL -> REFERENCE .)
    )               reduce using rule 63 (VAL -> REFERENCE .)


state 64

    (65) VAL -> CHAR .
    /               reduce using rule 65 (VAL -> CHAR .)
    *               reduce using rule 65 (VAL -> CHAR .)
    -               reduce using rule 65 (VAL -> CHAR .)
    +               reduce using rule 65 (VAL -> CHAR .)
    COMPSIMB        reduce using rule 65 (VAL -> CHAR .)
    ANDSIMB         reduce using rule 65 (VAL -> CHAR .)
    ORSIMB          reduce using rule 65 (VAL -> CHAR .)
    ;               reduce using rule 65 (VAL -> CHAR .)
    ,               reduce using rule 65 (VAL -> CHAR .)
    )               reduce using rule 65 (VAL -> CHAR .)


state 65

    (66) VAL -> NUMBERF .
    /               reduce using rule 66 (VAL -> NUMBERF .)
    *               reduce using rule 66 (VAL -> NUMBERF .)
    -               reduce using rule 66 (VAL -> NUMBERF .)
    +               reduce using rule 66 (VAL -> NUMBERF .)
    COMPSIMB        reduce using rule 66 (VAL -> NUMBERF .)
    ANDSIMB         reduce using rule 66 (VAL -> NUMBERF .)
    ORSIMB          reduce using rule 66 (VAL -> NUMBERF .)
    ;               reduce using rule 66 (VAL -> NUMBERF .)
    ,               reduce using rule 66 (VAL -> NUMBERF .)
    )               reduce using rule 66 (VAL -> NUMBERF .)


state 66

    (67) VAL -> NUMBER .
    /               reduce using rule 67 (VAL -> NUMBER .)
    *               reduce using rule 67 (VAL -> NUMBER .)
    -               reduce using rule 67 (VAL -> NUMBER .)
    +               reduce using rule 67 (VAL -> NUMBER .)
    COMPSIMB        reduce using rule 67 (VAL -> NUMBER .)
    ANDSIMB         reduce using rule 67 (VAL -> NUMBER .)
    ORSIMB          reduce using rule 67 (VAL -> NUMBER .)
    ;               reduce using rule 67 (VAL -> NUMBER .)
    ,               reduce using rule 67 (VAL -> NUMBER .)
    )               reduce using rule 67 (VAL -> NUMBER .)


state 67

    (68) REFERENCE -> & . ID
    ID              shift and go to state 89


state 68

    (40) ELEM -> ID = INSTR .
    ,               reduce using rule 40 (ELEM -> ID = INSTR .)
    ;               reduce using rule 40 (ELEM -> ID = INSTR .)


state 69

    (11) RARGS -> , TYPE . ARG RARGS
    (14) ARG -> . ID
    ID              shift and go to state 31

    ARG                            shift and go to state 90

state 70

    (7) FUNCTION -> TYPE ID emptyF1 ( ARGS ) { LINES . } emptyF2
    (16) LINES -> LINES . LINE ;
    (17) LINE -> . PRINT ( STRING PRINTIDS )
    (18) LINE -> . SCANF ( STRING SCANIDS )
    (19) LINE -> . DECLAR
    (20) LINE -> . INSTR
    (34) DECLAR -> . TYPE POINTERS IDPRIMA
    (25) INSTR -> . FCALL
    (26) INSTR -> . OROP
    (27) INSTR -> . ASIG
    (28) FCALL -> . ID ( FARGS )
    (47) OROP -> . ANDOP
    (48) OROP -> . OROP ORSIMB ANDOP
    (46) ASIG -> . ID = INSTR
    (49) ANDOP -> . NOTOP
    (50) ANDOP -> . ANDOP ANDSIMB NOTOP
    (51) NOTOP -> . COMPOP
    (52) NOTOP -> . ! NOTOP
    (53) COMPOP -> . ADDOP
    (54) COMPOP -> . COMPOP COMPSIMB ADDOP
    (55) ADDOP -> . PRODOP
    (56) ADDOP -> . ADDOP - PRODOP
    (57) ADDOP -> . ADDOP + PRODOP
    (58) PRODOP -> . PAROP
    (59) PRODOP -> . PRODOP / PAROP
    (60) PRODOP -> . PRODOP * PAROP
    (61) PAROP -> . VAL
    (62) PAROP -> . ( OROP )
    (63) VAL -> . REFERENCE
    (64) VAL -> . ID
    (65) VAL -> . CHAR
    (66) VAL -> . NUMBERF
    (67) VAL -> . NUMBER
    (68) REFERENCE -> . & ID
    }               shift and go to state 91
    PRINT           shift and go to state 47
    SCANF           shift and go to state 48
    TYPE            shift and go to state 43
    ID              shift and go to state 54
    !               shift and go to state 58
    (               shift and go to state 44
    CHAR            shift and go to state 64
    NUMBERF         shift and go to state 65
    NUMBER          shift and go to state 66
    &               shift and go to state 67

    LINE                           shift and go to state 46
    DECLAR                         shift and go to state 49
    INSTR                          shift and go to state 50
    FCALL                          shift and go to state 51
    OROP                           shift and go to state 52
    ASIG                           shift and go to state 53
    ANDOP                          shift and go to state 55
    NOTOP                          shift and go to state 56
    COMPOP                         shift and go to state 57
    ADDOP                          shift and go to state 59
    PRODOP                         shift and go to state 60
    PAROP                          shift and go to state 61
    VAL                            shift and go to state 62
    REFERENCE                      shift and go to state 63

state 71

    (6) FUNCTION -> VOIDTYPE ID emptyF1 ( ARGS ) { LINES . } emptyF2
    (16) LINES -> LINES . LINE ;
    (17) LINE -> . PRINT ( STRING PRINTIDS )
    (18) LINE -> . SCANF ( STRING SCANIDS )
    (19) LINE -> . DECLAR
    (20) LINE -> . INSTR
    (34) DECLAR -> . TYPE POINTERS IDPRIMA
    (25) INSTR -> . FCALL
    (26) INSTR -> . OROP
    (27) INSTR -> . ASIG
    (28) FCALL -> . ID ( FARGS )
    (47) OROP -> . ANDOP
    (48) OROP -> . OROP ORSIMB ANDOP
    (46) ASIG -> . ID = INSTR
    (49) ANDOP -> . NOTOP
    (50) ANDOP -> . ANDOP ANDSIMB NOTOP
    (51) NOTOP -> . COMPOP
    (52) NOTOP -> . ! NOTOP
    (53) COMPOP -> . ADDOP
    (54) COMPOP -> . COMPOP COMPSIMB ADDOP
    (55) ADDOP -> . PRODOP
    (56) ADDOP -> . ADDOP - PRODOP
    (57) ADDOP -> . ADDOP + PRODOP
    (58) PRODOP -> . PAROP
    (59) PRODOP -> . PRODOP / PAROP
    (60) PRODOP -> . PRODOP * PAROP
    (61) PAROP -> . VAL
    (62) PAROP -> . ( OROP )
    (63) VAL -> . REFERENCE
    (64) VAL -> . ID
    (65) VAL -> . CHAR
    (66) VAL -> . NUMBERF
    (67) VAL -> . NUMBER
    (68) REFERENCE -> . & ID
    }               shift and go to state 92
    PRINT           shift and go to state 47
    SCANF           shift and go to state 48
    TYPE            shift and go to state 43
    ID              shift and go to state 54
    !               shift and go to state 58
    (               shift and go to state 44
    CHAR            shift and go to state 64
    NUMBERF         shift and go to state 65
    NUMBER          shift and go to state 66
    &               shift and go to state 67

    LINE                           shift and go to state 46
    DECLAR                         shift and go to state 49
    INSTR                          shift and go to state 50
    FCALL                          shift and go to state 51
    OROP                           shift and go to state 52
    ASIG                           shift and go to state 53
    ANDOP                          shift and go to state 55
    NOTOP                          shift and go to state 56
    COMPOP                         shift and go to state 57
    ADDOP                          shift and go to state 59
    PRODOP                         shift and go to state 60
    PAROP                          shift and go to state 61
    VAL                            shift and go to state 62
    REFERENCE                      shift and go to state 63

state 72

    (34) DECLAR -> TYPE POINTERS . IDPRIMA
    (37) IDPRIMA -> . empty ELEM REST
    (44) empty -> .
    ID              reduce using rule 44 (empty -> .)

    IDPRIMA                        shift and go to state 93
    empty                          shift and go to state 94

state 73

    (36) POINTERS -> * . POINTERS
    (35) POINTERS -> .
    (36) POINTERS -> . * POINTERS
    ID              reduce using rule 35 (POINTERS -> .)
    *               shift and go to state 73

    POINTERS                       shift and go to state 95

state 74

    (62) PAROP -> ( OROP . )
    (48) OROP -> OROP . ORSIMB ANDOP
    )               shift and go to state 96
    ORSIMB          shift and go to state 79


state 75

    (64) VAL -> ID .
    /               reduce using rule 64 (VAL -> ID .)
    *               reduce using rule 64 (VAL -> ID .)
    -               reduce using rule 64 (VAL -> ID .)
    +               reduce using rule 64 (VAL -> ID .)
    COMPSIMB        reduce using rule 64 (VAL -> ID .)
    ANDSIMB         reduce using rule 64 (VAL -> ID .)
    )               reduce using rule 64 (VAL -> ID .)
    ORSIMB          reduce using rule 64 (VAL -> ID .)
    ;               reduce using rule 64 (VAL -> ID .)
    ,               reduce using rule 64 (VAL -> ID .)


state 76

    (16) LINES -> LINES LINE ; .
    }               reduce using rule 16 (LINES -> LINES LINE ; .)
    PRINT           reduce using rule 16 (LINES -> LINES LINE ; .)
    SCANF           reduce using rule 16 (LINES -> LINES LINE ; .)
    TYPE            reduce using rule 16 (LINES -> LINES LINE ; .)
    ID              reduce using rule 16 (LINES -> LINES LINE ; .)
    !               reduce using rule 16 (LINES -> LINES LINE ; .)
    (               reduce using rule 16 (LINES -> LINES LINE ; .)
    CHAR            reduce using rule 16 (LINES -> LINES LINE ; .)
    NUMBERF         reduce using rule 16 (LINES -> LINES LINE ; .)
    NUMBER          reduce using rule 16 (LINES -> LINES LINE ; .)
    &               reduce using rule 16 (LINES -> LINES LINE ; .)


state 77

    (17) LINE -> PRINT ( . STRING PRINTIDS )
    STRING          shift and go to state 97


state 78

    (18) LINE -> SCANF ( . STRING SCANIDS )
    STRING          shift and go to state 98


state 79

    (48) OROP -> OROP ORSIMB . ANDOP
    (49) ANDOP -> . NOTOP
    (50) ANDOP -> . ANDOP ANDSIMB NOTOP
    (51) NOTOP -> . COMPOP
    (52) NOTOP -> . ! NOTOP
    (53) COMPOP -> . ADDOP
    (54) COMPOP -> . COMPOP COMPSIMB ADDOP
    (55) ADDOP -> . PRODOP
    (56) ADDOP -> . ADDOP - PRODOP
    (57) ADDOP -> . ADDOP + PRODOP
    (58) PRODOP -> . PAROP
    (59) PRODOP -> . PRODOP / PAROP
    (60) PRODOP -> . PRODOP * PAROP
    (61) PAROP -> . VAL
    (62) PAROP -> . ( OROP )
    (63) VAL -> . REFERENCE
    (64) VAL -> . ID
    (65) VAL -> . CHAR
    (66) VAL -> . NUMBERF
    (67) VAL -> . NUMBER
    (68) REFERENCE -> . & ID
    !               shift and go to state 58
    (               shift and go to state 44
    ID              shift and go to state 75
    CHAR            shift and go to state 64
    NUMBERF         shift and go to state 65
    NUMBER          shift and go to state 66
    &               shift and go to state 67

    ANDOP                          shift and go to state 99
    NOTOP                          shift and go to state 56
    COMPOP                         shift and go to state 57
    ADDOP                          shift and go to state 59
    PRODOP                         shift and go to state 60
    PAROP                          shift and go to state 61
    VAL                            shift and go to state 62
    REFERENCE                      shift and go to state 63

state 80

    (28) FCALL -> ID ( . FARGS )
    (29) FARGS -> .
    (30) FARGS -> . FARG RFARGS
    (33) FARG -> . VAL
    (63) VAL -> . REFERENCE
    (64) VAL -> . ID
    (65) VAL -> . CHAR
    (66) VAL -> . NUMBERF
    (67) VAL -> . NUMBER
    (68) REFERENCE -> . & ID
    )               reduce using rule 29 (FARGS -> .)
    ID              shift and go to state 75
    CHAR            shift and go to state 64
    NUMBERF         shift and go to state 65
    NUMBER          shift and go to state 66
    &               shift and go to state 67

    FARGS                          shift and go to state 100
    FARG                           shift and go to state 101
    VAL                            shift and go to state 102
    REFERENCE                      shift and go to state 63

state 81

    (46) ASIG -> ID = . INSTR
    (25) INSTR -> . FCALL
    (26) INSTR -> . OROP
    (27) INSTR -> . ASIG
    (28) FCALL -> . ID ( FARGS )
    (47) OROP -> . ANDOP
    (48) OROP -> . OROP ORSIMB ANDOP
    (46) ASIG -> . ID = INSTR
    (49) ANDOP -> . NOTOP
    (50) ANDOP -> . ANDOP ANDSIMB NOTOP
    (51) NOTOP -> . COMPOP
    (52) NOTOP -> . ! NOTOP
    (53) COMPOP -> . ADDOP
    (54) COMPOP -> . COMPOP COMPSIMB ADDOP
    (55) ADDOP -> . PRODOP
    (56) ADDOP -> . ADDOP - PRODOP
    (57) ADDOP -> . ADDOP + PRODOP
    (58) PRODOP -> . PAROP
    (59) PRODOP -> . PRODOP / PAROP
    (60) PRODOP -> . PRODOP * PAROP
    (61) PAROP -> . VAL
    (62) PAROP -> . ( OROP )
    (63) VAL -> . REFERENCE
    (64) VAL -> . ID
    (65) VAL -> . CHAR
    (66) VAL -> . NUMBERF
    (67) VAL -> . NUMBER
    (68) REFERENCE -> . & ID
    ID              shift and go to state 54
    !               shift and go to state 58
    (               shift and go to state 44
    CHAR            shift and go to state 64
    NUMBERF         shift and go to state 65
    NUMBER          shift and go to state 66
    &               shift and go to state 67

    INSTR                          shift and go to state 103
    FCALL                          shift and go to state 51
    OROP                           shift and go to state 52
    ASIG                           shift and go to state 53
    ANDOP                          shift and go to state 55
    NOTOP                          shift and go to state 56
    COMPOP                         shift and go to state 57
    ADDOP                          shift and go to state 59
    PRODOP                         shift and go to state 60
    PAROP                          shift and go to state 61
    VAL                            shift and go to state 62
    REFERENCE                      shift and go to state 63

state 82

    (50) ANDOP -> ANDOP ANDSIMB . NOTOP
    (51) NOTOP -> . COMPOP
    (52) NOTOP -> . ! NOTOP
    (53) COMPOP -> . ADDOP
    (54) COMPOP -> . COMPOP COMPSIMB ADDOP
    (55) ADDOP -> . PRODOP
    (56) ADDOP -> . ADDOP - PRODOP
    (57) ADDOP -> . ADDOP + PRODOP
    (58) PRODOP -> . PAROP
    (59) PRODOP -> . PRODOP / PAROP
    (60) PRODOP -> . PRODOP * PAROP
    (61) PAROP -> . VAL
    (62) PAROP -> . ( OROP )
    (63) VAL -> . REFERENCE
    (64) VAL -> . ID
    (65) VAL -> . CHAR
    (66) VAL -> . NUMBERF
    (67) VAL -> . NUMBER
    (68) REFERENCE -> . & ID
    !               shift and go to state 58
    (               shift and go to state 44
    ID              shift and go to state 75
    CHAR            shift and go to state 64
    NUMBERF         shift and go to state 65
    NUMBER          shift and go to state 66
    &               shift and go to state 67

    NOTOP                          shift and go to state 104
    COMPOP                         shift and go to state 57
    ADDOP                          shift and go to state 59
    PRODOP                         shift and go to state 60
    PAROP                          shift and go to state 61
    VAL                            shift and go to state 62
    REFERENCE                      shift and go to state 63

state 83

    (54) COMPOP -> COMPOP COMPSIMB . ADDOP
    (55) ADDOP -> . PRODOP
    (56) ADDOP -> . ADDOP - PRODOP
    (57) ADDOP -> . ADDOP + PRODOP
    (58) PRODOP -> . PAROP
    (59) PRODOP -> . PRODOP / PAROP
    (60) PRODOP -> . PRODOP * PAROP
    (61) PAROP -> . VAL
    (62) PAROP -> . ( OROP )
    (63) VAL -> . REFERENCE
    (64) VAL -> . ID
    (65) VAL -> . CHAR
    (66) VAL -> . NUMBERF
    (67) VAL -> . NUMBER
    (68) REFERENCE -> . & ID
    (               shift and go to state 44
    ID              shift and go to state 75
    CHAR            shift and go to state 64
    NUMBERF         shift and go to state 65
    NUMBER          shift and go to state 66
    &               shift and go to state 67

    ADDOP                          shift and go to state 105
    PRODOP                         shift and go to state 60
    PAROP                          shift and go to state 61
    VAL                            shift and go to state 62
    REFERENCE                      shift and go to state 63

state 84

    (52) NOTOP -> ! NOTOP .
    ANDSIMB         reduce using rule 52 (NOTOP -> ! NOTOP .)
    ORSIMB          reduce using rule 52 (NOTOP -> ! NOTOP .)
    ;               reduce using rule 52 (NOTOP -> ! NOTOP .)
    ,               reduce using rule 52 (NOTOP -> ! NOTOP .)
    )               reduce using rule 52 (NOTOP -> ! NOTOP .)


state 85

    (56) ADDOP -> ADDOP - . PRODOP
    (58) PRODOP -> . PAROP
    (59) PRODOP -> . PRODOP / PAROP
    (60) PRODOP -> . PRODOP * PAROP
    (61) PAROP -> . VAL
    (62) PAROP -> . ( OROP )
    (63) VAL -> . REFERENCE
    (64) VAL -> . ID
    (65) VAL -> . CHAR
    (66) VAL -> . NUMBERF
    (67) VAL -> . NUMBER
    (68) REFERENCE -> . & ID
    (               shift and go to state 44
    ID              shift and go to state 75
    CHAR            shift and go to state 64
    NUMBERF         shift and go to state 65
    NUMBER          shift and go to state 66
    &               shift and go to state 67

    PRODOP                         shift and go to state 106
    PAROP                          shift and go to state 61
    VAL                            shift and go to state 62
    REFERENCE                      shift and go to state 63

state 86

    (57) ADDOP -> ADDOP + . PRODOP
    (58) PRODOP -> . PAROP
    (59) PRODOP -> . PRODOP / PAROP
    (60) PRODOP -> . PRODOP * PAROP
    (61) PAROP -> . VAL
    (62) PAROP -> . ( OROP )
    (63) VAL -> . REFERENCE
    (64) VAL -> . ID
    (65) VAL -> . CHAR
    (66) VAL -> . NUMBERF
    (67) VAL -> . NUMBER
    (68) REFERENCE -> . & ID
    (               shift and go to state 44
    ID              shift and go to state 75
    CHAR            shift and go to state 64
    NUMBERF         shift and go to state 65
    NUMBER          shift and go to state 66
    &               shift and go to state 67

    PRODOP                         shift and go to state 107
    PAROP                          shift and go to state 61
    VAL                            shift and go to state 62
    REFERENCE                      shift and go to state 63

state 87

    (59) PRODOP -> PRODOP / . PAROP
    (61) PAROP -> . VAL
    (62) PAROP -> . ( OROP )
    (63) VAL -> . REFERENCE
    (64) VAL -> . ID
    (65) VAL -> . CHAR
    (66) VAL -> . NUMBERF
    (67) VAL -> . NUMBER
    (68) REFERENCE -> . & ID
    (               shift and go to state 44
    ID              shift and go to state 75
    CHAR            shift and go to state 64
    NUMBERF         shift and go to state 65
    NUMBER          shift and go to state 66
    &               shift and go to state 67

    PAROP                          shift and go to state 108
    VAL                            shift and go to state 62
    REFERENCE                      shift and go to state 63

state 88

    (60) PRODOP -> PRODOP * . PAROP
    (61) PAROP -> . VAL
    (62) PAROP -> . ( OROP )
    (63) VAL -> . REFERENCE
    (64) VAL -> . ID
    (65) VAL -> . CHAR
    (66) VAL -> . NUMBERF
    (67) VAL -> . NUMBER
    (68) REFERENCE -> . & ID
    (               shift and go to state 44
    ID              shift and go to state 75
    CHAR            shift and go to state 64
    NUMBERF         shift and go to state 65
    NUMBER          shift and go to state 66
    &               shift and go to state 67

    PAROP                          shift and go to state 109
    VAL                            shift and go to state 62
    REFERENCE                      shift and go to state 63

state 89

    (68) REFERENCE -> & ID .
    /               reduce using rule 68 (REFERENCE -> & ID .)
    *               reduce using rule 68 (REFERENCE -> & ID .)
    -               reduce using rule 68 (REFERENCE -> & ID .)
    +               reduce using rule 68 (REFERENCE -> & ID .)
    COMPSIMB        reduce using rule 68 (REFERENCE -> & ID .)
    ANDSIMB         reduce using rule 68 (REFERENCE -> & ID .)
    ORSIMB          reduce using rule 68 (REFERENCE -> & ID .)
    ;               reduce using rule 68 (REFERENCE -> & ID .)
    ,               reduce using rule 68 (REFERENCE -> & ID .)
    )               reduce using rule 68 (REFERENCE -> & ID .)


state 90

    (11) RARGS -> , TYPE ARG . RARGS
    (10) RARGS -> .
    (11) RARGS -> . , TYPE ARG RARGS
    )               reduce using rule 10 (RARGS -> .)
    ,               shift and go to state 40

    RARGS                          shift and go to state 110

state 91

    (7) FUNCTION -> TYPE ID emptyF1 ( ARGS ) { LINES } . emptyF2
    (13) emptyF2 -> .
    TYPE            reduce using rule 13 (emptyF2 -> .)
    VOIDTYPE        reduce using rule 13 (emptyF2 -> .)

    emptyF2                        shift and go to state 111

state 92

    (6) FUNCTION -> VOIDTYPE ID emptyF1 ( ARGS ) { LINES } . emptyF2
    (13) emptyF2 -> .
    TYPE            reduce using rule 13 (emptyF2 -> .)
    VOIDTYPE        reduce using rule 13 (emptyF2 -> .)

    emptyF2                        shift and go to state 112

state 93

    (34) DECLAR -> TYPE POINTERS IDPRIMA .
    ;               reduce using rule 34 (DECLAR -> TYPE POINTERS IDPRIMA .)


state 94

    (37) IDPRIMA -> empty . ELEM REST
    (40) ELEM -> . ID = INSTR
    (41) ELEM -> . ID ARRAY
    ID              shift and go to state 29

    ELEM                           shift and go to state 113

state 95

    (36) POINTERS -> * POINTERS .
    ID              reduce using rule 36 (POINTERS -> * POINTERS .)


state 96

    (62) PAROP -> ( OROP ) .
    /               reduce using rule 62 (PAROP -> ( OROP ) .)
    *               reduce using rule 62 (PAROP -> ( OROP ) .)
    -               reduce using rule 62 (PAROP -> ( OROP ) .)
    +               reduce using rule 62 (PAROP -> ( OROP ) .)
    COMPSIMB        reduce using rule 62 (PAROP -> ( OROP ) .)
    ANDSIMB         reduce using rule 62 (PAROP -> ( OROP ) .)
    ORSIMB          reduce using rule 62 (PAROP -> ( OROP ) .)
    ;               reduce using rule 62 (PAROP -> ( OROP ) .)
    ,               reduce using rule 62 (PAROP -> ( OROP ) .)
    )               reduce using rule 62 (PAROP -> ( OROP ) .)


state 97

    (17) LINE -> PRINT ( STRING . PRINTIDS )
    (23) PRINTIDS -> .
    (24) PRINTIDS -> . , INSTR PRINTIDS
    )               reduce using rule 23 (PRINTIDS -> .)
    ,               shift and go to state 115

    PRINTIDS                       shift and go to state 114

state 98

    (18) LINE -> SCANF ( STRING . SCANIDS )
    (21) SCANIDS -> .
    (22) SCANIDS -> . , REFERENCE SCANIDS
    )               reduce using rule 21 (SCANIDS -> .)
    ,               shift and go to state 117

    SCANIDS                        shift and go to state 116

state 99

    (48) OROP -> OROP ORSIMB ANDOP .
    (50) ANDOP -> ANDOP . ANDSIMB NOTOP
    ORSIMB          reduce using rule 48 (OROP -> OROP ORSIMB ANDOP .)
    ;               reduce using rule 48 (OROP -> OROP ORSIMB ANDOP .)
    ,               reduce using rule 48 (OROP -> OROP ORSIMB ANDOP .)
    )               reduce using rule 48 (OROP -> OROP ORSIMB ANDOP .)
    ANDSIMB         shift and go to state 82


state 100

    (28) FCALL -> ID ( FARGS . )
    )               shift and go to state 118


state 101

    (30) FARGS -> FARG . RFARGS
    (31) RFARGS -> .
    (32) RFARGS -> . , FARG RFARGS
    )               reduce using rule 31 (RFARGS -> .)
    ,               shift and go to state 120

    RFARGS                         shift and go to state 119

state 102

    (33) FARG -> VAL .
    ,               reduce using rule 33 (FARG -> VAL .)
    )               reduce using rule 33 (FARG -> VAL .)


state 103

    (46) ASIG -> ID = INSTR .
    ;               reduce using rule 46 (ASIG -> ID = INSTR .)
    ,               reduce using rule 46 (ASIG -> ID = INSTR .)
    )               reduce using rule 46 (ASIG -> ID = INSTR .)


state 104

    (50) ANDOP -> ANDOP ANDSIMB NOTOP .
    ANDSIMB         reduce using rule 50 (ANDOP -> ANDOP ANDSIMB NOTOP .)
    ORSIMB          reduce using rule 50 (ANDOP -> ANDOP ANDSIMB NOTOP .)
    ;               reduce using rule 50 (ANDOP -> ANDOP ANDSIMB NOTOP .)
    ,               reduce using rule 50 (ANDOP -> ANDOP ANDSIMB NOTOP .)
    )               reduce using rule 50 (ANDOP -> ANDOP ANDSIMB NOTOP .)


state 105

    (54) COMPOP -> COMPOP COMPSIMB ADDOP .
    (56) ADDOP -> ADDOP . - PRODOP
    (57) ADDOP -> ADDOP . + PRODOP
    COMPSIMB        reduce using rule 54 (COMPOP -> COMPOP COMPSIMB ADDOP .)
    ANDSIMB         reduce using rule 54 (COMPOP -> COMPOP COMPSIMB ADDOP .)
    ORSIMB          reduce using rule 54 (COMPOP -> COMPOP COMPSIMB ADDOP .)
    ;               reduce using rule 54 (COMPOP -> COMPOP COMPSIMB ADDOP .)
    ,               reduce using rule 54 (COMPOP -> COMPOP COMPSIMB ADDOP .)
    )               reduce using rule 54 (COMPOP -> COMPOP COMPSIMB ADDOP .)
    -               shift and go to state 85
    +               shift and go to state 86


state 106

    (56) ADDOP -> ADDOP - PRODOP .
    (59) PRODOP -> PRODOP . / PAROP
    (60) PRODOP -> PRODOP . * PAROP
    -               reduce using rule 56 (ADDOP -> ADDOP - PRODOP .)
    +               reduce using rule 56 (ADDOP -> ADDOP - PRODOP .)
    COMPSIMB        reduce using rule 56 (ADDOP -> ADDOP - PRODOP .)
    ANDSIMB         reduce using rule 56 (ADDOP -> ADDOP - PRODOP .)
    ORSIMB          reduce using rule 56 (ADDOP -> ADDOP - PRODOP .)
    ;               reduce using rule 56 (ADDOP -> ADDOP - PRODOP .)
    ,               reduce using rule 56 (ADDOP -> ADDOP - PRODOP .)
    )               reduce using rule 56 (ADDOP -> ADDOP - PRODOP .)
    /               shift and go to state 87
    *               shift and go to state 88


state 107

    (57) ADDOP -> ADDOP + PRODOP .
    (59) PRODOP -> PRODOP . / PAROP
    (60) PRODOP -> PRODOP . * PAROP
    -               reduce using rule 57 (ADDOP -> ADDOP + PRODOP .)
    +               reduce using rule 57 (ADDOP -> ADDOP + PRODOP .)
    COMPSIMB        reduce using rule 57 (ADDOP -> ADDOP + PRODOP .)
    ANDSIMB         reduce using rule 57 (ADDOP -> ADDOP + PRODOP .)
    ORSIMB          reduce using rule 57 (ADDOP -> ADDOP + PRODOP .)
    ;               reduce using rule 57 (ADDOP -> ADDOP + PRODOP .)
    ,               reduce using rule 57 (ADDOP -> ADDOP + PRODOP .)
    )               reduce using rule 57 (ADDOP -> ADDOP + PRODOP .)
    /               shift and go to state 87
    *               shift and go to state 88


state 108

    (59) PRODOP -> PRODOP / PAROP .
    /               reduce using rule 59 (PRODOP -> PRODOP / PAROP .)
    *               reduce using rule 59 (PRODOP -> PRODOP / PAROP .)
    -               reduce using rule 59 (PRODOP -> PRODOP / PAROP .)
    +               reduce using rule 59 (PRODOP -> PRODOP / PAROP .)
    COMPSIMB        reduce using rule 59 (PRODOP -> PRODOP / PAROP .)
    ANDSIMB         reduce using rule 59 (PRODOP -> PRODOP / PAROP .)
    ORSIMB          reduce using rule 59 (PRODOP -> PRODOP / PAROP .)
    ;               reduce using rule 59 (PRODOP -> PRODOP / PAROP .)
    ,               reduce using rule 59 (PRODOP -> PRODOP / PAROP .)
    )               reduce using rule 59 (PRODOP -> PRODOP / PAROP .)


state 109

    (60) PRODOP -> PRODOP * PAROP .
    /               reduce using rule 60 (PRODOP -> PRODOP * PAROP .)
    *               reduce using rule 60 (PRODOP -> PRODOP * PAROP .)
    -               reduce using rule 60 (PRODOP -> PRODOP * PAROP .)
    +               reduce using rule 60 (PRODOP -> PRODOP * PAROP .)
    COMPSIMB        reduce using rule 60 (PRODOP -> PRODOP * PAROP .)
    ANDSIMB         reduce using rule 60 (PRODOP -> PRODOP * PAROP .)
    ORSIMB          reduce using rule 60 (PRODOP -> PRODOP * PAROP .)
    ;               reduce using rule 60 (PRODOP -> PRODOP * PAROP .)
    ,               reduce using rule 60 (PRODOP -> PRODOP * PAROP .)
    )               reduce using rule 60 (PRODOP -> PRODOP * PAROP .)


state 110

    (11) RARGS -> , TYPE ARG RARGS .
    )               reduce using rule 11 (RARGS -> , TYPE ARG RARGS .)


state 111

    (7) FUNCTION -> TYPE ID emptyF1 ( ARGS ) { LINES } emptyF2 .
    TYPE            reduce using rule 7 (FUNCTION -> TYPE ID emptyF1 ( ARGS ) { LINES } emptyF2 .)
    VOIDTYPE        reduce using rule 7 (FUNCTION -> TYPE ID emptyF1 ( ARGS ) { LINES } emptyF2 .)


state 112

    (6) FUNCTION -> VOIDTYPE ID emptyF1 ( ARGS ) { LINES } emptyF2 .
    TYPE            reduce using rule 6 (FUNCTION -> VOIDTYPE ID emptyF1 ( ARGS ) { LINES } emptyF2 .)
    VOIDTYPE        reduce using rule 6 (FUNCTION -> VOIDTYPE ID emptyF1 ( ARGS ) { LINES } emptyF2 .)


state 113

    (37) IDPRIMA -> empty ELEM . REST
    (38) REST -> .
    (39) REST -> . , empty2 ELEM REST
    ;               reduce using rule 38 (REST -> .)
    ,               shift and go to state 16

    REST                           shift and go to state 121

state 114

    (17) LINE -> PRINT ( STRING PRINTIDS . )
    )               shift and go to state 122


state 115

    (24) PRINTIDS -> , . INSTR PRINTIDS
    (25) INSTR -> . FCALL
    (26) INSTR -> . OROP
    (27) INSTR -> . ASIG
    (28) FCALL -> . ID ( FARGS )
    (47) OROP -> . ANDOP
    (48) OROP -> . OROP ORSIMB ANDOP
    (46) ASIG -> . ID = INSTR
    (49) ANDOP -> . NOTOP
    (50) ANDOP -> . ANDOP ANDSIMB NOTOP
    (51) NOTOP -> . COMPOP
    (52) NOTOP -> . ! NOTOP
    (53) COMPOP -> . ADDOP
    (54) COMPOP -> . COMPOP COMPSIMB ADDOP
    (55) ADDOP -> . PRODOP
    (56) ADDOP -> . ADDOP - PRODOP
    (57) ADDOP -> . ADDOP + PRODOP
    (58) PRODOP -> . PAROP
    (59) PRODOP -> . PRODOP / PAROP
    (60) PRODOP -> . PRODOP * PAROP
    (61) PAROP -> . VAL
    (62) PAROP -> . ( OROP )
    (63) VAL -> . REFERENCE
    (64) VAL -> . ID
    (65) VAL -> . CHAR
    (66) VAL -> . NUMBERF
    (67) VAL -> . NUMBER
    (68) REFERENCE -> . & ID
    ID              shift and go to state 54
    !               shift and go to state 58
    (               shift and go to state 44
    CHAR            shift and go to state 64
    NUMBERF         shift and go to state 65
    NUMBER          shift and go to state 66
    &               shift and go to state 67

    INSTR                          shift and go to state 123
    FCALL                          shift and go to state 51
    OROP                           shift and go to state 52
    ASIG                           shift and go to state 53
    ANDOP                          shift and go to state 55
    NOTOP                          shift and go to state 56
    COMPOP                         shift and go to state 57
    ADDOP                          shift and go to state 59
    PRODOP                         shift and go to state 60
    PAROP                          shift and go to state 61
    VAL                            shift and go to state 62
    REFERENCE                      shift and go to state 63

state 116

    (18) LINE -> SCANF ( STRING SCANIDS . )
    )               shift and go to state 124


state 117

    (22) SCANIDS -> , . REFERENCE SCANIDS
    (68) REFERENCE -> . & ID
    &               shift and go to state 67

    REFERENCE                      shift and go to state 125

state 118

    (28) FCALL -> ID ( FARGS ) .
    ;               reduce using rule 28 (FCALL -> ID ( FARGS ) .)
    ,               reduce using rule 28 (FCALL -> ID ( FARGS ) .)
    )               reduce using rule 28 (FCALL -> ID ( FARGS ) .)


state 119

    (30) FARGS -> FARG RFARGS .
    )               reduce using rule 30 (FARGS -> FARG RFARGS .)


state 120

    (32) RFARGS -> , . FARG RFARGS
    (33) FARG -> . VAL
    (63) VAL -> . REFERENCE
    (64) VAL -> . ID
    (65) VAL -> . CHAR
    (66) VAL -> . NUMBERF
    (67) VAL -> . NUMBER
    (68) REFERENCE -> . & ID
    ID              shift and go to state 75
    CHAR            shift and go to state 64
    NUMBERF         shift and go to state 65
    NUMBER          shift and go to state 66
    &               shift and go to state 67

    FARG                           shift and go to state 126
    VAL                            shift and go to state 102
    REFERENCE                      shift and go to state 63

state 121

    (37) IDPRIMA -> empty ELEM REST .
    ;               reduce using rule 37 (IDPRIMA -> empty ELEM REST .)


state 122

    (17) LINE -> PRINT ( STRING PRINTIDS ) .
    ;               reduce using rule 17 (LINE -> PRINT ( STRING PRINTIDS ) .)


state 123

    (24) PRINTIDS -> , INSTR . PRINTIDS
    (23) PRINTIDS -> .
    (24) PRINTIDS -> . , INSTR PRINTIDS
    )               reduce using rule 23 (PRINTIDS -> .)
    ,               shift and go to state 115

    PRINTIDS                       shift and go to state 127

state 124

    (18) LINE -> SCANF ( STRING SCANIDS ) .
    ;               reduce using rule 18 (LINE -> SCANF ( STRING SCANIDS ) .)


state 125

    (22) SCANIDS -> , REFERENCE . SCANIDS
    (21) SCANIDS -> .
    (22) SCANIDS -> . , REFERENCE SCANIDS
    )               reduce using rule 21 (SCANIDS -> .)
    ,               shift and go to state 117

    SCANIDS                        shift and go to state 128

state 126

    (32) RFARGS -> , FARG . RFARGS
    (31) RFARGS -> .
    (32) RFARGS -> . , FARG RFARGS
    )               reduce using rule 31 (RFARGS -> .)
    ,               shift and go to state 120

    RFARGS                         shift and go to state 129

state 127

    (24) PRINTIDS -> , INSTR PRINTIDS .
    )               reduce using rule 24 (PRINTIDS -> , INSTR PRINTIDS .)


state 128

    (22) SCANIDS -> , REFERENCE SCANIDS .
    )               reduce using rule 22 (SCANIDS -> , REFERENCE SCANIDS .)


state 129

    (32) RFARGS -> , FARG RFARGS .
    )               reduce using rule 32 (RFARGS -> , FARG RFARGS .)
