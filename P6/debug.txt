Grammar:

Rule 0     S' -> S
Rule 1     S -> S2 TYPE emptymain MAIN ( ) { LINES }
Rule 2     emptymain -> <empty>
Rule 3     S2 -> <empty>
Rule 4     S2 -> S2 FUNCTION
Rule 5     FUNCTION -> TYPE ID emptyF1 ( ARGS ) { LINES } emptyF2
Rule 6     ARGS -> <empty>
Rule 7     ARGS -> TYPE ARG RARGS
Rule 8     RARGS -> <empty>
Rule 9     RARGS -> , TYPE ARG RARGS
Rule 10    emptyF1 -> <empty>
Rule 11    emptyF2 -> <empty>
Rule 12    ARG -> ID
Rule 13    LINES -> <empty>
Rule 14    LINES -> LINES LINE ;
Rule 15    LINE -> PRINT ( STRING PRINTIDS )
Rule 16    LINE -> SCANF ( STRING SCANIDS )
Rule 17    LINE -> DECLAR
Rule 18    LINE -> INSTR
Rule 19    SCANIDS -> <empty>
Rule 20    SCANIDS -> , REFERENCE SCANIDS
Rule 21    PRINTIDS -> <empty>
Rule 22    PRINTIDS -> , INSTR PRINTIDS
Rule 23    INSTR -> FCALL
Rule 24    INSTR -> OROP
Rule 25    INSTR -> ASIG
Rule 26    FCALL -> ID ( FARGS )
Rule 27    FARGS -> <empty>
Rule 28    FARGS -> FARG RFARGS
Rule 29    RFARGS -> <empty>
Rule 30    RFARGS -> , FARG RFARGS
Rule 31    FARG -> VAL
Rule 32    DECLAR -> TYPE POINTERS IDPRIMA
Rule 33    POINTERS -> <empty>
Rule 34    POINTERS -> * POINTERS
Rule 35    IDPRIMA -> empty ELEM REST
Rule 36    REST -> <empty>
Rule 37    REST -> , empty2 ELEM REST
Rule 38    ELEM -> ID = INSTR
Rule 39    ELEM -> ID ARRAY
Rule 40    ARRAY -> <empty>
Rule 41    ARRAY -> [ NUMBER ] ARRAY
Rule 42    empty -> <empty>
Rule 43    empty2 -> <empty>
Rule 44    ASIG -> ID = INSTR
Rule 45    OROP -> ANDOP
Rule 46    OROP -> OROP ORSIMB ANDOP
Rule 47    ANDOP -> NOTOP
Rule 48    ANDOP -> ANDOP ANDSIMB NOTOP
Rule 49    NOTOP -> COMPOP
Rule 50    NOTOP -> ! NOTOP
Rule 51    COMPOP -> ADDOP
Rule 52    COMPOP -> COMPOP COMPSIMB ADDOP
Rule 53    ADDOP -> PRODOP
Rule 54    ADDOP -> ADDOP - PRODOP
Rule 55    ADDOP -> ADDOP + PRODOP
Rule 56    PRODOP -> PAROP
Rule 57    PRODOP -> PRODOP / PAROP
Rule 58    PRODOP -> PRODOP * PAROP
Rule 59    PAROP -> VAL
Rule 60    PAROP -> ( OROP )
Rule 61    VAL -> REFERENCE
Rule 62    VAL -> ID
Rule 63    VAL -> CHAR
Rule 64    VAL -> NUMBERF
Rule 65    VAL -> NUMBER
Rule 66    REFERENCE -> & ID

Terminals, with rules where they appear:

!                    : 50
&                    : 66
(                    : 1 5 15 16 26 60
)                    : 1 5 15 16 26 60
*                    : 34 58
+                    : 55
,                    : 9 20 22 30 37
-                    : 54
/                    : 57
;                    : 14
=                    : 38 44
ANDSIMB              : 48
CHAR                 : 63
COMPSIMB             : 52
ID                   : 5 12 26 38 39 44 62 66
MAIN                 : 1
NUMBER               : 41 65
NUMBERF              : 64
ORSIMB               : 46
PRINT                : 15
SCANF                : 16
STRING               : 15 16
TYPE                 : 1 5 7 9 32
[                    : 41
]                    : 41
error                : 
{                    : 1 5
}                    : 1 5

Nonterminals, with rules where they appear:

ADDOP                : 51 52 54 55
ANDOP                : 45 46 48
ARG                  : 7 9
ARGS                 : 5
ARRAY                : 39 41
ASIG                 : 25
COMPOP               : 49 52
DECLAR               : 17
ELEM                 : 35 37
FARG                 : 28 30
FARGS                : 26
FCALL                : 23
FUNCTION             : 4
IDPRIMA              : 32
INSTR                : 18 22 38 44
LINE                 : 14
LINES                : 1 5 14
NOTOP                : 47 48 50
OROP                 : 24 46 60
PAROP                : 56 57 58
POINTERS             : 32 34
PRINTIDS             : 15 22
PRODOP               : 53 54 55 57 58
RARGS                : 7 9
REFERENCE            : 20 61
REST                 : 35 37
RFARGS               : 28 30
S                    : 0
S2                   : 1 4
SCANIDS              : 16 20
VAL                  : 31 59
empty                : 35
empty2               : 37
emptyF1              : 5
emptyF2              : 5
emptymain            : 1


state 0

    (0) S' -> . S
    (1) S -> . S2 TYPE emptymain MAIN ( ) { LINES }
    (3) S2 -> .
    (4) S2 -> . S2 FUNCTION
    TYPE            reduce using rule 3 (S2 -> .)

    S                              shift and go to state 1
    S2                             shift and go to state 2

state 1

    (0) S' -> S .


state 2

    (1) S -> S2 . TYPE emptymain MAIN ( ) { LINES }
    (4) S2 -> S2 . FUNCTION
    (5) FUNCTION -> . TYPE ID emptyF1 ( ARGS ) { LINES } emptyF2
    TYPE            shift and go to state 3

    FUNCTION                       shift and go to state 4

state 3

    (1) S -> S2 TYPE . emptymain MAIN ( ) { LINES }
    (5) FUNCTION -> TYPE . ID emptyF1 ( ARGS ) { LINES } emptyF2
    (2) emptymain -> .
    ID              shift and go to state 6
    MAIN            reduce using rule 2 (emptymain -> .)

    emptymain                      shift and go to state 5

state 4

    (4) S2 -> S2 FUNCTION .
    TYPE            reduce using rule 4 (S2 -> S2 FUNCTION .)


state 5

    (1) S -> S2 TYPE emptymain . MAIN ( ) { LINES }
    MAIN            shift and go to state 7


state 6

    (5) FUNCTION -> TYPE ID . emptyF1 ( ARGS ) { LINES } emptyF2
    (10) emptyF1 -> .
    (               reduce using rule 10 (emptyF1 -> .)

    emptyF1                        shift and go to state 8

state 7

    (1) S -> S2 TYPE emptymain MAIN . ( ) { LINES }
    (               shift and go to state 9


state 8

    (5) FUNCTION -> TYPE ID emptyF1 . ( ARGS ) { LINES } emptyF2
    (               shift and go to state 10


state 9

    (1) S -> S2 TYPE emptymain MAIN ( . ) { LINES }
    )               shift and go to state 11


state 10

    (5) FUNCTION -> TYPE ID emptyF1 ( . ARGS ) { LINES } emptyF2
    (6) ARGS -> .
    (7) ARGS -> . TYPE ARG RARGS
    )               reduce using rule 6 (ARGS -> .)
    TYPE            shift and go to state 12

    ARGS                           shift and go to state 13

state 11

    (1) S -> S2 TYPE emptymain MAIN ( ) . { LINES }
    {               shift and go to state 14


state 12

    (7) ARGS -> TYPE . ARG RARGS
    (12) ARG -> . ID
    ID              shift and go to state 16

    ARG                            shift and go to state 15

state 13

    (5) FUNCTION -> TYPE ID emptyF1 ( ARGS . ) { LINES } emptyF2
    )               shift and go to state 17


state 14

    (1) S -> S2 TYPE emptymain MAIN ( ) { . LINES }
    (13) LINES -> .
    (14) LINES -> . LINES LINE ;
    }               reduce using rule 13 (LINES -> .)
    PRINT           reduce using rule 13 (LINES -> .)
    SCANF           reduce using rule 13 (LINES -> .)
    TYPE            reduce using rule 13 (LINES -> .)
    ID              reduce using rule 13 (LINES -> .)
    !               reduce using rule 13 (LINES -> .)
    (               reduce using rule 13 (LINES -> .)
    CHAR            reduce using rule 13 (LINES -> .)
    NUMBERF         reduce using rule 13 (LINES -> .)
    NUMBER          reduce using rule 13 (LINES -> .)
    &               reduce using rule 13 (LINES -> .)

    LINES                          shift and go to state 18

state 15

    (7) ARGS -> TYPE ARG . RARGS
    (8) RARGS -> .
    (9) RARGS -> . , TYPE ARG RARGS
    )               reduce using rule 8 (RARGS -> .)
    ,               shift and go to state 20

    RARGS                          shift and go to state 19

state 16

    (12) ARG -> ID .
    ,               reduce using rule 12 (ARG -> ID .)
    )               reduce using rule 12 (ARG -> ID .)


state 17

    (5) FUNCTION -> TYPE ID emptyF1 ( ARGS ) . { LINES } emptyF2
    {               shift and go to state 21


state 18

    (1) S -> S2 TYPE emptymain MAIN ( ) { LINES . }
    (14) LINES -> LINES . LINE ;
    (15) LINE -> . PRINT ( STRING PRINTIDS )
    (16) LINE -> . SCANF ( STRING SCANIDS )
    (17) LINE -> . DECLAR
    (18) LINE -> . INSTR
    (32) DECLAR -> . TYPE POINTERS IDPRIMA
    (23) INSTR -> . FCALL
    (24) INSTR -> . OROP
    (25) INSTR -> . ASIG
    (26) FCALL -> . ID ( FARGS )
    (45) OROP -> . ANDOP
    (46) OROP -> . OROP ORSIMB ANDOP
    (44) ASIG -> . ID = INSTR
    (47) ANDOP -> . NOTOP
    (48) ANDOP -> . ANDOP ANDSIMB NOTOP
    (49) NOTOP -> . COMPOP
    (50) NOTOP -> . ! NOTOP
    (51) COMPOP -> . ADDOP
    (52) COMPOP -> . COMPOP COMPSIMB ADDOP
    (53) ADDOP -> . PRODOP
    (54) ADDOP -> . ADDOP - PRODOP
    (55) ADDOP -> . ADDOP + PRODOP
    (56) PRODOP -> . PAROP
    (57) PRODOP -> . PRODOP / PAROP
    (58) PRODOP -> . PRODOP * PAROP
    (59) PAROP -> . VAL
    (60) PAROP -> . ( OROP )
    (61) VAL -> . REFERENCE
    (62) VAL -> . ID
    (63) VAL -> . CHAR
    (64) VAL -> . NUMBERF
    (65) VAL -> . NUMBER
    (66) REFERENCE -> . & ID
    }               shift and go to state 24
    PRINT           shift and go to state 26
    SCANF           shift and go to state 27
    TYPE            shift and go to state 22
    ID              shift and go to state 33
    !               shift and go to state 37
    (               shift and go to state 23
    CHAR            shift and go to state 43
    NUMBERF         shift and go to state 44
    NUMBER          shift and go to state 45
    &               shift and go to state 46

    LINE                           shift and go to state 25
    DECLAR                         shift and go to state 28
    INSTR                          shift and go to state 29
    FCALL                          shift and go to state 30
    OROP                           shift and go to state 31
    ASIG                           shift and go to state 32
    ANDOP                          shift and go to state 34
    NOTOP                          shift and go to state 35
    COMPOP                         shift and go to state 36
    ADDOP                          shift and go to state 38
    PRODOP                         shift and go to state 39
    PAROP                          shift and go to state 40
    VAL                            shift and go to state 41
    REFERENCE                      shift and go to state 42

state 19

    (7) ARGS -> TYPE ARG RARGS .
    )               reduce using rule 7 (ARGS -> TYPE ARG RARGS .)


state 20

    (9) RARGS -> , . TYPE ARG RARGS
    TYPE            shift and go to state 47


state 21

    (5) FUNCTION -> TYPE ID emptyF1 ( ARGS ) { . LINES } emptyF2
    (13) LINES -> .
    (14) LINES -> . LINES LINE ;
    }               reduce using rule 13 (LINES -> .)
    PRINT           reduce using rule 13 (LINES -> .)
    SCANF           reduce using rule 13 (LINES -> .)
    TYPE            reduce using rule 13 (LINES -> .)
    ID              reduce using rule 13 (LINES -> .)
    !               reduce using rule 13 (LINES -> .)
    (               reduce using rule 13 (LINES -> .)
    CHAR            reduce using rule 13 (LINES -> .)
    NUMBERF         reduce using rule 13 (LINES -> .)
    NUMBER          reduce using rule 13 (LINES -> .)
    &               reduce using rule 13 (LINES -> .)

    LINES                          shift and go to state 48

state 22

    (32) DECLAR -> TYPE . POINTERS IDPRIMA
    (33) POINTERS -> .
    (34) POINTERS -> . * POINTERS
    ID              reduce using rule 33 (POINTERS -> .)
    *               shift and go to state 50

    POINTERS                       shift and go to state 49

state 23

    (60) PAROP -> ( . OROP )
    (45) OROP -> . ANDOP
    (46) OROP -> . OROP ORSIMB ANDOP
    (47) ANDOP -> . NOTOP
    (48) ANDOP -> . ANDOP ANDSIMB NOTOP
    (49) NOTOP -> . COMPOP
    (50) NOTOP -> . ! NOTOP
    (51) COMPOP -> . ADDOP
    (52) COMPOP -> . COMPOP COMPSIMB ADDOP
    (53) ADDOP -> . PRODOP
    (54) ADDOP -> . ADDOP - PRODOP
    (55) ADDOP -> . ADDOP + PRODOP
    (56) PRODOP -> . PAROP
    (57) PRODOP -> . PRODOP / PAROP
    (58) PRODOP -> . PRODOP * PAROP
    (59) PAROP -> . VAL
    (60) PAROP -> . ( OROP )
    (61) VAL -> . REFERENCE
    (62) VAL -> . ID
    (63) VAL -> . CHAR
    (64) VAL -> . NUMBERF
    (65) VAL -> . NUMBER
    (66) REFERENCE -> . & ID
    !               shift and go to state 37
    (               shift and go to state 23
    ID              shift and go to state 52
    CHAR            shift and go to state 43
    NUMBERF         shift and go to state 44
    NUMBER          shift and go to state 45
    &               shift and go to state 46

    OROP                           shift and go to state 51
    ANDOP                          shift and go to state 34
    NOTOP                          shift and go to state 35
    COMPOP                         shift and go to state 36
    ADDOP                          shift and go to state 38
    PRODOP                         shift and go to state 39
    PAROP                          shift and go to state 40
    VAL                            shift and go to state 41
    REFERENCE                      shift and go to state 42

state 24

    (1) S -> S2 TYPE emptymain MAIN ( ) { LINES } .
    $end            reduce using rule 1 (S -> S2 TYPE emptymain MAIN ( ) { LINES } .)


state 25

    (14) LINES -> LINES LINE . ;
    ;               shift and go to state 53


state 26

    (15) LINE -> PRINT . ( STRING PRINTIDS )
    (               shift and go to state 54


state 27

    (16) LINE -> SCANF . ( STRING SCANIDS )
    (               shift and go to state 55


state 28

    (17) LINE -> DECLAR .
    ;               reduce using rule 17 (LINE -> DECLAR .)


state 29

    (18) LINE -> INSTR .
    ;               reduce using rule 18 (LINE -> INSTR .)


state 30

    (23) INSTR -> FCALL .
    ;               reduce using rule 23 (INSTR -> FCALL .)
    ,               reduce using rule 23 (INSTR -> FCALL .)
    )               reduce using rule 23 (INSTR -> FCALL .)


state 31

    (24) INSTR -> OROP .
    (46) OROP -> OROP . ORSIMB ANDOP
    ;               reduce using rule 24 (INSTR -> OROP .)
    ,               reduce using rule 24 (INSTR -> OROP .)
    )               reduce using rule 24 (INSTR -> OROP .)
    ORSIMB          shift and go to state 56


state 32

    (25) INSTR -> ASIG .
    ;               reduce using rule 25 (INSTR -> ASIG .)
    ,               reduce using rule 25 (INSTR -> ASIG .)
    )               reduce using rule 25 (INSTR -> ASIG .)


state 33

    (26) FCALL -> ID . ( FARGS )
    (44) ASIG -> ID . = INSTR
    (62) VAL -> ID .
    (               shift and go to state 57
    =               shift and go to state 58
    /               reduce using rule 62 (VAL -> ID .)
    *               reduce using rule 62 (VAL -> ID .)
    -               reduce using rule 62 (VAL -> ID .)
    +               reduce using rule 62 (VAL -> ID .)
    COMPSIMB        reduce using rule 62 (VAL -> ID .)
    ANDSIMB         reduce using rule 62 (VAL -> ID .)
    ORSIMB          reduce using rule 62 (VAL -> ID .)
    ;               reduce using rule 62 (VAL -> ID .)
    ,               reduce using rule 62 (VAL -> ID .)
    )               reduce using rule 62 (VAL -> ID .)


state 34

    (45) OROP -> ANDOP .
    (48) ANDOP -> ANDOP . ANDSIMB NOTOP
    ORSIMB          reduce using rule 45 (OROP -> ANDOP .)
    ;               reduce using rule 45 (OROP -> ANDOP .)
    )               reduce using rule 45 (OROP -> ANDOP .)
    ,               reduce using rule 45 (OROP -> ANDOP .)
    ANDSIMB         shift and go to state 59


state 35

    (47) ANDOP -> NOTOP .
    ANDSIMB         reduce using rule 47 (ANDOP -> NOTOP .)
    ORSIMB          reduce using rule 47 (ANDOP -> NOTOP .)
    ;               reduce using rule 47 (ANDOP -> NOTOP .)
    )               reduce using rule 47 (ANDOP -> NOTOP .)
    ,               reduce using rule 47 (ANDOP -> NOTOP .)


state 36

    (49) NOTOP -> COMPOP .
    (52) COMPOP -> COMPOP . COMPSIMB ADDOP
    ANDSIMB         reduce using rule 49 (NOTOP -> COMPOP .)
    ORSIMB          reduce using rule 49 (NOTOP -> COMPOP .)
    ;               reduce using rule 49 (NOTOP -> COMPOP .)
    )               reduce using rule 49 (NOTOP -> COMPOP .)
    ,               reduce using rule 49 (NOTOP -> COMPOP .)
    COMPSIMB        shift and go to state 60


state 37

    (50) NOTOP -> ! . NOTOP
    (49) NOTOP -> . COMPOP
    (50) NOTOP -> . ! NOTOP
    (51) COMPOP -> . ADDOP
    (52) COMPOP -> . COMPOP COMPSIMB ADDOP
    (53) ADDOP -> . PRODOP
    (54) ADDOP -> . ADDOP - PRODOP
    (55) ADDOP -> . ADDOP + PRODOP
    (56) PRODOP -> . PAROP
    (57) PRODOP -> . PRODOP / PAROP
    (58) PRODOP -> . PRODOP * PAROP
    (59) PAROP -> . VAL
    (60) PAROP -> . ( OROP )
    (61) VAL -> . REFERENCE
    (62) VAL -> . ID
    (63) VAL -> . CHAR
    (64) VAL -> . NUMBERF
    (65) VAL -> . NUMBER
    (66) REFERENCE -> . & ID
    !               shift and go to state 37
    (               shift and go to state 23
    ID              shift and go to state 52
    CHAR            shift and go to state 43
    NUMBERF         shift and go to state 44
    NUMBER          shift and go to state 45
    &               shift and go to state 46

    NOTOP                          shift and go to state 61
    COMPOP                         shift and go to state 36
    ADDOP                          shift and go to state 38
    PRODOP                         shift and go to state 39
    PAROP                          shift and go to state 40
    VAL                            shift and go to state 41
    REFERENCE                      shift and go to state 42

state 38

    (51) COMPOP -> ADDOP .
    (54) ADDOP -> ADDOP . - PRODOP
    (55) ADDOP -> ADDOP . + PRODOP
    COMPSIMB        reduce using rule 51 (COMPOP -> ADDOP .)
    ANDSIMB         reduce using rule 51 (COMPOP -> ADDOP .)
    ORSIMB          reduce using rule 51 (COMPOP -> ADDOP .)
    ;               reduce using rule 51 (COMPOP -> ADDOP .)
    )               reduce using rule 51 (COMPOP -> ADDOP .)
    ,               reduce using rule 51 (COMPOP -> ADDOP .)
    -               shift and go to state 62
    +               shift and go to state 63


state 39

    (53) ADDOP -> PRODOP .
    (57) PRODOP -> PRODOP . / PAROP
    (58) PRODOP -> PRODOP . * PAROP
    -               reduce using rule 53 (ADDOP -> PRODOP .)
    +               reduce using rule 53 (ADDOP -> PRODOP .)
    COMPSIMB        reduce using rule 53 (ADDOP -> PRODOP .)
    ANDSIMB         reduce using rule 53 (ADDOP -> PRODOP .)
    ORSIMB          reduce using rule 53 (ADDOP -> PRODOP .)
    ;               reduce using rule 53 (ADDOP -> PRODOP .)
    )               reduce using rule 53 (ADDOP -> PRODOP .)
    ,               reduce using rule 53 (ADDOP -> PRODOP .)
    /               shift and go to state 64
    *               shift and go to state 65


state 40

    (56) PRODOP -> PAROP .
    /               reduce using rule 56 (PRODOP -> PAROP .)
    *               reduce using rule 56 (PRODOP -> PAROP .)
    -               reduce using rule 56 (PRODOP -> PAROP .)
    +               reduce using rule 56 (PRODOP -> PAROP .)
    COMPSIMB        reduce using rule 56 (PRODOP -> PAROP .)
    ANDSIMB         reduce using rule 56 (PRODOP -> PAROP .)
    ORSIMB          reduce using rule 56 (PRODOP -> PAROP .)
    ;               reduce using rule 56 (PRODOP -> PAROP .)
    )               reduce using rule 56 (PRODOP -> PAROP .)
    ,               reduce using rule 56 (PRODOP -> PAROP .)


state 41

    (59) PAROP -> VAL .
    /               reduce using rule 59 (PAROP -> VAL .)
    *               reduce using rule 59 (PAROP -> VAL .)
    -               reduce using rule 59 (PAROP -> VAL .)
    +               reduce using rule 59 (PAROP -> VAL .)
    COMPSIMB        reduce using rule 59 (PAROP -> VAL .)
    ANDSIMB         reduce using rule 59 (PAROP -> VAL .)
    ORSIMB          reduce using rule 59 (PAROP -> VAL .)
    ;               reduce using rule 59 (PAROP -> VAL .)
    )               reduce using rule 59 (PAROP -> VAL .)
    ,               reduce using rule 59 (PAROP -> VAL .)


state 42

    (61) VAL -> REFERENCE .
    /               reduce using rule 61 (VAL -> REFERENCE .)
    *               reduce using rule 61 (VAL -> REFERENCE .)
    -               reduce using rule 61 (VAL -> REFERENCE .)
    +               reduce using rule 61 (VAL -> REFERENCE .)
    COMPSIMB        reduce using rule 61 (VAL -> REFERENCE .)
    ANDSIMB         reduce using rule 61 (VAL -> REFERENCE .)
    ORSIMB          reduce using rule 61 (VAL -> REFERENCE .)
    ;               reduce using rule 61 (VAL -> REFERENCE .)
    )               reduce using rule 61 (VAL -> REFERENCE .)
    ,               reduce using rule 61 (VAL -> REFERENCE .)


state 43

    (63) VAL -> CHAR .
    /               reduce using rule 63 (VAL -> CHAR .)
    *               reduce using rule 63 (VAL -> CHAR .)
    -               reduce using rule 63 (VAL -> CHAR .)
    +               reduce using rule 63 (VAL -> CHAR .)
    COMPSIMB        reduce using rule 63 (VAL -> CHAR .)
    ANDSIMB         reduce using rule 63 (VAL -> CHAR .)
    ORSIMB          reduce using rule 63 (VAL -> CHAR .)
    ;               reduce using rule 63 (VAL -> CHAR .)
    )               reduce using rule 63 (VAL -> CHAR .)
    ,               reduce using rule 63 (VAL -> CHAR .)


state 44

    (64) VAL -> NUMBERF .
    /               reduce using rule 64 (VAL -> NUMBERF .)
    *               reduce using rule 64 (VAL -> NUMBERF .)
    -               reduce using rule 64 (VAL -> NUMBERF .)
    +               reduce using rule 64 (VAL -> NUMBERF .)
    COMPSIMB        reduce using rule 64 (VAL -> NUMBERF .)
    ANDSIMB         reduce using rule 64 (VAL -> NUMBERF .)
    ORSIMB          reduce using rule 64 (VAL -> NUMBERF .)
    ;               reduce using rule 64 (VAL -> NUMBERF .)
    )               reduce using rule 64 (VAL -> NUMBERF .)
    ,               reduce using rule 64 (VAL -> NUMBERF .)


state 45

    (65) VAL -> NUMBER .
    /               reduce using rule 65 (VAL -> NUMBER .)
    *               reduce using rule 65 (VAL -> NUMBER .)
    -               reduce using rule 65 (VAL -> NUMBER .)
    +               reduce using rule 65 (VAL -> NUMBER .)
    COMPSIMB        reduce using rule 65 (VAL -> NUMBER .)
    ANDSIMB         reduce using rule 65 (VAL -> NUMBER .)
    ORSIMB          reduce using rule 65 (VAL -> NUMBER .)
    ;               reduce using rule 65 (VAL -> NUMBER .)
    )               reduce using rule 65 (VAL -> NUMBER .)
    ,               reduce using rule 65 (VAL -> NUMBER .)


state 46

    (66) REFERENCE -> & . ID
    ID              shift and go to state 66


state 47

    (9) RARGS -> , TYPE . ARG RARGS
    (12) ARG -> . ID
    ID              shift and go to state 16

    ARG                            shift and go to state 67

state 48

    (5) FUNCTION -> TYPE ID emptyF1 ( ARGS ) { LINES . } emptyF2
    (14) LINES -> LINES . LINE ;
    (15) LINE -> . PRINT ( STRING PRINTIDS )
    (16) LINE -> . SCANF ( STRING SCANIDS )
    (17) LINE -> . DECLAR
    (18) LINE -> . INSTR
    (32) DECLAR -> . TYPE POINTERS IDPRIMA
    (23) INSTR -> . FCALL
    (24) INSTR -> . OROP
    (25) INSTR -> . ASIG
    (26) FCALL -> . ID ( FARGS )
    (45) OROP -> . ANDOP
    (46) OROP -> . OROP ORSIMB ANDOP
    (44) ASIG -> . ID = INSTR
    (47) ANDOP -> . NOTOP
    (48) ANDOP -> . ANDOP ANDSIMB NOTOP
    (49) NOTOP -> . COMPOP
    (50) NOTOP -> . ! NOTOP
    (51) COMPOP -> . ADDOP
    (52) COMPOP -> . COMPOP COMPSIMB ADDOP
    (53) ADDOP -> . PRODOP
    (54) ADDOP -> . ADDOP - PRODOP
    (55) ADDOP -> . ADDOP + PRODOP
    (56) PRODOP -> . PAROP
    (57) PRODOP -> . PRODOP / PAROP
    (58) PRODOP -> . PRODOP * PAROP
    (59) PAROP -> . VAL
    (60) PAROP -> . ( OROP )
    (61) VAL -> . REFERENCE
    (62) VAL -> . ID
    (63) VAL -> . CHAR
    (64) VAL -> . NUMBERF
    (65) VAL -> . NUMBER
    (66) REFERENCE -> . & ID
    }               shift and go to state 68
    PRINT           shift and go to state 26
    SCANF           shift and go to state 27
    TYPE            shift and go to state 22
    ID              shift and go to state 33
    !               shift and go to state 37
    (               shift and go to state 23
    CHAR            shift and go to state 43
    NUMBERF         shift and go to state 44
    NUMBER          shift and go to state 45
    &               shift and go to state 46

    LINE                           shift and go to state 25
    DECLAR                         shift and go to state 28
    INSTR                          shift and go to state 29
    FCALL                          shift and go to state 30
    OROP                           shift and go to state 31
    ASIG                           shift and go to state 32
    ANDOP                          shift and go to state 34
    NOTOP                          shift and go to state 35
    COMPOP                         shift and go to state 36
    ADDOP                          shift and go to state 38
    PRODOP                         shift and go to state 39
    PAROP                          shift and go to state 40
    VAL                            shift and go to state 41
    REFERENCE                      shift and go to state 42

state 49

    (32) DECLAR -> TYPE POINTERS . IDPRIMA
    (35) IDPRIMA -> . empty ELEM REST
    (42) empty -> .
    ID              reduce using rule 42 (empty -> .)

    IDPRIMA                        shift and go to state 69
    empty                          shift and go to state 70

state 50

    (34) POINTERS -> * . POINTERS
    (33) POINTERS -> .
    (34) POINTERS -> . * POINTERS
    ID              reduce using rule 33 (POINTERS -> .)
    *               shift and go to state 50

    POINTERS                       shift and go to state 71

state 51

    (60) PAROP -> ( OROP . )
    (46) OROP -> OROP . ORSIMB ANDOP
    )               shift and go to state 72
    ORSIMB          shift and go to state 56


state 52

    (62) VAL -> ID .
    /               reduce using rule 62 (VAL -> ID .)
    *               reduce using rule 62 (VAL -> ID .)
    -               reduce using rule 62 (VAL -> ID .)
    +               reduce using rule 62 (VAL -> ID .)
    COMPSIMB        reduce using rule 62 (VAL -> ID .)
    ANDSIMB         reduce using rule 62 (VAL -> ID .)
    )               reduce using rule 62 (VAL -> ID .)
    ORSIMB          reduce using rule 62 (VAL -> ID .)
    ;               reduce using rule 62 (VAL -> ID .)
    ,               reduce using rule 62 (VAL -> ID .)


state 53

    (14) LINES -> LINES LINE ; .
    }               reduce using rule 14 (LINES -> LINES LINE ; .)
    PRINT           reduce using rule 14 (LINES -> LINES LINE ; .)
    SCANF           reduce using rule 14 (LINES -> LINES LINE ; .)
    TYPE            reduce using rule 14 (LINES -> LINES LINE ; .)
    ID              reduce using rule 14 (LINES -> LINES LINE ; .)
    !               reduce using rule 14 (LINES -> LINES LINE ; .)
    (               reduce using rule 14 (LINES -> LINES LINE ; .)
    CHAR            reduce using rule 14 (LINES -> LINES LINE ; .)
    NUMBERF         reduce using rule 14 (LINES -> LINES LINE ; .)
    NUMBER          reduce using rule 14 (LINES -> LINES LINE ; .)
    &               reduce using rule 14 (LINES -> LINES LINE ; .)


state 54

    (15) LINE -> PRINT ( . STRING PRINTIDS )
    STRING          shift and go to state 73


state 55

    (16) LINE -> SCANF ( . STRING SCANIDS )
    STRING          shift and go to state 74


state 56

    (46) OROP -> OROP ORSIMB . ANDOP
    (47) ANDOP -> . NOTOP
    (48) ANDOP -> . ANDOP ANDSIMB NOTOP
    (49) NOTOP -> . COMPOP
    (50) NOTOP -> . ! NOTOP
    (51) COMPOP -> . ADDOP
    (52) COMPOP -> . COMPOP COMPSIMB ADDOP
    (53) ADDOP -> . PRODOP
    (54) ADDOP -> . ADDOP - PRODOP
    (55) ADDOP -> . ADDOP + PRODOP
    (56) PRODOP -> . PAROP
    (57) PRODOP -> . PRODOP / PAROP
    (58) PRODOP -> . PRODOP * PAROP
    (59) PAROP -> . VAL
    (60) PAROP -> . ( OROP )
    (61) VAL -> . REFERENCE
    (62) VAL -> . ID
    (63) VAL -> . CHAR
    (64) VAL -> . NUMBERF
    (65) VAL -> . NUMBER
    (66) REFERENCE -> . & ID
    !               shift and go to state 37
    (               shift and go to state 23
    ID              shift and go to state 52
    CHAR            shift and go to state 43
    NUMBERF         shift and go to state 44
    NUMBER          shift and go to state 45
    &               shift and go to state 46

    ANDOP                          shift and go to state 75
    NOTOP                          shift and go to state 35
    COMPOP                         shift and go to state 36
    ADDOP                          shift and go to state 38
    PRODOP                         shift and go to state 39
    PAROP                          shift and go to state 40
    VAL                            shift and go to state 41
    REFERENCE                      shift and go to state 42

state 57

    (26) FCALL -> ID ( . FARGS )
    (27) FARGS -> .
    (28) FARGS -> . FARG RFARGS
    (31) FARG -> . VAL
    (61) VAL -> . REFERENCE
    (62) VAL -> . ID
    (63) VAL -> . CHAR
    (64) VAL -> . NUMBERF
    (65) VAL -> . NUMBER
    (66) REFERENCE -> . & ID
    )               reduce using rule 27 (FARGS -> .)
    ID              shift and go to state 52
    CHAR            shift and go to state 43
    NUMBERF         shift and go to state 44
    NUMBER          shift and go to state 45
    &               shift and go to state 46

    FARGS                          shift and go to state 76
    FARG                           shift and go to state 77
    VAL                            shift and go to state 78
    REFERENCE                      shift and go to state 42

state 58

    (44) ASIG -> ID = . INSTR
    (23) INSTR -> . FCALL
    (24) INSTR -> . OROP
    (25) INSTR -> . ASIG
    (26) FCALL -> . ID ( FARGS )
    (45) OROP -> . ANDOP
    (46) OROP -> . OROP ORSIMB ANDOP
    (44) ASIG -> . ID = INSTR
    (47) ANDOP -> . NOTOP
    (48) ANDOP -> . ANDOP ANDSIMB NOTOP
    (49) NOTOP -> . COMPOP
    (50) NOTOP -> . ! NOTOP
    (51) COMPOP -> . ADDOP
    (52) COMPOP -> . COMPOP COMPSIMB ADDOP
    (53) ADDOP -> . PRODOP
    (54) ADDOP -> . ADDOP - PRODOP
    (55) ADDOP -> . ADDOP + PRODOP
    (56) PRODOP -> . PAROP
    (57) PRODOP -> . PRODOP / PAROP
    (58) PRODOP -> . PRODOP * PAROP
    (59) PAROP -> . VAL
    (60) PAROP -> . ( OROP )
    (61) VAL -> . REFERENCE
    (62) VAL -> . ID
    (63) VAL -> . CHAR
    (64) VAL -> . NUMBERF
    (65) VAL -> . NUMBER
    (66) REFERENCE -> . & ID
    ID              shift and go to state 33
    !               shift and go to state 37
    (               shift and go to state 23
    CHAR            shift and go to state 43
    NUMBERF         shift and go to state 44
    NUMBER          shift and go to state 45
    &               shift and go to state 46

    INSTR                          shift and go to state 79
    FCALL                          shift and go to state 30
    OROP                           shift and go to state 31
    ASIG                           shift and go to state 32
    ANDOP                          shift and go to state 34
    NOTOP                          shift and go to state 35
    COMPOP                         shift and go to state 36
    ADDOP                          shift and go to state 38
    PRODOP                         shift and go to state 39
    PAROP                          shift and go to state 40
    VAL                            shift and go to state 41
    REFERENCE                      shift and go to state 42

state 59

    (48) ANDOP -> ANDOP ANDSIMB . NOTOP
    (49) NOTOP -> . COMPOP
    (50) NOTOP -> . ! NOTOP
    (51) COMPOP -> . ADDOP
    (52) COMPOP -> . COMPOP COMPSIMB ADDOP
    (53) ADDOP -> . PRODOP
    (54) ADDOP -> . ADDOP - PRODOP
    (55) ADDOP -> . ADDOP + PRODOP
    (56) PRODOP -> . PAROP
    (57) PRODOP -> . PRODOP / PAROP
    (58) PRODOP -> . PRODOP * PAROP
    (59) PAROP -> . VAL
    (60) PAROP -> . ( OROP )
    (61) VAL -> . REFERENCE
    (62) VAL -> . ID
    (63) VAL -> . CHAR
    (64) VAL -> . NUMBERF
    (65) VAL -> . NUMBER
    (66) REFERENCE -> . & ID
    !               shift and go to state 37
    (               shift and go to state 23
    ID              shift and go to state 52
    CHAR            shift and go to state 43
    NUMBERF         shift and go to state 44
    NUMBER          shift and go to state 45
    &               shift and go to state 46

    NOTOP                          shift and go to state 80
    COMPOP                         shift and go to state 36
    ADDOP                          shift and go to state 38
    PRODOP                         shift and go to state 39
    PAROP                          shift and go to state 40
    VAL                            shift and go to state 41
    REFERENCE                      shift and go to state 42

state 60

    (52) COMPOP -> COMPOP COMPSIMB . ADDOP
    (53) ADDOP -> . PRODOP
    (54) ADDOP -> . ADDOP - PRODOP
    (55) ADDOP -> . ADDOP + PRODOP
    (56) PRODOP -> . PAROP
    (57) PRODOP -> . PRODOP / PAROP
    (58) PRODOP -> . PRODOP * PAROP
    (59) PAROP -> . VAL
    (60) PAROP -> . ( OROP )
    (61) VAL -> . REFERENCE
    (62) VAL -> . ID
    (63) VAL -> . CHAR
    (64) VAL -> . NUMBERF
    (65) VAL -> . NUMBER
    (66) REFERENCE -> . & ID
    (               shift and go to state 23
    ID              shift and go to state 52
    CHAR            shift and go to state 43
    NUMBERF         shift and go to state 44
    NUMBER          shift and go to state 45
    &               shift and go to state 46

    ADDOP                          shift and go to state 81
    PRODOP                         shift and go to state 39
    PAROP                          shift and go to state 40
    VAL                            shift and go to state 41
    REFERENCE                      shift and go to state 42

state 61

    (50) NOTOP -> ! NOTOP .
    ANDSIMB         reduce using rule 50 (NOTOP -> ! NOTOP .)
    ORSIMB          reduce using rule 50 (NOTOP -> ! NOTOP .)
    ;               reduce using rule 50 (NOTOP -> ! NOTOP .)
    )               reduce using rule 50 (NOTOP -> ! NOTOP .)
    ,               reduce using rule 50 (NOTOP -> ! NOTOP .)


state 62

    (54) ADDOP -> ADDOP - . PRODOP
    (56) PRODOP -> . PAROP
    (57) PRODOP -> . PRODOP / PAROP
    (58) PRODOP -> . PRODOP * PAROP
    (59) PAROP -> . VAL
    (60) PAROP -> . ( OROP )
    (61) VAL -> . REFERENCE
    (62) VAL -> . ID
    (63) VAL -> . CHAR
    (64) VAL -> . NUMBERF
    (65) VAL -> . NUMBER
    (66) REFERENCE -> . & ID
    (               shift and go to state 23
    ID              shift and go to state 52
    CHAR            shift and go to state 43
    NUMBERF         shift and go to state 44
    NUMBER          shift and go to state 45
    &               shift and go to state 46

    PRODOP                         shift and go to state 82
    PAROP                          shift and go to state 40
    VAL                            shift and go to state 41
    REFERENCE                      shift and go to state 42

state 63

    (55) ADDOP -> ADDOP + . PRODOP
    (56) PRODOP -> . PAROP
    (57) PRODOP -> . PRODOP / PAROP
    (58) PRODOP -> . PRODOP * PAROP
    (59) PAROP -> . VAL
    (60) PAROP -> . ( OROP )
    (61) VAL -> . REFERENCE
    (62) VAL -> . ID
    (63) VAL -> . CHAR
    (64) VAL -> . NUMBERF
    (65) VAL -> . NUMBER
    (66) REFERENCE -> . & ID
    (               shift and go to state 23
    ID              shift and go to state 52
    CHAR            shift and go to state 43
    NUMBERF         shift and go to state 44
    NUMBER          shift and go to state 45
    &               shift and go to state 46

    PRODOP                         shift and go to state 83
    PAROP                          shift and go to state 40
    VAL                            shift and go to state 41
    REFERENCE                      shift and go to state 42

state 64

    (57) PRODOP -> PRODOP / . PAROP
    (59) PAROP -> . VAL
    (60) PAROP -> . ( OROP )
    (61) VAL -> . REFERENCE
    (62) VAL -> . ID
    (63) VAL -> . CHAR
    (64) VAL -> . NUMBERF
    (65) VAL -> . NUMBER
    (66) REFERENCE -> . & ID
    (               shift and go to state 23
    ID              shift and go to state 52
    CHAR            shift and go to state 43
    NUMBERF         shift and go to state 44
    NUMBER          shift and go to state 45
    &               shift and go to state 46

    PAROP                          shift and go to state 84
    VAL                            shift and go to state 41
    REFERENCE                      shift and go to state 42

state 65

    (58) PRODOP -> PRODOP * . PAROP
    (59) PAROP -> . VAL
    (60) PAROP -> . ( OROP )
    (61) VAL -> . REFERENCE
    (62) VAL -> . ID
    (63) VAL -> . CHAR
    (64) VAL -> . NUMBERF
    (65) VAL -> . NUMBER
    (66) REFERENCE -> . & ID
    (               shift and go to state 23
    ID              shift and go to state 52
    CHAR            shift and go to state 43
    NUMBERF         shift and go to state 44
    NUMBER          shift and go to state 45
    &               shift and go to state 46

    PAROP                          shift and go to state 85
    VAL                            shift and go to state 41
    REFERENCE                      shift and go to state 42

state 66

    (66) REFERENCE -> & ID .
    /               reduce using rule 66 (REFERENCE -> & ID .)
    *               reduce using rule 66 (REFERENCE -> & ID .)
    -               reduce using rule 66 (REFERENCE -> & ID .)
    +               reduce using rule 66 (REFERENCE -> & ID .)
    COMPSIMB        reduce using rule 66 (REFERENCE -> & ID .)
    ANDSIMB         reduce using rule 66 (REFERENCE -> & ID .)
    ORSIMB          reduce using rule 66 (REFERENCE -> & ID .)
    ;               reduce using rule 66 (REFERENCE -> & ID .)
    )               reduce using rule 66 (REFERENCE -> & ID .)
    ,               reduce using rule 66 (REFERENCE -> & ID .)


state 67

    (9) RARGS -> , TYPE ARG . RARGS
    (8) RARGS -> .
    (9) RARGS -> . , TYPE ARG RARGS
    )               reduce using rule 8 (RARGS -> .)
    ,               shift and go to state 20

    RARGS                          shift and go to state 86

state 68

    (5) FUNCTION -> TYPE ID emptyF1 ( ARGS ) { LINES } . emptyF2
    (11) emptyF2 -> .
    TYPE            reduce using rule 11 (emptyF2 -> .)

    emptyF2                        shift and go to state 87

state 69

    (32) DECLAR -> TYPE POINTERS IDPRIMA .
    ;               reduce using rule 32 (DECLAR -> TYPE POINTERS IDPRIMA .)


state 70

    (35) IDPRIMA -> empty . ELEM REST
    (38) ELEM -> . ID = INSTR
    (39) ELEM -> . ID ARRAY
    ID              shift and go to state 89

    ELEM                           shift and go to state 88

state 71

    (34) POINTERS -> * POINTERS .
    ID              reduce using rule 34 (POINTERS -> * POINTERS .)


state 72

    (60) PAROP -> ( OROP ) .
    /               reduce using rule 60 (PAROP -> ( OROP ) .)
    *               reduce using rule 60 (PAROP -> ( OROP ) .)
    -               reduce using rule 60 (PAROP -> ( OROP ) .)
    +               reduce using rule 60 (PAROP -> ( OROP ) .)
    COMPSIMB        reduce using rule 60 (PAROP -> ( OROP ) .)
    ANDSIMB         reduce using rule 60 (PAROP -> ( OROP ) .)
    ORSIMB          reduce using rule 60 (PAROP -> ( OROP ) .)
    ;               reduce using rule 60 (PAROP -> ( OROP ) .)
    )               reduce using rule 60 (PAROP -> ( OROP ) .)
    ,               reduce using rule 60 (PAROP -> ( OROP ) .)


state 73

    (15) LINE -> PRINT ( STRING . PRINTIDS )
    (21) PRINTIDS -> .
    (22) PRINTIDS -> . , INSTR PRINTIDS
    )               reduce using rule 21 (PRINTIDS -> .)
    ,               shift and go to state 91

    PRINTIDS                       shift and go to state 90

state 74

    (16) LINE -> SCANF ( STRING . SCANIDS )
    (19) SCANIDS -> .
    (20) SCANIDS -> . , REFERENCE SCANIDS
    )               reduce using rule 19 (SCANIDS -> .)
    ,               shift and go to state 93

    SCANIDS                        shift and go to state 92

state 75

    (46) OROP -> OROP ORSIMB ANDOP .
    (48) ANDOP -> ANDOP . ANDSIMB NOTOP
    ORSIMB          reduce using rule 46 (OROP -> OROP ORSIMB ANDOP .)
    ;               reduce using rule 46 (OROP -> OROP ORSIMB ANDOP .)
    )               reduce using rule 46 (OROP -> OROP ORSIMB ANDOP .)
    ,               reduce using rule 46 (OROP -> OROP ORSIMB ANDOP .)
    ANDSIMB         shift and go to state 59


state 76

    (26) FCALL -> ID ( FARGS . )
    )               shift and go to state 94


state 77

    (28) FARGS -> FARG . RFARGS
    (29) RFARGS -> .
    (30) RFARGS -> . , FARG RFARGS
    )               reduce using rule 29 (RFARGS -> .)
    ,               shift and go to state 96

    RFARGS                         shift and go to state 95

state 78

    (31) FARG -> VAL .
    ,               reduce using rule 31 (FARG -> VAL .)
    )               reduce using rule 31 (FARG -> VAL .)


state 79

    (44) ASIG -> ID = INSTR .
    ;               reduce using rule 44 (ASIG -> ID = INSTR .)
    ,               reduce using rule 44 (ASIG -> ID = INSTR .)
    )               reduce using rule 44 (ASIG -> ID = INSTR .)


state 80

    (48) ANDOP -> ANDOP ANDSIMB NOTOP .
    ANDSIMB         reduce using rule 48 (ANDOP -> ANDOP ANDSIMB NOTOP .)
    ORSIMB          reduce using rule 48 (ANDOP -> ANDOP ANDSIMB NOTOP .)
    ;               reduce using rule 48 (ANDOP -> ANDOP ANDSIMB NOTOP .)
    )               reduce using rule 48 (ANDOP -> ANDOP ANDSIMB NOTOP .)
    ,               reduce using rule 48 (ANDOP -> ANDOP ANDSIMB NOTOP .)


state 81

    (52) COMPOP -> COMPOP COMPSIMB ADDOP .
    (54) ADDOP -> ADDOP . - PRODOP
    (55) ADDOP -> ADDOP . + PRODOP
    COMPSIMB        reduce using rule 52 (COMPOP -> COMPOP COMPSIMB ADDOP .)
    ANDSIMB         reduce using rule 52 (COMPOP -> COMPOP COMPSIMB ADDOP .)
    ORSIMB          reduce using rule 52 (COMPOP -> COMPOP COMPSIMB ADDOP .)
    ;               reduce using rule 52 (COMPOP -> COMPOP COMPSIMB ADDOP .)
    )               reduce using rule 52 (COMPOP -> COMPOP COMPSIMB ADDOP .)
    ,               reduce using rule 52 (COMPOP -> COMPOP COMPSIMB ADDOP .)
    -               shift and go to state 62
    +               shift and go to state 63


state 82

    (54) ADDOP -> ADDOP - PRODOP .
    (57) PRODOP -> PRODOP . / PAROP
    (58) PRODOP -> PRODOP . * PAROP
    -               reduce using rule 54 (ADDOP -> ADDOP - PRODOP .)
    +               reduce using rule 54 (ADDOP -> ADDOP - PRODOP .)
    COMPSIMB        reduce using rule 54 (ADDOP -> ADDOP - PRODOP .)
    ANDSIMB         reduce using rule 54 (ADDOP -> ADDOP - PRODOP .)
    ORSIMB          reduce using rule 54 (ADDOP -> ADDOP - PRODOP .)
    ;               reduce using rule 54 (ADDOP -> ADDOP - PRODOP .)
    )               reduce using rule 54 (ADDOP -> ADDOP - PRODOP .)
    ,               reduce using rule 54 (ADDOP -> ADDOP - PRODOP .)
    /               shift and go to state 64
    *               shift and go to state 65


state 83

    (55) ADDOP -> ADDOP + PRODOP .
    (57) PRODOP -> PRODOP . / PAROP
    (58) PRODOP -> PRODOP . * PAROP
    -               reduce using rule 55 (ADDOP -> ADDOP + PRODOP .)
    +               reduce using rule 55 (ADDOP -> ADDOP + PRODOP .)
    COMPSIMB        reduce using rule 55 (ADDOP -> ADDOP + PRODOP .)
    ANDSIMB         reduce using rule 55 (ADDOP -> ADDOP + PRODOP .)
    ORSIMB          reduce using rule 55 (ADDOP -> ADDOP + PRODOP .)
    ;               reduce using rule 55 (ADDOP -> ADDOP + PRODOP .)
    )               reduce using rule 55 (ADDOP -> ADDOP + PRODOP .)
    ,               reduce using rule 55 (ADDOP -> ADDOP + PRODOP .)
    /               shift and go to state 64
    *               shift and go to state 65


state 84

    (57) PRODOP -> PRODOP / PAROP .
    /               reduce using rule 57 (PRODOP -> PRODOP / PAROP .)
    *               reduce using rule 57 (PRODOP -> PRODOP / PAROP .)
    -               reduce using rule 57 (PRODOP -> PRODOP / PAROP .)
    +               reduce using rule 57 (PRODOP -> PRODOP / PAROP .)
    COMPSIMB        reduce using rule 57 (PRODOP -> PRODOP / PAROP .)
    ANDSIMB         reduce using rule 57 (PRODOP -> PRODOP / PAROP .)
    ORSIMB          reduce using rule 57 (PRODOP -> PRODOP / PAROP .)
    ;               reduce using rule 57 (PRODOP -> PRODOP / PAROP .)
    )               reduce using rule 57 (PRODOP -> PRODOP / PAROP .)
    ,               reduce using rule 57 (PRODOP -> PRODOP / PAROP .)


state 85

    (58) PRODOP -> PRODOP * PAROP .
    /               reduce using rule 58 (PRODOP -> PRODOP * PAROP .)
    *               reduce using rule 58 (PRODOP -> PRODOP * PAROP .)
    -               reduce using rule 58 (PRODOP -> PRODOP * PAROP .)
    +               reduce using rule 58 (PRODOP -> PRODOP * PAROP .)
    COMPSIMB        reduce using rule 58 (PRODOP -> PRODOP * PAROP .)
    ANDSIMB         reduce using rule 58 (PRODOP -> PRODOP * PAROP .)
    ORSIMB          reduce using rule 58 (PRODOP -> PRODOP * PAROP .)
    ;               reduce using rule 58 (PRODOP -> PRODOP * PAROP .)
    )               reduce using rule 58 (PRODOP -> PRODOP * PAROP .)
    ,               reduce using rule 58 (PRODOP -> PRODOP * PAROP .)


state 86

    (9) RARGS -> , TYPE ARG RARGS .
    )               reduce using rule 9 (RARGS -> , TYPE ARG RARGS .)


state 87

    (5) FUNCTION -> TYPE ID emptyF1 ( ARGS ) { LINES } emptyF2 .
    TYPE            reduce using rule 5 (FUNCTION -> TYPE ID emptyF1 ( ARGS ) { LINES } emptyF2 .)


state 88

    (35) IDPRIMA -> empty ELEM . REST
    (36) REST -> .
    (37) REST -> . , empty2 ELEM REST
    ;               reduce using rule 36 (REST -> .)
    ,               shift and go to state 98

    REST                           shift and go to state 97

state 89

    (38) ELEM -> ID . = INSTR
    (39) ELEM -> ID . ARRAY
    (40) ARRAY -> .
    (41) ARRAY -> . [ NUMBER ] ARRAY
    =               shift and go to state 99
    ,               reduce using rule 40 (ARRAY -> .)
    ;               reduce using rule 40 (ARRAY -> .)
    [               shift and go to state 101

    ARRAY                          shift and go to state 100

state 90

    (15) LINE -> PRINT ( STRING PRINTIDS . )
    )               shift and go to state 102


state 91

    (22) PRINTIDS -> , . INSTR PRINTIDS
    (23) INSTR -> . FCALL
    (24) INSTR -> . OROP
    (25) INSTR -> . ASIG
    (26) FCALL -> . ID ( FARGS )
    (45) OROP -> . ANDOP
    (46) OROP -> . OROP ORSIMB ANDOP
    (44) ASIG -> . ID = INSTR
    (47) ANDOP -> . NOTOP
    (48) ANDOP -> . ANDOP ANDSIMB NOTOP
    (49) NOTOP -> . COMPOP
    (50) NOTOP -> . ! NOTOP
    (51) COMPOP -> . ADDOP
    (52) COMPOP -> . COMPOP COMPSIMB ADDOP
    (53) ADDOP -> . PRODOP
    (54) ADDOP -> . ADDOP - PRODOP
    (55) ADDOP -> . ADDOP + PRODOP
    (56) PRODOP -> . PAROP
    (57) PRODOP -> . PRODOP / PAROP
    (58) PRODOP -> . PRODOP * PAROP
    (59) PAROP -> . VAL
    (60) PAROP -> . ( OROP )
    (61) VAL -> . REFERENCE
    (62) VAL -> . ID
    (63) VAL -> . CHAR
    (64) VAL -> . NUMBERF
    (65) VAL -> . NUMBER
    (66) REFERENCE -> . & ID
    ID              shift and go to state 33
    !               shift and go to state 37
    (               shift and go to state 23
    CHAR            shift and go to state 43
    NUMBERF         shift and go to state 44
    NUMBER          shift and go to state 45
    &               shift and go to state 46

    INSTR                          shift and go to state 103
    FCALL                          shift and go to state 30
    OROP                           shift and go to state 31
    ASIG                           shift and go to state 32
    ANDOP                          shift and go to state 34
    NOTOP                          shift and go to state 35
    COMPOP                         shift and go to state 36
    ADDOP                          shift and go to state 38
    PRODOP                         shift and go to state 39
    PAROP                          shift and go to state 40
    VAL                            shift and go to state 41
    REFERENCE                      shift and go to state 42

state 92

    (16) LINE -> SCANF ( STRING SCANIDS . )
    )               shift and go to state 104


state 93

    (20) SCANIDS -> , . REFERENCE SCANIDS
    (66) REFERENCE -> . & ID
    &               shift and go to state 46

    REFERENCE                      shift and go to state 105

state 94

    (26) FCALL -> ID ( FARGS ) .
    ;               reduce using rule 26 (FCALL -> ID ( FARGS ) .)
    ,               reduce using rule 26 (FCALL -> ID ( FARGS ) .)
    )               reduce using rule 26 (FCALL -> ID ( FARGS ) .)


state 95

    (28) FARGS -> FARG RFARGS .
    )               reduce using rule 28 (FARGS -> FARG RFARGS .)


state 96

    (30) RFARGS -> , . FARG RFARGS
    (31) FARG -> . VAL
    (61) VAL -> . REFERENCE
    (62) VAL -> . ID
    (63) VAL -> . CHAR
    (64) VAL -> . NUMBERF
    (65) VAL -> . NUMBER
    (66) REFERENCE -> . & ID
    ID              shift and go to state 52
    CHAR            shift and go to state 43
    NUMBERF         shift and go to state 44
    NUMBER          shift and go to state 45
    &               shift and go to state 46

    FARG                           shift and go to state 106
    VAL                            shift and go to state 78
    REFERENCE                      shift and go to state 42

state 97

    (35) IDPRIMA -> empty ELEM REST .
    ;               reduce using rule 35 (IDPRIMA -> empty ELEM REST .)


state 98

    (37) REST -> , . empty2 ELEM REST
    (43) empty2 -> .
    ID              reduce using rule 43 (empty2 -> .)

    empty2                         shift and go to state 107

state 99

    (38) ELEM -> ID = . INSTR
    (23) INSTR -> . FCALL
    (24) INSTR -> . OROP
    (25) INSTR -> . ASIG
    (26) FCALL -> . ID ( FARGS )
    (45) OROP -> . ANDOP
    (46) OROP -> . OROP ORSIMB ANDOP
    (44) ASIG -> . ID = INSTR
    (47) ANDOP -> . NOTOP
    (48) ANDOP -> . ANDOP ANDSIMB NOTOP
    (49) NOTOP -> . COMPOP
    (50) NOTOP -> . ! NOTOP
    (51) COMPOP -> . ADDOP
    (52) COMPOP -> . COMPOP COMPSIMB ADDOP
    (53) ADDOP -> . PRODOP
    (54) ADDOP -> . ADDOP - PRODOP
    (55) ADDOP -> . ADDOP + PRODOP
    (56) PRODOP -> . PAROP
    (57) PRODOP -> . PRODOP / PAROP
    (58) PRODOP -> . PRODOP * PAROP
    (59) PAROP -> . VAL
    (60) PAROP -> . ( OROP )
    (61) VAL -> . REFERENCE
    (62) VAL -> . ID
    (63) VAL -> . CHAR
    (64) VAL -> . NUMBERF
    (65) VAL -> . NUMBER
    (66) REFERENCE -> . & ID
    ID              shift and go to state 33
    !               shift and go to state 37
    (               shift and go to state 23
    CHAR            shift and go to state 43
    NUMBERF         shift and go to state 44
    NUMBER          shift and go to state 45
    &               shift and go to state 46

    INSTR                          shift and go to state 108
    FCALL                          shift and go to state 30
    OROP                           shift and go to state 31
    ASIG                           shift and go to state 32
    ANDOP                          shift and go to state 34
    NOTOP                          shift and go to state 35
    COMPOP                         shift and go to state 36
    ADDOP                          shift and go to state 38
    PRODOP                         shift and go to state 39
    PAROP                          shift and go to state 40
    VAL                            shift and go to state 41
    REFERENCE                      shift and go to state 42

state 100

    (39) ELEM -> ID ARRAY .
    ,               reduce using rule 39 (ELEM -> ID ARRAY .)
    ;               reduce using rule 39 (ELEM -> ID ARRAY .)


state 101

    (41) ARRAY -> [ . NUMBER ] ARRAY
    NUMBER          shift and go to state 109


state 102

    (15) LINE -> PRINT ( STRING PRINTIDS ) .
    ;               reduce using rule 15 (LINE -> PRINT ( STRING PRINTIDS ) .)


state 103

    (22) PRINTIDS -> , INSTR . PRINTIDS
    (21) PRINTIDS -> .
    (22) PRINTIDS -> . , INSTR PRINTIDS
    )               reduce using rule 21 (PRINTIDS -> .)
    ,               shift and go to state 91

    PRINTIDS                       shift and go to state 110

state 104

    (16) LINE -> SCANF ( STRING SCANIDS ) .
    ;               reduce using rule 16 (LINE -> SCANF ( STRING SCANIDS ) .)


state 105

    (20) SCANIDS -> , REFERENCE . SCANIDS
    (19) SCANIDS -> .
    (20) SCANIDS -> . , REFERENCE SCANIDS
    )               reduce using rule 19 (SCANIDS -> .)
    ,               shift and go to state 93

    SCANIDS                        shift and go to state 111

state 106

    (30) RFARGS -> , FARG . RFARGS
    (29) RFARGS -> .
    (30) RFARGS -> . , FARG RFARGS
    )               reduce using rule 29 (RFARGS -> .)
    ,               shift and go to state 96

    RFARGS                         shift and go to state 112

state 107

    (37) REST -> , empty2 . ELEM REST
    (38) ELEM -> . ID = INSTR
    (39) ELEM -> . ID ARRAY
    ID              shift and go to state 89

    ELEM                           shift and go to state 113

state 108

    (38) ELEM -> ID = INSTR .
    ,               reduce using rule 38 (ELEM -> ID = INSTR .)
    ;               reduce using rule 38 (ELEM -> ID = INSTR .)


state 109

    (41) ARRAY -> [ NUMBER . ] ARRAY
    ]               shift and go to state 114


state 110

    (22) PRINTIDS -> , INSTR PRINTIDS .
    )               reduce using rule 22 (PRINTIDS -> , INSTR PRINTIDS .)


state 111

    (20) SCANIDS -> , REFERENCE SCANIDS .
    )               reduce using rule 20 (SCANIDS -> , REFERENCE SCANIDS .)


state 112

    (30) RFARGS -> , FARG RFARGS .
    )               reduce using rule 30 (RFARGS -> , FARG RFARGS .)


state 113

    (37) REST -> , empty2 ELEM . REST
    (36) REST -> .
    (37) REST -> . , empty2 ELEM REST
    ;               reduce using rule 36 (REST -> .)
    ,               shift and go to state 98

    REST                           shift and go to state 115

state 114

    (41) ARRAY -> [ NUMBER ] . ARRAY
    (40) ARRAY -> .
    (41) ARRAY -> . [ NUMBER ] ARRAY
    ,               reduce using rule 40 (ARRAY -> .)
    ;               reduce using rule 40 (ARRAY -> .)
    [               shift and go to state 101

    ARRAY                          shift and go to state 116

state 115

    (37) REST -> , empty2 ELEM REST .
    ;               reduce using rule 37 (REST -> , empty2 ELEM REST .)


state 116

    (41) ARRAY -> [ NUMBER ] ARRAY .
    ,               reduce using rule 41 (ARRAY -> [ NUMBER ] ARRAY .)
    ;               reduce using rule 41 (ARRAY -> [ NUMBER ] ARRAY .)
