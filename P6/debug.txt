Grammar:

Rule 0     S' -> S
Rule 1     S -> S2 TYPE emptymain MAIN ( ) { LINES }
Rule 2     emptymain -> <empty>
Rule 3     S2 -> <empty>
Rule 4     S2 -> S2 FUNCTION
Rule 5     FUNCTION -> TYPE ID emptyF1 ( ARGS ) { LINES } emptyF2
Rule 6     ARGS -> <empty>
Rule 7     ARGS -> TYPE ARG RARGS
Rule 8     RARGS -> <empty>
Rule 9     RARGS -> , TYPE ARG RARGS
Rule 10    emptyF1 -> <empty>
Rule 11    emptyF2 -> <empty>
Rule 12    ARG -> ID
Rule 13    LINES -> <empty>
Rule 14    LINES -> LINES LINE ;
Rule 15    LINE -> PRINT ( STRING PRINTIDS )
Rule 16    LINE -> SCANF ( STRING SCANIDS )
Rule 17    LINE -> DECLAR
Rule 18    LINE -> INSTR
Rule 19    SCANIDS -> <empty>
Rule 20    SCANIDS -> , & ID SCANIDS
Rule 21    PRINTIDS -> <empty>
Rule 22    PRINTIDS -> , INSTR PRINTIDS
Rule 23    INSTR -> OROP
Rule 24    INSTR -> ASIG
Rule 25    DECLAR -> TYPE POINTERS IDPRIMA
Rule 26    POINTERS -> <empty>
Rule 27    POINTERS -> * POINTERS
Rule 28    IDPRIMA -> empty ELEM REST
Rule 29    REST -> <empty>
Rule 30    REST -> , empty2 ELEM REST
Rule 31    ELEM -> ID = INSTR
Rule 32    ELEM -> ID ARRAY
Rule 33    ARRAY -> <empty>
Rule 34    ARRAY -> [ NUMBER ] ARRAY
Rule 35    empty -> <empty>
Rule 36    empty2 -> <empty>
Rule 37    ASIG -> ID = INSTR
Rule 38    OROP -> ANDOP
Rule 39    OROP -> OROP ORSIMB ANDOP
Rule 40    ANDOP -> NOTOP
Rule 41    ANDOP -> ANDOP ANDSIMB NOTOP
Rule 42    NOTOP -> COMPOP
Rule 43    NOTOP -> ! NOTOP
Rule 44    COMPOP -> ADDOP
Rule 45    COMPOP -> COMPOP COMPSIMB ADDOP
Rule 46    ADDOP -> PRODOP
Rule 47    ADDOP -> ADDOP - PRODOP
Rule 48    ADDOP -> ADDOP + PRODOP
Rule 49    PRODOP -> PAROP
Rule 50    PRODOP -> PRODOP / PAROP
Rule 51    PRODOP -> PRODOP * PAROP
Rule 52    PAROP -> VAL
Rule 53    PAROP -> ( OROP )
Rule 54    VAL -> & ID
Rule 55    VAL -> ID
Rule 56    VAL -> CHAR
Rule 57    VAL -> NUMBERF
Rule 58    VAL -> NUMBER

Terminals, with rules where they appear:

!                    : 43
&                    : 20 54
(                    : 1 5 15 16 53
)                    : 1 5 15 16 53
*                    : 27 51
+                    : 48
,                    : 9 20 22 30
-                    : 47
/                    : 50
;                    : 14
=                    : 31 37
ANDSIMB              : 41
CHAR                 : 56
COMPSIMB             : 45
ID                   : 5 12 20 31 32 37 54 55
MAIN                 : 1
NUMBER               : 34 58
NUMBERF              : 57
ORSIMB               : 39
PRINT                : 15
SCANF                : 16
STRING               : 15 16
TYPE                 : 1 5 7 9 25
[                    : 34
]                    : 34
error                : 
{                    : 1 5
}                    : 1 5

Nonterminals, with rules where they appear:

ADDOP                : 44 45 47 48
ANDOP                : 38 39 41
ARG                  : 7 9
ARGS                 : 5
ARRAY                : 32 34
ASIG                 : 24
COMPOP               : 42 45
DECLAR               : 17
ELEM                 : 28 30
FUNCTION             : 4
IDPRIMA              : 25
INSTR                : 18 22 31 37
LINE                 : 14
LINES                : 1 5 14
NOTOP                : 40 41 43
OROP                 : 23 39 53
PAROP                : 49 50 51
POINTERS             : 25 27
PRINTIDS             : 15 22
PRODOP               : 46 47 48 50 51
RARGS                : 7 9
REST                 : 28 30
S                    : 0
S2                   : 1 4
SCANIDS              : 16 20
VAL                  : 52
empty                : 28
empty2               : 30
emptyF1              : 5
emptyF2              : 5
emptymain            : 1


state 0

    (0) S' -> . S
    (1) S -> . S2 TYPE emptymain MAIN ( ) { LINES }
    (3) S2 -> .
    (4) S2 -> . S2 FUNCTION
    TYPE            reduce using rule 3 (S2 -> .)

    S                              shift and go to state 1
    S2                             shift and go to state 2

state 1

    (0) S' -> S .


state 2

    (1) S -> S2 . TYPE emptymain MAIN ( ) { LINES }
    (4) S2 -> S2 . FUNCTION
    (5) FUNCTION -> . TYPE ID emptyF1 ( ARGS ) { LINES } emptyF2
    TYPE            shift and go to state 3

    FUNCTION                       shift and go to state 4

state 3

    (1) S -> S2 TYPE . emptymain MAIN ( ) { LINES }
    (5) FUNCTION -> TYPE . ID emptyF1 ( ARGS ) { LINES } emptyF2
    (2) emptymain -> .
    ID              shift and go to state 6
    MAIN            reduce using rule 2 (emptymain -> .)

    emptymain                      shift and go to state 5

state 4

    (4) S2 -> S2 FUNCTION .
    TYPE            reduce using rule 4 (S2 -> S2 FUNCTION .)


state 5

    (1) S -> S2 TYPE emptymain . MAIN ( ) { LINES }
    MAIN            shift and go to state 7


state 6

    (5) FUNCTION -> TYPE ID . emptyF1 ( ARGS ) { LINES } emptyF2
    (10) emptyF1 -> .
    (               reduce using rule 10 (emptyF1 -> .)

    emptyF1                        shift and go to state 8

state 7

    (1) S -> S2 TYPE emptymain MAIN . ( ) { LINES }
    (               shift and go to state 9


state 8

    (5) FUNCTION -> TYPE ID emptyF1 . ( ARGS ) { LINES } emptyF2
    (               shift and go to state 10


state 9

    (1) S -> S2 TYPE emptymain MAIN ( . ) { LINES }
    )               shift and go to state 11


state 10

    (5) FUNCTION -> TYPE ID emptyF1 ( . ARGS ) { LINES } emptyF2
    (6) ARGS -> .
    (7) ARGS -> . TYPE ARG RARGS
    )               reduce using rule 6 (ARGS -> .)
    TYPE            shift and go to state 12

    ARGS                           shift and go to state 13

state 11

    (1) S -> S2 TYPE emptymain MAIN ( ) . { LINES }
    {               shift and go to state 14


state 12

    (7) ARGS -> TYPE . ARG RARGS
    (12) ARG -> . ID
    ID              shift and go to state 16

    ARG                            shift and go to state 15

state 13

    (5) FUNCTION -> TYPE ID emptyF1 ( ARGS . ) { LINES } emptyF2
    )               shift and go to state 17


state 14

    (1) S -> S2 TYPE emptymain MAIN ( ) { . LINES }
    (13) LINES -> .
    (14) LINES -> . LINES LINE ;
    }               reduce using rule 13 (LINES -> .)
    PRINT           reduce using rule 13 (LINES -> .)
    SCANF           reduce using rule 13 (LINES -> .)
    TYPE            reduce using rule 13 (LINES -> .)
    ID              reduce using rule 13 (LINES -> .)
    !               reduce using rule 13 (LINES -> .)
    (               reduce using rule 13 (LINES -> .)
    &               reduce using rule 13 (LINES -> .)
    CHAR            reduce using rule 13 (LINES -> .)
    NUMBERF         reduce using rule 13 (LINES -> .)
    NUMBER          reduce using rule 13 (LINES -> .)

    LINES                          shift and go to state 18

state 15

    (7) ARGS -> TYPE ARG . RARGS
    (8) RARGS -> .
    (9) RARGS -> . , TYPE ARG RARGS
    )               reduce using rule 8 (RARGS -> .)
    ,               shift and go to state 20

    RARGS                          shift and go to state 19

state 16

    (12) ARG -> ID .
    ,               reduce using rule 12 (ARG -> ID .)
    )               reduce using rule 12 (ARG -> ID .)


state 17

    (5) FUNCTION -> TYPE ID emptyF1 ( ARGS ) . { LINES } emptyF2
    {               shift and go to state 21


state 18

    (1) S -> S2 TYPE emptymain MAIN ( ) { LINES . }
    (14) LINES -> LINES . LINE ;
    (15) LINE -> . PRINT ( STRING PRINTIDS )
    (16) LINE -> . SCANF ( STRING SCANIDS )
    (17) LINE -> . DECLAR
    (18) LINE -> . INSTR
    (25) DECLAR -> . TYPE POINTERS IDPRIMA
    (23) INSTR -> . OROP
    (24) INSTR -> . ASIG
    (38) OROP -> . ANDOP
    (39) OROP -> . OROP ORSIMB ANDOP
    (37) ASIG -> . ID = INSTR
    (40) ANDOP -> . NOTOP
    (41) ANDOP -> . ANDOP ANDSIMB NOTOP
    (42) NOTOP -> . COMPOP
    (43) NOTOP -> . ! NOTOP
    (44) COMPOP -> . ADDOP
    (45) COMPOP -> . COMPOP COMPSIMB ADDOP
    (46) ADDOP -> . PRODOP
    (47) ADDOP -> . ADDOP - PRODOP
    (48) ADDOP -> . ADDOP + PRODOP
    (49) PRODOP -> . PAROP
    (50) PRODOP -> . PRODOP / PAROP
    (51) PRODOP -> . PRODOP * PAROP
    (52) PAROP -> . VAL
    (53) PAROP -> . ( OROP )
    (54) VAL -> . & ID
    (55) VAL -> . ID
    (56) VAL -> . CHAR
    (57) VAL -> . NUMBERF
    (58) VAL -> . NUMBER
    }               shift and go to state 24
    PRINT           shift and go to state 26
    SCANF           shift and go to state 27
    TYPE            shift and go to state 22
    ID              shift and go to state 33
    !               shift and go to state 36
    (               shift and go to state 23
    &               shift and go to state 41
    CHAR            shift and go to state 42
    NUMBERF         shift and go to state 43
    NUMBER          shift and go to state 44

    LINE                           shift and go to state 25
    DECLAR                         shift and go to state 28
    INSTR                          shift and go to state 29
    OROP                           shift and go to state 30
    ASIG                           shift and go to state 31
    ANDOP                          shift and go to state 32
    NOTOP                          shift and go to state 34
    COMPOP                         shift and go to state 35
    ADDOP                          shift and go to state 37
    PRODOP                         shift and go to state 38
    PAROP                          shift and go to state 39
    VAL                            shift and go to state 40

state 19

    (7) ARGS -> TYPE ARG RARGS .
    )               reduce using rule 7 (ARGS -> TYPE ARG RARGS .)


state 20

    (9) RARGS -> , . TYPE ARG RARGS
    TYPE            shift and go to state 45


state 21

    (5) FUNCTION -> TYPE ID emptyF1 ( ARGS ) { . LINES } emptyF2
    (13) LINES -> .
    (14) LINES -> . LINES LINE ;
    }               reduce using rule 13 (LINES -> .)
    PRINT           reduce using rule 13 (LINES -> .)
    SCANF           reduce using rule 13 (LINES -> .)
    TYPE            reduce using rule 13 (LINES -> .)
    ID              reduce using rule 13 (LINES -> .)
    !               reduce using rule 13 (LINES -> .)
    (               reduce using rule 13 (LINES -> .)
    &               reduce using rule 13 (LINES -> .)
    CHAR            reduce using rule 13 (LINES -> .)
    NUMBERF         reduce using rule 13 (LINES -> .)
    NUMBER          reduce using rule 13 (LINES -> .)

    LINES                          shift and go to state 46

state 22

    (25) DECLAR -> TYPE . POINTERS IDPRIMA
    (26) POINTERS -> .
    (27) POINTERS -> . * POINTERS
    ID              reduce using rule 26 (POINTERS -> .)
    *               shift and go to state 48

    POINTERS                       shift and go to state 47

state 23

    (53) PAROP -> ( . OROP )
    (38) OROP -> . ANDOP
    (39) OROP -> . OROP ORSIMB ANDOP
    (40) ANDOP -> . NOTOP
    (41) ANDOP -> . ANDOP ANDSIMB NOTOP
    (42) NOTOP -> . COMPOP
    (43) NOTOP -> . ! NOTOP
    (44) COMPOP -> . ADDOP
    (45) COMPOP -> . COMPOP COMPSIMB ADDOP
    (46) ADDOP -> . PRODOP
    (47) ADDOP -> . ADDOP - PRODOP
    (48) ADDOP -> . ADDOP + PRODOP
    (49) PRODOP -> . PAROP
    (50) PRODOP -> . PRODOP / PAROP
    (51) PRODOP -> . PRODOP * PAROP
    (52) PAROP -> . VAL
    (53) PAROP -> . ( OROP )
    (54) VAL -> . & ID
    (55) VAL -> . ID
    (56) VAL -> . CHAR
    (57) VAL -> . NUMBERF
    (58) VAL -> . NUMBER
    !               shift and go to state 36
    (               shift and go to state 23
    &               shift and go to state 41
    ID              shift and go to state 50
    CHAR            shift and go to state 42
    NUMBERF         shift and go to state 43
    NUMBER          shift and go to state 44

    OROP                           shift and go to state 49
    ANDOP                          shift and go to state 32
    NOTOP                          shift and go to state 34
    COMPOP                         shift and go to state 35
    ADDOP                          shift and go to state 37
    PRODOP                         shift and go to state 38
    PAROP                          shift and go to state 39
    VAL                            shift and go to state 40

state 24

    (1) S -> S2 TYPE emptymain MAIN ( ) { LINES } .
    $end            reduce using rule 1 (S -> S2 TYPE emptymain MAIN ( ) { LINES } .)


state 25

    (14) LINES -> LINES LINE . ;
    ;               shift and go to state 51


state 26

    (15) LINE -> PRINT . ( STRING PRINTIDS )
    (               shift and go to state 52


state 27

    (16) LINE -> SCANF . ( STRING SCANIDS )
    (               shift and go to state 53


state 28

    (17) LINE -> DECLAR .
    ;               reduce using rule 17 (LINE -> DECLAR .)


state 29

    (18) LINE -> INSTR .
    ;               reduce using rule 18 (LINE -> INSTR .)


state 30

    (23) INSTR -> OROP .
    (39) OROP -> OROP . ORSIMB ANDOP
    ;               reduce using rule 23 (INSTR -> OROP .)
    ,               reduce using rule 23 (INSTR -> OROP .)
    )               reduce using rule 23 (INSTR -> OROP .)
    ORSIMB          shift and go to state 54


state 31

    (24) INSTR -> ASIG .
    ;               reduce using rule 24 (INSTR -> ASIG .)
    ,               reduce using rule 24 (INSTR -> ASIG .)
    )               reduce using rule 24 (INSTR -> ASIG .)


state 32

    (38) OROP -> ANDOP .
    (41) ANDOP -> ANDOP . ANDSIMB NOTOP
    ORSIMB          reduce using rule 38 (OROP -> ANDOP .)
    ;               reduce using rule 38 (OROP -> ANDOP .)
    )               reduce using rule 38 (OROP -> ANDOP .)
    ,               reduce using rule 38 (OROP -> ANDOP .)
    ANDSIMB         shift and go to state 55


state 33

    (37) ASIG -> ID . = INSTR
    (55) VAL -> ID .
    =               shift and go to state 56
    /               reduce using rule 55 (VAL -> ID .)
    *               reduce using rule 55 (VAL -> ID .)
    -               reduce using rule 55 (VAL -> ID .)
    +               reduce using rule 55 (VAL -> ID .)
    COMPSIMB        reduce using rule 55 (VAL -> ID .)
    ANDSIMB         reduce using rule 55 (VAL -> ID .)
    ORSIMB          reduce using rule 55 (VAL -> ID .)
    ;               reduce using rule 55 (VAL -> ID .)
    ,               reduce using rule 55 (VAL -> ID .)
    )               reduce using rule 55 (VAL -> ID .)


state 34

    (40) ANDOP -> NOTOP .
    ANDSIMB         reduce using rule 40 (ANDOP -> NOTOP .)
    ORSIMB          reduce using rule 40 (ANDOP -> NOTOP .)
    ;               reduce using rule 40 (ANDOP -> NOTOP .)
    )               reduce using rule 40 (ANDOP -> NOTOP .)
    ,               reduce using rule 40 (ANDOP -> NOTOP .)


state 35

    (42) NOTOP -> COMPOP .
    (45) COMPOP -> COMPOP . COMPSIMB ADDOP
    ANDSIMB         reduce using rule 42 (NOTOP -> COMPOP .)
    ORSIMB          reduce using rule 42 (NOTOP -> COMPOP .)
    ;               reduce using rule 42 (NOTOP -> COMPOP .)
    )               reduce using rule 42 (NOTOP -> COMPOP .)
    ,               reduce using rule 42 (NOTOP -> COMPOP .)
    COMPSIMB        shift and go to state 57


state 36

    (43) NOTOP -> ! . NOTOP
    (42) NOTOP -> . COMPOP
    (43) NOTOP -> . ! NOTOP
    (44) COMPOP -> . ADDOP
    (45) COMPOP -> . COMPOP COMPSIMB ADDOP
    (46) ADDOP -> . PRODOP
    (47) ADDOP -> . ADDOP - PRODOP
    (48) ADDOP -> . ADDOP + PRODOP
    (49) PRODOP -> . PAROP
    (50) PRODOP -> . PRODOP / PAROP
    (51) PRODOP -> . PRODOP * PAROP
    (52) PAROP -> . VAL
    (53) PAROP -> . ( OROP )
    (54) VAL -> . & ID
    (55) VAL -> . ID
    (56) VAL -> . CHAR
    (57) VAL -> . NUMBERF
    (58) VAL -> . NUMBER
    !               shift and go to state 36
    (               shift and go to state 23
    &               shift and go to state 41
    ID              shift and go to state 50
    CHAR            shift and go to state 42
    NUMBERF         shift and go to state 43
    NUMBER          shift and go to state 44

    NOTOP                          shift and go to state 58
    COMPOP                         shift and go to state 35
    ADDOP                          shift and go to state 37
    PRODOP                         shift and go to state 38
    PAROP                          shift and go to state 39
    VAL                            shift and go to state 40

state 37

    (44) COMPOP -> ADDOP .
    (47) ADDOP -> ADDOP . - PRODOP
    (48) ADDOP -> ADDOP . + PRODOP
    COMPSIMB        reduce using rule 44 (COMPOP -> ADDOP .)
    ANDSIMB         reduce using rule 44 (COMPOP -> ADDOP .)
    ORSIMB          reduce using rule 44 (COMPOP -> ADDOP .)
    ;               reduce using rule 44 (COMPOP -> ADDOP .)
    )               reduce using rule 44 (COMPOP -> ADDOP .)
    ,               reduce using rule 44 (COMPOP -> ADDOP .)
    -               shift and go to state 59
    +               shift and go to state 60


state 38

    (46) ADDOP -> PRODOP .
    (50) PRODOP -> PRODOP . / PAROP
    (51) PRODOP -> PRODOP . * PAROP
    -               reduce using rule 46 (ADDOP -> PRODOP .)
    +               reduce using rule 46 (ADDOP -> PRODOP .)
    COMPSIMB        reduce using rule 46 (ADDOP -> PRODOP .)
    ANDSIMB         reduce using rule 46 (ADDOP -> PRODOP .)
    ORSIMB          reduce using rule 46 (ADDOP -> PRODOP .)
    ;               reduce using rule 46 (ADDOP -> PRODOP .)
    )               reduce using rule 46 (ADDOP -> PRODOP .)
    ,               reduce using rule 46 (ADDOP -> PRODOP .)
    /               shift and go to state 61
    *               shift and go to state 62


state 39

    (49) PRODOP -> PAROP .
    /               reduce using rule 49 (PRODOP -> PAROP .)
    *               reduce using rule 49 (PRODOP -> PAROP .)
    -               reduce using rule 49 (PRODOP -> PAROP .)
    +               reduce using rule 49 (PRODOP -> PAROP .)
    COMPSIMB        reduce using rule 49 (PRODOP -> PAROP .)
    ANDSIMB         reduce using rule 49 (PRODOP -> PAROP .)
    ORSIMB          reduce using rule 49 (PRODOP -> PAROP .)
    ;               reduce using rule 49 (PRODOP -> PAROP .)
    )               reduce using rule 49 (PRODOP -> PAROP .)
    ,               reduce using rule 49 (PRODOP -> PAROP .)


state 40

    (52) PAROP -> VAL .
    /               reduce using rule 52 (PAROP -> VAL .)
    *               reduce using rule 52 (PAROP -> VAL .)
    -               reduce using rule 52 (PAROP -> VAL .)
    +               reduce using rule 52 (PAROP -> VAL .)
    COMPSIMB        reduce using rule 52 (PAROP -> VAL .)
    ANDSIMB         reduce using rule 52 (PAROP -> VAL .)
    ORSIMB          reduce using rule 52 (PAROP -> VAL .)
    ;               reduce using rule 52 (PAROP -> VAL .)
    )               reduce using rule 52 (PAROP -> VAL .)
    ,               reduce using rule 52 (PAROP -> VAL .)


state 41

    (54) VAL -> & . ID
    ID              shift and go to state 63


state 42

    (56) VAL -> CHAR .
    /               reduce using rule 56 (VAL -> CHAR .)
    *               reduce using rule 56 (VAL -> CHAR .)
    -               reduce using rule 56 (VAL -> CHAR .)
    +               reduce using rule 56 (VAL -> CHAR .)
    COMPSIMB        reduce using rule 56 (VAL -> CHAR .)
    ANDSIMB         reduce using rule 56 (VAL -> CHAR .)
    ORSIMB          reduce using rule 56 (VAL -> CHAR .)
    ;               reduce using rule 56 (VAL -> CHAR .)
    )               reduce using rule 56 (VAL -> CHAR .)
    ,               reduce using rule 56 (VAL -> CHAR .)


state 43

    (57) VAL -> NUMBERF .
    /               reduce using rule 57 (VAL -> NUMBERF .)
    *               reduce using rule 57 (VAL -> NUMBERF .)
    -               reduce using rule 57 (VAL -> NUMBERF .)
    +               reduce using rule 57 (VAL -> NUMBERF .)
    COMPSIMB        reduce using rule 57 (VAL -> NUMBERF .)
    ANDSIMB         reduce using rule 57 (VAL -> NUMBERF .)
    ORSIMB          reduce using rule 57 (VAL -> NUMBERF .)
    ;               reduce using rule 57 (VAL -> NUMBERF .)
    )               reduce using rule 57 (VAL -> NUMBERF .)
    ,               reduce using rule 57 (VAL -> NUMBERF .)


state 44

    (58) VAL -> NUMBER .
    /               reduce using rule 58 (VAL -> NUMBER .)
    *               reduce using rule 58 (VAL -> NUMBER .)
    -               reduce using rule 58 (VAL -> NUMBER .)
    +               reduce using rule 58 (VAL -> NUMBER .)
    COMPSIMB        reduce using rule 58 (VAL -> NUMBER .)
    ANDSIMB         reduce using rule 58 (VAL -> NUMBER .)
    ORSIMB          reduce using rule 58 (VAL -> NUMBER .)
    ;               reduce using rule 58 (VAL -> NUMBER .)
    )               reduce using rule 58 (VAL -> NUMBER .)
    ,               reduce using rule 58 (VAL -> NUMBER .)


state 45

    (9) RARGS -> , TYPE . ARG RARGS
    (12) ARG -> . ID
    ID              shift and go to state 16

    ARG                            shift and go to state 64

state 46

    (5) FUNCTION -> TYPE ID emptyF1 ( ARGS ) { LINES . } emptyF2
    (14) LINES -> LINES . LINE ;
    (15) LINE -> . PRINT ( STRING PRINTIDS )
    (16) LINE -> . SCANF ( STRING SCANIDS )
    (17) LINE -> . DECLAR
    (18) LINE -> . INSTR
    (25) DECLAR -> . TYPE POINTERS IDPRIMA
    (23) INSTR -> . OROP
    (24) INSTR -> . ASIG
    (38) OROP -> . ANDOP
    (39) OROP -> . OROP ORSIMB ANDOP
    (37) ASIG -> . ID = INSTR
    (40) ANDOP -> . NOTOP
    (41) ANDOP -> . ANDOP ANDSIMB NOTOP
    (42) NOTOP -> . COMPOP
    (43) NOTOP -> . ! NOTOP
    (44) COMPOP -> . ADDOP
    (45) COMPOP -> . COMPOP COMPSIMB ADDOP
    (46) ADDOP -> . PRODOP
    (47) ADDOP -> . ADDOP - PRODOP
    (48) ADDOP -> . ADDOP + PRODOP
    (49) PRODOP -> . PAROP
    (50) PRODOP -> . PRODOP / PAROP
    (51) PRODOP -> . PRODOP * PAROP
    (52) PAROP -> . VAL
    (53) PAROP -> . ( OROP )
    (54) VAL -> . & ID
    (55) VAL -> . ID
    (56) VAL -> . CHAR
    (57) VAL -> . NUMBERF
    (58) VAL -> . NUMBER
    }               shift and go to state 65
    PRINT           shift and go to state 26
    SCANF           shift and go to state 27
    TYPE            shift and go to state 22
    ID              shift and go to state 33
    !               shift and go to state 36
    (               shift and go to state 23
    &               shift and go to state 41
    CHAR            shift and go to state 42
    NUMBERF         shift and go to state 43
    NUMBER          shift and go to state 44

    LINE                           shift and go to state 25
    DECLAR                         shift and go to state 28
    INSTR                          shift and go to state 29
    OROP                           shift and go to state 30
    ASIG                           shift and go to state 31
    ANDOP                          shift and go to state 32
    NOTOP                          shift and go to state 34
    COMPOP                         shift and go to state 35
    ADDOP                          shift and go to state 37
    PRODOP                         shift and go to state 38
    PAROP                          shift and go to state 39
    VAL                            shift and go to state 40

state 47

    (25) DECLAR -> TYPE POINTERS . IDPRIMA
    (28) IDPRIMA -> . empty ELEM REST
    (35) empty -> .
    ID              reduce using rule 35 (empty -> .)

    IDPRIMA                        shift and go to state 66
    empty                          shift and go to state 67

state 48

    (27) POINTERS -> * . POINTERS
    (26) POINTERS -> .
    (27) POINTERS -> . * POINTERS
    ID              reduce using rule 26 (POINTERS -> .)
    *               shift and go to state 48

    POINTERS                       shift and go to state 68

state 49

    (53) PAROP -> ( OROP . )
    (39) OROP -> OROP . ORSIMB ANDOP
    )               shift and go to state 69
    ORSIMB          shift and go to state 54


state 50

    (55) VAL -> ID .
    /               reduce using rule 55 (VAL -> ID .)
    *               reduce using rule 55 (VAL -> ID .)
    -               reduce using rule 55 (VAL -> ID .)
    +               reduce using rule 55 (VAL -> ID .)
    COMPSIMB        reduce using rule 55 (VAL -> ID .)
    ANDSIMB         reduce using rule 55 (VAL -> ID .)
    )               reduce using rule 55 (VAL -> ID .)
    ORSIMB          reduce using rule 55 (VAL -> ID .)
    ;               reduce using rule 55 (VAL -> ID .)
    ,               reduce using rule 55 (VAL -> ID .)


state 51

    (14) LINES -> LINES LINE ; .
    }               reduce using rule 14 (LINES -> LINES LINE ; .)
    PRINT           reduce using rule 14 (LINES -> LINES LINE ; .)
    SCANF           reduce using rule 14 (LINES -> LINES LINE ; .)
    TYPE            reduce using rule 14 (LINES -> LINES LINE ; .)
    ID              reduce using rule 14 (LINES -> LINES LINE ; .)
    !               reduce using rule 14 (LINES -> LINES LINE ; .)
    (               reduce using rule 14 (LINES -> LINES LINE ; .)
    &               reduce using rule 14 (LINES -> LINES LINE ; .)
    CHAR            reduce using rule 14 (LINES -> LINES LINE ; .)
    NUMBERF         reduce using rule 14 (LINES -> LINES LINE ; .)
    NUMBER          reduce using rule 14 (LINES -> LINES LINE ; .)


state 52

    (15) LINE -> PRINT ( . STRING PRINTIDS )
    STRING          shift and go to state 70


state 53

    (16) LINE -> SCANF ( . STRING SCANIDS )
    STRING          shift and go to state 71


state 54

    (39) OROP -> OROP ORSIMB . ANDOP
    (40) ANDOP -> . NOTOP
    (41) ANDOP -> . ANDOP ANDSIMB NOTOP
    (42) NOTOP -> . COMPOP
    (43) NOTOP -> . ! NOTOP
    (44) COMPOP -> . ADDOP
    (45) COMPOP -> . COMPOP COMPSIMB ADDOP
    (46) ADDOP -> . PRODOP
    (47) ADDOP -> . ADDOP - PRODOP
    (48) ADDOP -> . ADDOP + PRODOP
    (49) PRODOP -> . PAROP
    (50) PRODOP -> . PRODOP / PAROP
    (51) PRODOP -> . PRODOP * PAROP
    (52) PAROP -> . VAL
    (53) PAROP -> . ( OROP )
    (54) VAL -> . & ID
    (55) VAL -> . ID
    (56) VAL -> . CHAR
    (57) VAL -> . NUMBERF
    (58) VAL -> . NUMBER
    !               shift and go to state 36
    (               shift and go to state 23
    &               shift and go to state 41
    ID              shift and go to state 50
    CHAR            shift and go to state 42
    NUMBERF         shift and go to state 43
    NUMBER          shift and go to state 44

    ANDOP                          shift and go to state 72
    NOTOP                          shift and go to state 34
    COMPOP                         shift and go to state 35
    ADDOP                          shift and go to state 37
    PRODOP                         shift and go to state 38
    PAROP                          shift and go to state 39
    VAL                            shift and go to state 40

state 55

    (41) ANDOP -> ANDOP ANDSIMB . NOTOP
    (42) NOTOP -> . COMPOP
    (43) NOTOP -> . ! NOTOP
    (44) COMPOP -> . ADDOP
    (45) COMPOP -> . COMPOP COMPSIMB ADDOP
    (46) ADDOP -> . PRODOP
    (47) ADDOP -> . ADDOP - PRODOP
    (48) ADDOP -> . ADDOP + PRODOP
    (49) PRODOP -> . PAROP
    (50) PRODOP -> . PRODOP / PAROP
    (51) PRODOP -> . PRODOP * PAROP
    (52) PAROP -> . VAL
    (53) PAROP -> . ( OROP )
    (54) VAL -> . & ID
    (55) VAL -> . ID
    (56) VAL -> . CHAR
    (57) VAL -> . NUMBERF
    (58) VAL -> . NUMBER
    !               shift and go to state 36
    (               shift and go to state 23
    &               shift and go to state 41
    ID              shift and go to state 50
    CHAR            shift and go to state 42
    NUMBERF         shift and go to state 43
    NUMBER          shift and go to state 44

    NOTOP                          shift and go to state 73
    COMPOP                         shift and go to state 35
    ADDOP                          shift and go to state 37
    PRODOP                         shift and go to state 38
    PAROP                          shift and go to state 39
    VAL                            shift and go to state 40

state 56

    (37) ASIG -> ID = . INSTR
    (23) INSTR -> . OROP
    (24) INSTR -> . ASIG
    (38) OROP -> . ANDOP
    (39) OROP -> . OROP ORSIMB ANDOP
    (37) ASIG -> . ID = INSTR
    (40) ANDOP -> . NOTOP
    (41) ANDOP -> . ANDOP ANDSIMB NOTOP
    (42) NOTOP -> . COMPOP
    (43) NOTOP -> . ! NOTOP
    (44) COMPOP -> . ADDOP
    (45) COMPOP -> . COMPOP COMPSIMB ADDOP
    (46) ADDOP -> . PRODOP
    (47) ADDOP -> . ADDOP - PRODOP
    (48) ADDOP -> . ADDOP + PRODOP
    (49) PRODOP -> . PAROP
    (50) PRODOP -> . PRODOP / PAROP
    (51) PRODOP -> . PRODOP * PAROP
    (52) PAROP -> . VAL
    (53) PAROP -> . ( OROP )
    (54) VAL -> . & ID
    (55) VAL -> . ID
    (56) VAL -> . CHAR
    (57) VAL -> . NUMBERF
    (58) VAL -> . NUMBER
    ID              shift and go to state 33
    !               shift and go to state 36
    (               shift and go to state 23
    &               shift and go to state 41
    CHAR            shift and go to state 42
    NUMBERF         shift and go to state 43
    NUMBER          shift and go to state 44

    INSTR                          shift and go to state 74
    OROP                           shift and go to state 30
    ASIG                           shift and go to state 31
    ANDOP                          shift and go to state 32
    NOTOP                          shift and go to state 34
    COMPOP                         shift and go to state 35
    ADDOP                          shift and go to state 37
    PRODOP                         shift and go to state 38
    PAROP                          shift and go to state 39
    VAL                            shift and go to state 40

state 57

    (45) COMPOP -> COMPOP COMPSIMB . ADDOP
    (46) ADDOP -> . PRODOP
    (47) ADDOP -> . ADDOP - PRODOP
    (48) ADDOP -> . ADDOP + PRODOP
    (49) PRODOP -> . PAROP
    (50) PRODOP -> . PRODOP / PAROP
    (51) PRODOP -> . PRODOP * PAROP
    (52) PAROP -> . VAL
    (53) PAROP -> . ( OROP )
    (54) VAL -> . & ID
    (55) VAL -> . ID
    (56) VAL -> . CHAR
    (57) VAL -> . NUMBERF
    (58) VAL -> . NUMBER
    (               shift and go to state 23
    &               shift and go to state 41
    ID              shift and go to state 50
    CHAR            shift and go to state 42
    NUMBERF         shift and go to state 43
    NUMBER          shift and go to state 44

    ADDOP                          shift and go to state 75
    PRODOP                         shift and go to state 38
    PAROP                          shift and go to state 39
    VAL                            shift and go to state 40

state 58

    (43) NOTOP -> ! NOTOP .
    ANDSIMB         reduce using rule 43 (NOTOP -> ! NOTOP .)
    ORSIMB          reduce using rule 43 (NOTOP -> ! NOTOP .)
    ;               reduce using rule 43 (NOTOP -> ! NOTOP .)
    )               reduce using rule 43 (NOTOP -> ! NOTOP .)
    ,               reduce using rule 43 (NOTOP -> ! NOTOP .)


state 59

    (47) ADDOP -> ADDOP - . PRODOP
    (49) PRODOP -> . PAROP
    (50) PRODOP -> . PRODOP / PAROP
    (51) PRODOP -> . PRODOP * PAROP
    (52) PAROP -> . VAL
    (53) PAROP -> . ( OROP )
    (54) VAL -> . & ID
    (55) VAL -> . ID
    (56) VAL -> . CHAR
    (57) VAL -> . NUMBERF
    (58) VAL -> . NUMBER
    (               shift and go to state 23
    &               shift and go to state 41
    ID              shift and go to state 50
    CHAR            shift and go to state 42
    NUMBERF         shift and go to state 43
    NUMBER          shift and go to state 44

    PRODOP                         shift and go to state 76
    PAROP                          shift and go to state 39
    VAL                            shift and go to state 40

state 60

    (48) ADDOP -> ADDOP + . PRODOP
    (49) PRODOP -> . PAROP
    (50) PRODOP -> . PRODOP / PAROP
    (51) PRODOP -> . PRODOP * PAROP
    (52) PAROP -> . VAL
    (53) PAROP -> . ( OROP )
    (54) VAL -> . & ID
    (55) VAL -> . ID
    (56) VAL -> . CHAR
    (57) VAL -> . NUMBERF
    (58) VAL -> . NUMBER
    (               shift and go to state 23
    &               shift and go to state 41
    ID              shift and go to state 50
    CHAR            shift and go to state 42
    NUMBERF         shift and go to state 43
    NUMBER          shift and go to state 44

    PRODOP                         shift and go to state 77
    PAROP                          shift and go to state 39
    VAL                            shift and go to state 40

state 61

    (50) PRODOP -> PRODOP / . PAROP
    (52) PAROP -> . VAL
    (53) PAROP -> . ( OROP )
    (54) VAL -> . & ID
    (55) VAL -> . ID
    (56) VAL -> . CHAR
    (57) VAL -> . NUMBERF
    (58) VAL -> . NUMBER
    (               shift and go to state 23
    &               shift and go to state 41
    ID              shift and go to state 50
    CHAR            shift and go to state 42
    NUMBERF         shift and go to state 43
    NUMBER          shift and go to state 44

    PAROP                          shift and go to state 78
    VAL                            shift and go to state 40

state 62

    (51) PRODOP -> PRODOP * . PAROP
    (52) PAROP -> . VAL
    (53) PAROP -> . ( OROP )
    (54) VAL -> . & ID
    (55) VAL -> . ID
    (56) VAL -> . CHAR
    (57) VAL -> . NUMBERF
    (58) VAL -> . NUMBER
    (               shift and go to state 23
    &               shift and go to state 41
    ID              shift and go to state 50
    CHAR            shift and go to state 42
    NUMBERF         shift and go to state 43
    NUMBER          shift and go to state 44

    PAROP                          shift and go to state 79
    VAL                            shift and go to state 40

state 63

    (54) VAL -> & ID .
    /               reduce using rule 54 (VAL -> & ID .)
    *               reduce using rule 54 (VAL -> & ID .)
    -               reduce using rule 54 (VAL -> & ID .)
    +               reduce using rule 54 (VAL -> & ID .)
    COMPSIMB        reduce using rule 54 (VAL -> & ID .)
    ANDSIMB         reduce using rule 54 (VAL -> & ID .)
    ORSIMB          reduce using rule 54 (VAL -> & ID .)
    ;               reduce using rule 54 (VAL -> & ID .)
    )               reduce using rule 54 (VAL -> & ID .)
    ,               reduce using rule 54 (VAL -> & ID .)


state 64

    (9) RARGS -> , TYPE ARG . RARGS
    (8) RARGS -> .
    (9) RARGS -> . , TYPE ARG RARGS
    )               reduce using rule 8 (RARGS -> .)
    ,               shift and go to state 20

    RARGS                          shift and go to state 80

state 65

    (5) FUNCTION -> TYPE ID emptyF1 ( ARGS ) { LINES } . emptyF2
    (11) emptyF2 -> .
    TYPE            reduce using rule 11 (emptyF2 -> .)

    emptyF2                        shift and go to state 81

state 66

    (25) DECLAR -> TYPE POINTERS IDPRIMA .
    ;               reduce using rule 25 (DECLAR -> TYPE POINTERS IDPRIMA .)


state 67

    (28) IDPRIMA -> empty . ELEM REST
    (31) ELEM -> . ID = INSTR
    (32) ELEM -> . ID ARRAY
    ID              shift and go to state 83

    ELEM                           shift and go to state 82

state 68

    (27) POINTERS -> * POINTERS .
    ID              reduce using rule 27 (POINTERS -> * POINTERS .)


state 69

    (53) PAROP -> ( OROP ) .
    /               reduce using rule 53 (PAROP -> ( OROP ) .)
    *               reduce using rule 53 (PAROP -> ( OROP ) .)
    -               reduce using rule 53 (PAROP -> ( OROP ) .)
    +               reduce using rule 53 (PAROP -> ( OROP ) .)
    COMPSIMB        reduce using rule 53 (PAROP -> ( OROP ) .)
    ANDSIMB         reduce using rule 53 (PAROP -> ( OROP ) .)
    ORSIMB          reduce using rule 53 (PAROP -> ( OROP ) .)
    ;               reduce using rule 53 (PAROP -> ( OROP ) .)
    )               reduce using rule 53 (PAROP -> ( OROP ) .)
    ,               reduce using rule 53 (PAROP -> ( OROP ) .)


state 70

    (15) LINE -> PRINT ( STRING . PRINTIDS )
    (21) PRINTIDS -> .
    (22) PRINTIDS -> . , INSTR PRINTIDS
    )               reduce using rule 21 (PRINTIDS -> .)
    ,               shift and go to state 85

    PRINTIDS                       shift and go to state 84

state 71

    (16) LINE -> SCANF ( STRING . SCANIDS )
    (19) SCANIDS -> .
    (20) SCANIDS -> . , & ID SCANIDS
    )               reduce using rule 19 (SCANIDS -> .)
    ,               shift and go to state 87

    SCANIDS                        shift and go to state 86

state 72

    (39) OROP -> OROP ORSIMB ANDOP .
    (41) ANDOP -> ANDOP . ANDSIMB NOTOP
    ORSIMB          reduce using rule 39 (OROP -> OROP ORSIMB ANDOP .)
    ;               reduce using rule 39 (OROP -> OROP ORSIMB ANDOP .)
    )               reduce using rule 39 (OROP -> OROP ORSIMB ANDOP .)
    ,               reduce using rule 39 (OROP -> OROP ORSIMB ANDOP .)
    ANDSIMB         shift and go to state 55


state 73

    (41) ANDOP -> ANDOP ANDSIMB NOTOP .
    ANDSIMB         reduce using rule 41 (ANDOP -> ANDOP ANDSIMB NOTOP .)
    ORSIMB          reduce using rule 41 (ANDOP -> ANDOP ANDSIMB NOTOP .)
    ;               reduce using rule 41 (ANDOP -> ANDOP ANDSIMB NOTOP .)
    )               reduce using rule 41 (ANDOP -> ANDOP ANDSIMB NOTOP .)
    ,               reduce using rule 41 (ANDOP -> ANDOP ANDSIMB NOTOP .)


state 74

    (37) ASIG -> ID = INSTR .
    ;               reduce using rule 37 (ASIG -> ID = INSTR .)
    ,               reduce using rule 37 (ASIG -> ID = INSTR .)
    )               reduce using rule 37 (ASIG -> ID = INSTR .)


state 75

    (45) COMPOP -> COMPOP COMPSIMB ADDOP .
    (47) ADDOP -> ADDOP . - PRODOP
    (48) ADDOP -> ADDOP . + PRODOP
    COMPSIMB        reduce using rule 45 (COMPOP -> COMPOP COMPSIMB ADDOP .)
    ANDSIMB         reduce using rule 45 (COMPOP -> COMPOP COMPSIMB ADDOP .)
    ORSIMB          reduce using rule 45 (COMPOP -> COMPOP COMPSIMB ADDOP .)
    ;               reduce using rule 45 (COMPOP -> COMPOP COMPSIMB ADDOP .)
    )               reduce using rule 45 (COMPOP -> COMPOP COMPSIMB ADDOP .)
    ,               reduce using rule 45 (COMPOP -> COMPOP COMPSIMB ADDOP .)
    -               shift and go to state 59
    +               shift and go to state 60


state 76

    (47) ADDOP -> ADDOP - PRODOP .
    (50) PRODOP -> PRODOP . / PAROP
    (51) PRODOP -> PRODOP . * PAROP
    -               reduce using rule 47 (ADDOP -> ADDOP - PRODOP .)
    +               reduce using rule 47 (ADDOP -> ADDOP - PRODOP .)
    COMPSIMB        reduce using rule 47 (ADDOP -> ADDOP - PRODOP .)
    ANDSIMB         reduce using rule 47 (ADDOP -> ADDOP - PRODOP .)
    ORSIMB          reduce using rule 47 (ADDOP -> ADDOP - PRODOP .)
    ;               reduce using rule 47 (ADDOP -> ADDOP - PRODOP .)
    )               reduce using rule 47 (ADDOP -> ADDOP - PRODOP .)
    ,               reduce using rule 47 (ADDOP -> ADDOP - PRODOP .)
    /               shift and go to state 61
    *               shift and go to state 62


state 77

    (48) ADDOP -> ADDOP + PRODOP .
    (50) PRODOP -> PRODOP . / PAROP
    (51) PRODOP -> PRODOP . * PAROP
    -               reduce using rule 48 (ADDOP -> ADDOP + PRODOP .)
    +               reduce using rule 48 (ADDOP -> ADDOP + PRODOP .)
    COMPSIMB        reduce using rule 48 (ADDOP -> ADDOP + PRODOP .)
    ANDSIMB         reduce using rule 48 (ADDOP -> ADDOP + PRODOP .)
    ORSIMB          reduce using rule 48 (ADDOP -> ADDOP + PRODOP .)
    ;               reduce using rule 48 (ADDOP -> ADDOP + PRODOP .)
    )               reduce using rule 48 (ADDOP -> ADDOP + PRODOP .)
    ,               reduce using rule 48 (ADDOP -> ADDOP + PRODOP .)
    /               shift and go to state 61
    *               shift and go to state 62


state 78

    (50) PRODOP -> PRODOP / PAROP .
    /               reduce using rule 50 (PRODOP -> PRODOP / PAROP .)
    *               reduce using rule 50 (PRODOP -> PRODOP / PAROP .)
    -               reduce using rule 50 (PRODOP -> PRODOP / PAROP .)
    +               reduce using rule 50 (PRODOP -> PRODOP / PAROP .)
    COMPSIMB        reduce using rule 50 (PRODOP -> PRODOP / PAROP .)
    ANDSIMB         reduce using rule 50 (PRODOP -> PRODOP / PAROP .)
    ORSIMB          reduce using rule 50 (PRODOP -> PRODOP / PAROP .)
    ;               reduce using rule 50 (PRODOP -> PRODOP / PAROP .)
    )               reduce using rule 50 (PRODOP -> PRODOP / PAROP .)
    ,               reduce using rule 50 (PRODOP -> PRODOP / PAROP .)


state 79

    (51) PRODOP -> PRODOP * PAROP .
    /               reduce using rule 51 (PRODOP -> PRODOP * PAROP .)
    *               reduce using rule 51 (PRODOP -> PRODOP * PAROP .)
    -               reduce using rule 51 (PRODOP -> PRODOP * PAROP .)
    +               reduce using rule 51 (PRODOP -> PRODOP * PAROP .)
    COMPSIMB        reduce using rule 51 (PRODOP -> PRODOP * PAROP .)
    ANDSIMB         reduce using rule 51 (PRODOP -> PRODOP * PAROP .)
    ORSIMB          reduce using rule 51 (PRODOP -> PRODOP * PAROP .)
    ;               reduce using rule 51 (PRODOP -> PRODOP * PAROP .)
    )               reduce using rule 51 (PRODOP -> PRODOP * PAROP .)
    ,               reduce using rule 51 (PRODOP -> PRODOP * PAROP .)


state 80

    (9) RARGS -> , TYPE ARG RARGS .
    )               reduce using rule 9 (RARGS -> , TYPE ARG RARGS .)


state 81

    (5) FUNCTION -> TYPE ID emptyF1 ( ARGS ) { LINES } emptyF2 .
    TYPE            reduce using rule 5 (FUNCTION -> TYPE ID emptyF1 ( ARGS ) { LINES } emptyF2 .)


state 82

    (28) IDPRIMA -> empty ELEM . REST
    (29) REST -> .
    (30) REST -> . , empty2 ELEM REST
    ;               reduce using rule 29 (REST -> .)
    ,               shift and go to state 89

    REST                           shift and go to state 88

state 83

    (31) ELEM -> ID . = INSTR
    (32) ELEM -> ID . ARRAY
    (33) ARRAY -> .
    (34) ARRAY -> . [ NUMBER ] ARRAY
    =               shift and go to state 90
    ,               reduce using rule 33 (ARRAY -> .)
    ;               reduce using rule 33 (ARRAY -> .)
    [               shift and go to state 92

    ARRAY                          shift and go to state 91

state 84

    (15) LINE -> PRINT ( STRING PRINTIDS . )
    )               shift and go to state 93


state 85

    (22) PRINTIDS -> , . INSTR PRINTIDS
    (23) INSTR -> . OROP
    (24) INSTR -> . ASIG
    (38) OROP -> . ANDOP
    (39) OROP -> . OROP ORSIMB ANDOP
    (37) ASIG -> . ID = INSTR
    (40) ANDOP -> . NOTOP
    (41) ANDOP -> . ANDOP ANDSIMB NOTOP
    (42) NOTOP -> . COMPOP
    (43) NOTOP -> . ! NOTOP
    (44) COMPOP -> . ADDOP
    (45) COMPOP -> . COMPOP COMPSIMB ADDOP
    (46) ADDOP -> . PRODOP
    (47) ADDOP -> . ADDOP - PRODOP
    (48) ADDOP -> . ADDOP + PRODOP
    (49) PRODOP -> . PAROP
    (50) PRODOP -> . PRODOP / PAROP
    (51) PRODOP -> . PRODOP * PAROP
    (52) PAROP -> . VAL
    (53) PAROP -> . ( OROP )
    (54) VAL -> . & ID
    (55) VAL -> . ID
    (56) VAL -> . CHAR
    (57) VAL -> . NUMBERF
    (58) VAL -> . NUMBER
    ID              shift and go to state 33
    !               shift and go to state 36
    (               shift and go to state 23
    &               shift and go to state 41
    CHAR            shift and go to state 42
    NUMBERF         shift and go to state 43
    NUMBER          shift and go to state 44

    INSTR                          shift and go to state 94
    OROP                           shift and go to state 30
    ASIG                           shift and go to state 31
    ANDOP                          shift and go to state 32
    NOTOP                          shift and go to state 34
    COMPOP                         shift and go to state 35
    ADDOP                          shift and go to state 37
    PRODOP                         shift and go to state 38
    PAROP                          shift and go to state 39
    VAL                            shift and go to state 40

state 86

    (16) LINE -> SCANF ( STRING SCANIDS . )
    )               shift and go to state 95


state 87

    (20) SCANIDS -> , . & ID SCANIDS
    &               shift and go to state 96


state 88

    (28) IDPRIMA -> empty ELEM REST .
    ;               reduce using rule 28 (IDPRIMA -> empty ELEM REST .)


state 89

    (30) REST -> , . empty2 ELEM REST
    (36) empty2 -> .
    ID              reduce using rule 36 (empty2 -> .)

    empty2                         shift and go to state 97

state 90

    (31) ELEM -> ID = . INSTR
    (23) INSTR -> . OROP
    (24) INSTR -> . ASIG
    (38) OROP -> . ANDOP
    (39) OROP -> . OROP ORSIMB ANDOP
    (37) ASIG -> . ID = INSTR
    (40) ANDOP -> . NOTOP
    (41) ANDOP -> . ANDOP ANDSIMB NOTOP
    (42) NOTOP -> . COMPOP
    (43) NOTOP -> . ! NOTOP
    (44) COMPOP -> . ADDOP
    (45) COMPOP -> . COMPOP COMPSIMB ADDOP
    (46) ADDOP -> . PRODOP
    (47) ADDOP -> . ADDOP - PRODOP
    (48) ADDOP -> . ADDOP + PRODOP
    (49) PRODOP -> . PAROP
    (50) PRODOP -> . PRODOP / PAROP
    (51) PRODOP -> . PRODOP * PAROP
    (52) PAROP -> . VAL
    (53) PAROP -> . ( OROP )
    (54) VAL -> . & ID
    (55) VAL -> . ID
    (56) VAL -> . CHAR
    (57) VAL -> . NUMBERF
    (58) VAL -> . NUMBER
    ID              shift and go to state 33
    !               shift and go to state 36
    (               shift and go to state 23
    &               shift and go to state 41
    CHAR            shift and go to state 42
    NUMBERF         shift and go to state 43
    NUMBER          shift and go to state 44

    INSTR                          shift and go to state 98
    OROP                           shift and go to state 30
    ASIG                           shift and go to state 31
    ANDOP                          shift and go to state 32
    NOTOP                          shift and go to state 34
    COMPOP                         shift and go to state 35
    ADDOP                          shift and go to state 37
    PRODOP                         shift and go to state 38
    PAROP                          shift and go to state 39
    VAL                            shift and go to state 40

state 91

    (32) ELEM -> ID ARRAY .
    ,               reduce using rule 32 (ELEM -> ID ARRAY .)
    ;               reduce using rule 32 (ELEM -> ID ARRAY .)


state 92

    (34) ARRAY -> [ . NUMBER ] ARRAY
    NUMBER          shift and go to state 99


state 93

    (15) LINE -> PRINT ( STRING PRINTIDS ) .
    ;               reduce using rule 15 (LINE -> PRINT ( STRING PRINTIDS ) .)


state 94

    (22) PRINTIDS -> , INSTR . PRINTIDS
    (21) PRINTIDS -> .
    (22) PRINTIDS -> . , INSTR PRINTIDS
    )               reduce using rule 21 (PRINTIDS -> .)
    ,               shift and go to state 85

    PRINTIDS                       shift and go to state 100

state 95

    (16) LINE -> SCANF ( STRING SCANIDS ) .
    ;               reduce using rule 16 (LINE -> SCANF ( STRING SCANIDS ) .)


state 96

    (20) SCANIDS -> , & . ID SCANIDS
    ID              shift and go to state 101


state 97

    (30) REST -> , empty2 . ELEM REST
    (31) ELEM -> . ID = INSTR
    (32) ELEM -> . ID ARRAY
    ID              shift and go to state 83

    ELEM                           shift and go to state 102

state 98

    (31) ELEM -> ID = INSTR .
    ,               reduce using rule 31 (ELEM -> ID = INSTR .)
    ;               reduce using rule 31 (ELEM -> ID = INSTR .)


state 99

    (34) ARRAY -> [ NUMBER . ] ARRAY
    ]               shift and go to state 103


state 100

    (22) PRINTIDS -> , INSTR PRINTIDS .
    )               reduce using rule 22 (PRINTIDS -> , INSTR PRINTIDS .)


state 101

    (20) SCANIDS -> , & ID . SCANIDS
    (19) SCANIDS -> .
    (20) SCANIDS -> . , & ID SCANIDS
    )               reduce using rule 19 (SCANIDS -> .)
    ,               shift and go to state 87

    SCANIDS                        shift and go to state 104

state 102

    (30) REST -> , empty2 ELEM . REST
    (29) REST -> .
    (30) REST -> . , empty2 ELEM REST
    ;               reduce using rule 29 (REST -> .)
    ,               shift and go to state 89

    REST                           shift and go to state 105

state 103

    (34) ARRAY -> [ NUMBER ] . ARRAY
    (33) ARRAY -> .
    (34) ARRAY -> . [ NUMBER ] ARRAY
    ,               reduce using rule 33 (ARRAY -> .)
    ;               reduce using rule 33 (ARRAY -> .)
    [               shift and go to state 92

    ARRAY                          shift and go to state 106

state 104

    (20) SCANIDS -> , & ID SCANIDS .
    )               reduce using rule 20 (SCANIDS -> , & ID SCANIDS .)


state 105

    (30) REST -> , empty2 ELEM REST .
    ;               reduce using rule 30 (REST -> , empty2 ELEM REST .)


state 106

    (34) ARRAY -> [ NUMBER ] ARRAY .
    ,               reduce using rule 34 (ARRAY -> [ NUMBER ] ARRAY .)
    ;               reduce using rule 34 (ARRAY -> [ NUMBER ] ARRAY .)
