Grammar:

Rule 0     S' -> S
Rule 1     S -> S2 TYPE emptymain MAIN ( ) { LINES }
Rule 2     emptymain -> <empty>
Rule 3     S2 -> <empty>
Rule 4     S2 -> S2 FUNCTION
Rule 5     FUNCTION -> FUNCTYPE ID emptyF1 ( ARGS ) { LINES }
Rule 6     FUNCTYPE -> VOIDTYPE
Rule 7     FUNCTYPE -> TYPE
Rule 8     ARGS -> <empty>
Rule 9     ARGS -> TYPE ARG RARGS
Rule 10    RARGS -> <empty>
Rule 11    RARGS -> , TYPE ARG RARGS
Rule 12    emptyF1 -> <empty>
Rule 13    ARG -> ID
Rule 14    LINES -> <empty>
Rule 15    LINES -> LINES LINE ;
Rule 16    LINE -> PRINT ( STRING PRINTIDS )
Rule 17    LINE -> DECLAR
Rule 18    LINE -> INSTR
Rule 19    PRINTIDS -> <empty>
Rule 20    PRINTIDS -> , INSTR PRINTIDS
Rule 21    INSTR -> OROP
Rule 22    INSTR -> ASIG
Rule 23    DECLAR -> TYPE POINTERS IDPRIMA
Rule 24    POINTERS -> <empty>
Rule 25    POINTERS -> * POINTERS
Rule 26    IDPRIMA -> empty ELEM REST
Rule 27    REST -> <empty>
Rule 28    REST -> , empty2 ELEM REST
Rule 29    ELEM -> ID = INSTR
Rule 30    ELEM -> ID ARRAY
Rule 31    ARRAY -> <empty>
Rule 32    ARRAY -> [ NUMBER ] ARRAY
Rule 33    empty -> <empty>
Rule 34    empty2 -> <empty>
Rule 35    ASIG -> ID = INSTR
Rule 36    OROP -> ANDOP
Rule 37    OROP -> OROP ORSIMB ANDOP
Rule 38    ANDOP -> NOTOP
Rule 39    ANDOP -> ANDOP ANDSIMB NOTOP
Rule 40    NOTOP -> COMPOP
Rule 41    NOTOP -> ! NOTOP
Rule 42    COMPOP -> ADDOP
Rule 43    COMPOP -> COMPOP COMPSIMB ADDOP
Rule 44    ADDOP -> PRODOP
Rule 45    ADDOP -> ADDOP - PRODOP
Rule 46    ADDOP -> ADDOP + PRODOP
Rule 47    PRODOP -> PAROP
Rule 48    PRODOP -> PRODOP / PAROP
Rule 49    PRODOP -> PRODOP * PAROP
Rule 50    PAROP -> VAL
Rule 51    PAROP -> ( OROP )
Rule 52    VAL -> & ID
Rule 53    VAL -> ID
Rule 54    VAL -> CHAR
Rule 55    VAL -> NUMBERF
Rule 56    VAL -> NUMBER

Terminals, with rules where they appear:

!                    : 41
&                    : 52
(                    : 1 5 16 51
)                    : 1 5 16 51
*                    : 25 49
+                    : 46
,                    : 11 20 28
-                    : 45
/                    : 48
;                    : 15
=                    : 29 35
ANDSIMB              : 39
CHAR                 : 54
COMPSIMB             : 43
ID                   : 5 13 29 30 35 52 53
MAIN                 : 1
NUMBER               : 32 56
NUMBERF              : 55
ORSIMB               : 37
PRINT                : 16
STRING               : 16
TYPE                 : 1 7 9 11 23
VOIDTYPE             : 6
[                    : 32
]                    : 32
error                : 
{                    : 1 5
}                    : 1 5

Nonterminals, with rules where they appear:

ADDOP                : 42 43 45 46
ANDOP                : 36 37 39
ARG                  : 9 11
ARGS                 : 5
ARRAY                : 30 32
ASIG                 : 22
COMPOP               : 40 43
DECLAR               : 17
ELEM                 : 26 28
FUNCTION             : 4
FUNCTYPE             : 5
IDPRIMA              : 23
INSTR                : 18 20 29 35
LINE                 : 15
LINES                : 1 5 15
NOTOP                : 38 39 41
OROP                 : 21 37 51
PAROP                : 47 48 49
POINTERS             : 23 25
PRINTIDS             : 16 20
PRODOP               : 44 45 46 48 49
RARGS                : 9 11
REST                 : 26 28
S                    : 0
S2                   : 1 4
VAL                  : 50
empty                : 26
empty2               : 28
emptyF1              : 5
emptymain            : 1


state 0

    (0) S' -> . S
    (1) S -> . S2 TYPE emptymain MAIN ( ) { LINES }
    (3) S2 -> .
    (4) S2 -> . S2 FUNCTION
    TYPE            reduce using rule 3 (S2 -> .)
    VOIDTYPE        reduce using rule 3 (S2 -> .)

    S                              shift and go to state 1
    S2                             shift and go to state 2

state 1

    (0) S' -> S .


state 2

    (1) S -> S2 . TYPE emptymain MAIN ( ) { LINES }
    (4) S2 -> S2 . FUNCTION
    (5) FUNCTION -> . FUNCTYPE ID emptyF1 ( ARGS ) { LINES }
    (6) FUNCTYPE -> . VOIDTYPE
    (7) FUNCTYPE -> . TYPE
    TYPE            shift and go to state 3
    VOIDTYPE        shift and go to state 6

    FUNCTION                       shift and go to state 4
    FUNCTYPE                       shift and go to state 5

state 3

    (1) S -> S2 TYPE . emptymain MAIN ( ) { LINES }
    (7) FUNCTYPE -> TYPE .
    (2) emptymain -> .
    ID              reduce using rule 7 (FUNCTYPE -> TYPE .)
    MAIN            reduce using rule 2 (emptymain -> .)

    emptymain                      shift and go to state 7

state 4

    (4) S2 -> S2 FUNCTION .
    TYPE            reduce using rule 4 (S2 -> S2 FUNCTION .)
    VOIDTYPE        reduce using rule 4 (S2 -> S2 FUNCTION .)


state 5

    (5) FUNCTION -> FUNCTYPE . ID emptyF1 ( ARGS ) { LINES }
    ID              shift and go to state 8


state 6

    (6) FUNCTYPE -> VOIDTYPE .
    ID              reduce using rule 6 (FUNCTYPE -> VOIDTYPE .)


state 7

    (1) S -> S2 TYPE emptymain . MAIN ( ) { LINES }
    MAIN            shift and go to state 9


state 8

    (5) FUNCTION -> FUNCTYPE ID . emptyF1 ( ARGS ) { LINES }
    (12) emptyF1 -> .
    (               reduce using rule 12 (emptyF1 -> .)

    emptyF1                        shift and go to state 10

state 9

    (1) S -> S2 TYPE emptymain MAIN . ( ) { LINES }
    (               shift and go to state 11


state 10

    (5) FUNCTION -> FUNCTYPE ID emptyF1 . ( ARGS ) { LINES }
    (               shift and go to state 12


state 11

    (1) S -> S2 TYPE emptymain MAIN ( . ) { LINES }
    )               shift and go to state 13


state 12

    (5) FUNCTION -> FUNCTYPE ID emptyF1 ( . ARGS ) { LINES }
    (8) ARGS -> .
    (9) ARGS -> . TYPE ARG RARGS
    )               reduce using rule 8 (ARGS -> .)
    TYPE            shift and go to state 15

    ARGS                           shift and go to state 14

state 13

    (1) S -> S2 TYPE emptymain MAIN ( ) . { LINES }
    {               shift and go to state 16


state 14

    (5) FUNCTION -> FUNCTYPE ID emptyF1 ( ARGS . ) { LINES }
    )               shift and go to state 17


state 15

    (9) ARGS -> TYPE . ARG RARGS
    (13) ARG -> . ID
    ID              shift and go to state 19

    ARG                            shift and go to state 18

state 16

    (1) S -> S2 TYPE emptymain MAIN ( ) { . LINES }
    (14) LINES -> .
    (15) LINES -> . LINES LINE ;
    }               reduce using rule 14 (LINES -> .)
    PRINT           reduce using rule 14 (LINES -> .)
    TYPE            reduce using rule 14 (LINES -> .)
    ID              reduce using rule 14 (LINES -> .)
    !               reduce using rule 14 (LINES -> .)
    (               reduce using rule 14 (LINES -> .)
    &               reduce using rule 14 (LINES -> .)
    CHAR            reduce using rule 14 (LINES -> .)
    NUMBERF         reduce using rule 14 (LINES -> .)
    NUMBER          reduce using rule 14 (LINES -> .)

    LINES                          shift and go to state 20

state 17

    (5) FUNCTION -> FUNCTYPE ID emptyF1 ( ARGS ) . { LINES }
    {               shift and go to state 21


state 18

    (9) ARGS -> TYPE ARG . RARGS
    (10) RARGS -> .
    (11) RARGS -> . , TYPE ARG RARGS
    )               reduce using rule 10 (RARGS -> .)
    ,               shift and go to state 23

    RARGS                          shift and go to state 22

state 19

    (13) ARG -> ID .
    ,               reduce using rule 13 (ARG -> ID .)
    )               reduce using rule 13 (ARG -> ID .)


state 20

    (1) S -> S2 TYPE emptymain MAIN ( ) { LINES . }
    (15) LINES -> LINES . LINE ;
    (16) LINE -> . PRINT ( STRING PRINTIDS )
    (17) LINE -> . DECLAR
    (18) LINE -> . INSTR
    (23) DECLAR -> . TYPE POINTERS IDPRIMA
    (21) INSTR -> . OROP
    (22) INSTR -> . ASIG
    (36) OROP -> . ANDOP
    (37) OROP -> . OROP ORSIMB ANDOP
    (35) ASIG -> . ID = INSTR
    (38) ANDOP -> . NOTOP
    (39) ANDOP -> . ANDOP ANDSIMB NOTOP
    (40) NOTOP -> . COMPOP
    (41) NOTOP -> . ! NOTOP
    (42) COMPOP -> . ADDOP
    (43) COMPOP -> . COMPOP COMPSIMB ADDOP
    (44) ADDOP -> . PRODOP
    (45) ADDOP -> . ADDOP - PRODOP
    (46) ADDOP -> . ADDOP + PRODOP
    (47) PRODOP -> . PAROP
    (48) PRODOP -> . PRODOP / PAROP
    (49) PRODOP -> . PRODOP * PAROP
    (50) PAROP -> . VAL
    (51) PAROP -> . ( OROP )
    (52) VAL -> . & ID
    (53) VAL -> . ID
    (54) VAL -> . CHAR
    (55) VAL -> . NUMBERF
    (56) VAL -> . NUMBER
    }               shift and go to state 26
    PRINT           shift and go to state 28
    TYPE            shift and go to state 24
    ID              shift and go to state 34
    !               shift and go to state 37
    (               shift and go to state 25
    &               shift and go to state 42
    CHAR            shift and go to state 43
    NUMBERF         shift and go to state 44
    NUMBER          shift and go to state 45

    LINE                           shift and go to state 27
    DECLAR                         shift and go to state 29
    INSTR                          shift and go to state 30
    OROP                           shift and go to state 31
    ASIG                           shift and go to state 32
    ANDOP                          shift and go to state 33
    NOTOP                          shift and go to state 35
    COMPOP                         shift and go to state 36
    ADDOP                          shift and go to state 38
    PRODOP                         shift and go to state 39
    PAROP                          shift and go to state 40
    VAL                            shift and go to state 41

state 21

    (5) FUNCTION -> FUNCTYPE ID emptyF1 ( ARGS ) { . LINES }
    (14) LINES -> .
    (15) LINES -> . LINES LINE ;
    }               reduce using rule 14 (LINES -> .)
    PRINT           reduce using rule 14 (LINES -> .)
    TYPE            reduce using rule 14 (LINES -> .)
    ID              reduce using rule 14 (LINES -> .)
    !               reduce using rule 14 (LINES -> .)
    (               reduce using rule 14 (LINES -> .)
    &               reduce using rule 14 (LINES -> .)
    CHAR            reduce using rule 14 (LINES -> .)
    NUMBERF         reduce using rule 14 (LINES -> .)
    NUMBER          reduce using rule 14 (LINES -> .)

    LINES                          shift and go to state 46

state 22

    (9) ARGS -> TYPE ARG RARGS .
    )               reduce using rule 9 (ARGS -> TYPE ARG RARGS .)


state 23

    (11) RARGS -> , . TYPE ARG RARGS
    TYPE            shift and go to state 47


state 24

    (23) DECLAR -> TYPE . POINTERS IDPRIMA
    (24) POINTERS -> .
    (25) POINTERS -> . * POINTERS
    ID              reduce using rule 24 (POINTERS -> .)
    *               shift and go to state 49

    POINTERS                       shift and go to state 48

state 25

    (51) PAROP -> ( . OROP )
    (36) OROP -> . ANDOP
    (37) OROP -> . OROP ORSIMB ANDOP
    (38) ANDOP -> . NOTOP
    (39) ANDOP -> . ANDOP ANDSIMB NOTOP
    (40) NOTOP -> . COMPOP
    (41) NOTOP -> . ! NOTOP
    (42) COMPOP -> . ADDOP
    (43) COMPOP -> . COMPOP COMPSIMB ADDOP
    (44) ADDOP -> . PRODOP
    (45) ADDOP -> . ADDOP - PRODOP
    (46) ADDOP -> . ADDOP + PRODOP
    (47) PRODOP -> . PAROP
    (48) PRODOP -> . PRODOP / PAROP
    (49) PRODOP -> . PRODOP * PAROP
    (50) PAROP -> . VAL
    (51) PAROP -> . ( OROP )
    (52) VAL -> . & ID
    (53) VAL -> . ID
    (54) VAL -> . CHAR
    (55) VAL -> . NUMBERF
    (56) VAL -> . NUMBER
    !               shift and go to state 37
    (               shift and go to state 25
    &               shift and go to state 42
    ID              shift and go to state 51
    CHAR            shift and go to state 43
    NUMBERF         shift and go to state 44
    NUMBER          shift and go to state 45

    OROP                           shift and go to state 50
    ANDOP                          shift and go to state 33
    NOTOP                          shift and go to state 35
    COMPOP                         shift and go to state 36
    ADDOP                          shift and go to state 38
    PRODOP                         shift and go to state 39
    PAROP                          shift and go to state 40
    VAL                            shift and go to state 41

state 26

    (1) S -> S2 TYPE emptymain MAIN ( ) { LINES } .
    $end            reduce using rule 1 (S -> S2 TYPE emptymain MAIN ( ) { LINES } .)


state 27

    (15) LINES -> LINES LINE . ;
    ;               shift and go to state 52


state 28

    (16) LINE -> PRINT . ( STRING PRINTIDS )
    (               shift and go to state 53


state 29

    (17) LINE -> DECLAR .
    ;               reduce using rule 17 (LINE -> DECLAR .)


state 30

    (18) LINE -> INSTR .
    ;               reduce using rule 18 (LINE -> INSTR .)


state 31

    (21) INSTR -> OROP .
    (37) OROP -> OROP . ORSIMB ANDOP
    ;               reduce using rule 21 (INSTR -> OROP .)
    ,               reduce using rule 21 (INSTR -> OROP .)
    )               reduce using rule 21 (INSTR -> OROP .)
    ORSIMB          shift and go to state 54


state 32

    (22) INSTR -> ASIG .
    ;               reduce using rule 22 (INSTR -> ASIG .)
    ,               reduce using rule 22 (INSTR -> ASIG .)
    )               reduce using rule 22 (INSTR -> ASIG .)


state 33

    (36) OROP -> ANDOP .
    (39) ANDOP -> ANDOP . ANDSIMB NOTOP
    ORSIMB          reduce using rule 36 (OROP -> ANDOP .)
    ;               reduce using rule 36 (OROP -> ANDOP .)
    )               reduce using rule 36 (OROP -> ANDOP .)
    ,               reduce using rule 36 (OROP -> ANDOP .)
    ANDSIMB         shift and go to state 55


state 34

    (35) ASIG -> ID . = INSTR
    (53) VAL -> ID .
    =               shift and go to state 56
    /               reduce using rule 53 (VAL -> ID .)
    *               reduce using rule 53 (VAL -> ID .)
    -               reduce using rule 53 (VAL -> ID .)
    +               reduce using rule 53 (VAL -> ID .)
    COMPSIMB        reduce using rule 53 (VAL -> ID .)
    ANDSIMB         reduce using rule 53 (VAL -> ID .)
    ORSIMB          reduce using rule 53 (VAL -> ID .)
    ;               reduce using rule 53 (VAL -> ID .)
    ,               reduce using rule 53 (VAL -> ID .)
    )               reduce using rule 53 (VAL -> ID .)


state 35

    (38) ANDOP -> NOTOP .
    ANDSIMB         reduce using rule 38 (ANDOP -> NOTOP .)
    ORSIMB          reduce using rule 38 (ANDOP -> NOTOP .)
    ;               reduce using rule 38 (ANDOP -> NOTOP .)
    )               reduce using rule 38 (ANDOP -> NOTOP .)
    ,               reduce using rule 38 (ANDOP -> NOTOP .)


state 36

    (40) NOTOP -> COMPOP .
    (43) COMPOP -> COMPOP . COMPSIMB ADDOP
    ANDSIMB         reduce using rule 40 (NOTOP -> COMPOP .)
    ORSIMB          reduce using rule 40 (NOTOP -> COMPOP .)
    ;               reduce using rule 40 (NOTOP -> COMPOP .)
    )               reduce using rule 40 (NOTOP -> COMPOP .)
    ,               reduce using rule 40 (NOTOP -> COMPOP .)
    COMPSIMB        shift and go to state 57


state 37

    (41) NOTOP -> ! . NOTOP
    (40) NOTOP -> . COMPOP
    (41) NOTOP -> . ! NOTOP
    (42) COMPOP -> . ADDOP
    (43) COMPOP -> . COMPOP COMPSIMB ADDOP
    (44) ADDOP -> . PRODOP
    (45) ADDOP -> . ADDOP - PRODOP
    (46) ADDOP -> . ADDOP + PRODOP
    (47) PRODOP -> . PAROP
    (48) PRODOP -> . PRODOP / PAROP
    (49) PRODOP -> . PRODOP * PAROP
    (50) PAROP -> . VAL
    (51) PAROP -> . ( OROP )
    (52) VAL -> . & ID
    (53) VAL -> . ID
    (54) VAL -> . CHAR
    (55) VAL -> . NUMBERF
    (56) VAL -> . NUMBER
    !               shift and go to state 37
    (               shift and go to state 25
    &               shift and go to state 42
    ID              shift and go to state 51
    CHAR            shift and go to state 43
    NUMBERF         shift and go to state 44
    NUMBER          shift and go to state 45

    NOTOP                          shift and go to state 58
    COMPOP                         shift and go to state 36
    ADDOP                          shift and go to state 38
    PRODOP                         shift and go to state 39
    PAROP                          shift and go to state 40
    VAL                            shift and go to state 41

state 38

    (42) COMPOP -> ADDOP .
    (45) ADDOP -> ADDOP . - PRODOP
    (46) ADDOP -> ADDOP . + PRODOP
    COMPSIMB        reduce using rule 42 (COMPOP -> ADDOP .)
    ANDSIMB         reduce using rule 42 (COMPOP -> ADDOP .)
    ORSIMB          reduce using rule 42 (COMPOP -> ADDOP .)
    ;               reduce using rule 42 (COMPOP -> ADDOP .)
    )               reduce using rule 42 (COMPOP -> ADDOP .)
    ,               reduce using rule 42 (COMPOP -> ADDOP .)
    -               shift and go to state 59
    +               shift and go to state 60


state 39

    (44) ADDOP -> PRODOP .
    (48) PRODOP -> PRODOP . / PAROP
    (49) PRODOP -> PRODOP . * PAROP
    -               reduce using rule 44 (ADDOP -> PRODOP .)
    +               reduce using rule 44 (ADDOP -> PRODOP .)
    COMPSIMB        reduce using rule 44 (ADDOP -> PRODOP .)
    ANDSIMB         reduce using rule 44 (ADDOP -> PRODOP .)
    ORSIMB          reduce using rule 44 (ADDOP -> PRODOP .)
    ;               reduce using rule 44 (ADDOP -> PRODOP .)
    )               reduce using rule 44 (ADDOP -> PRODOP .)
    ,               reduce using rule 44 (ADDOP -> PRODOP .)
    /               shift and go to state 61
    *               shift and go to state 62


state 40

    (47) PRODOP -> PAROP .
    /               reduce using rule 47 (PRODOP -> PAROP .)
    *               reduce using rule 47 (PRODOP -> PAROP .)
    -               reduce using rule 47 (PRODOP -> PAROP .)
    +               reduce using rule 47 (PRODOP -> PAROP .)
    COMPSIMB        reduce using rule 47 (PRODOP -> PAROP .)
    ANDSIMB         reduce using rule 47 (PRODOP -> PAROP .)
    ORSIMB          reduce using rule 47 (PRODOP -> PAROP .)
    ;               reduce using rule 47 (PRODOP -> PAROP .)
    )               reduce using rule 47 (PRODOP -> PAROP .)
    ,               reduce using rule 47 (PRODOP -> PAROP .)


state 41

    (50) PAROP -> VAL .
    /               reduce using rule 50 (PAROP -> VAL .)
    *               reduce using rule 50 (PAROP -> VAL .)
    -               reduce using rule 50 (PAROP -> VAL .)
    +               reduce using rule 50 (PAROP -> VAL .)
    COMPSIMB        reduce using rule 50 (PAROP -> VAL .)
    ANDSIMB         reduce using rule 50 (PAROP -> VAL .)
    ORSIMB          reduce using rule 50 (PAROP -> VAL .)
    ;               reduce using rule 50 (PAROP -> VAL .)
    )               reduce using rule 50 (PAROP -> VAL .)
    ,               reduce using rule 50 (PAROP -> VAL .)


state 42

    (52) VAL -> & . ID
    ID              shift and go to state 63


state 43

    (54) VAL -> CHAR .
    /               reduce using rule 54 (VAL -> CHAR .)
    *               reduce using rule 54 (VAL -> CHAR .)
    -               reduce using rule 54 (VAL -> CHAR .)
    +               reduce using rule 54 (VAL -> CHAR .)
    COMPSIMB        reduce using rule 54 (VAL -> CHAR .)
    ANDSIMB         reduce using rule 54 (VAL -> CHAR .)
    ORSIMB          reduce using rule 54 (VAL -> CHAR .)
    ;               reduce using rule 54 (VAL -> CHAR .)
    )               reduce using rule 54 (VAL -> CHAR .)
    ,               reduce using rule 54 (VAL -> CHAR .)


state 44

    (55) VAL -> NUMBERF .
    /               reduce using rule 55 (VAL -> NUMBERF .)
    *               reduce using rule 55 (VAL -> NUMBERF .)
    -               reduce using rule 55 (VAL -> NUMBERF .)
    +               reduce using rule 55 (VAL -> NUMBERF .)
    COMPSIMB        reduce using rule 55 (VAL -> NUMBERF .)
    ANDSIMB         reduce using rule 55 (VAL -> NUMBERF .)
    ORSIMB          reduce using rule 55 (VAL -> NUMBERF .)
    ;               reduce using rule 55 (VAL -> NUMBERF .)
    )               reduce using rule 55 (VAL -> NUMBERF .)
    ,               reduce using rule 55 (VAL -> NUMBERF .)


state 45

    (56) VAL -> NUMBER .
    /               reduce using rule 56 (VAL -> NUMBER .)
    *               reduce using rule 56 (VAL -> NUMBER .)
    -               reduce using rule 56 (VAL -> NUMBER .)
    +               reduce using rule 56 (VAL -> NUMBER .)
    COMPSIMB        reduce using rule 56 (VAL -> NUMBER .)
    ANDSIMB         reduce using rule 56 (VAL -> NUMBER .)
    ORSIMB          reduce using rule 56 (VAL -> NUMBER .)
    ;               reduce using rule 56 (VAL -> NUMBER .)
    )               reduce using rule 56 (VAL -> NUMBER .)
    ,               reduce using rule 56 (VAL -> NUMBER .)


state 46

    (5) FUNCTION -> FUNCTYPE ID emptyF1 ( ARGS ) { LINES . }
    (15) LINES -> LINES . LINE ;
    (16) LINE -> . PRINT ( STRING PRINTIDS )
    (17) LINE -> . DECLAR
    (18) LINE -> . INSTR
    (23) DECLAR -> . TYPE POINTERS IDPRIMA
    (21) INSTR -> . OROP
    (22) INSTR -> . ASIG
    (36) OROP -> . ANDOP
    (37) OROP -> . OROP ORSIMB ANDOP
    (35) ASIG -> . ID = INSTR
    (38) ANDOP -> . NOTOP
    (39) ANDOP -> . ANDOP ANDSIMB NOTOP
    (40) NOTOP -> . COMPOP
    (41) NOTOP -> . ! NOTOP
    (42) COMPOP -> . ADDOP
    (43) COMPOP -> . COMPOP COMPSIMB ADDOP
    (44) ADDOP -> . PRODOP
    (45) ADDOP -> . ADDOP - PRODOP
    (46) ADDOP -> . ADDOP + PRODOP
    (47) PRODOP -> . PAROP
    (48) PRODOP -> . PRODOP / PAROP
    (49) PRODOP -> . PRODOP * PAROP
    (50) PAROP -> . VAL
    (51) PAROP -> . ( OROP )
    (52) VAL -> . & ID
    (53) VAL -> . ID
    (54) VAL -> . CHAR
    (55) VAL -> . NUMBERF
    (56) VAL -> . NUMBER
    }               shift and go to state 64
    PRINT           shift and go to state 28
    TYPE            shift and go to state 24
    ID              shift and go to state 34
    !               shift and go to state 37
    (               shift and go to state 25
    &               shift and go to state 42
    CHAR            shift and go to state 43
    NUMBERF         shift and go to state 44
    NUMBER          shift and go to state 45

    LINE                           shift and go to state 27
    DECLAR                         shift and go to state 29
    INSTR                          shift and go to state 30
    OROP                           shift and go to state 31
    ASIG                           shift and go to state 32
    ANDOP                          shift and go to state 33
    NOTOP                          shift and go to state 35
    COMPOP                         shift and go to state 36
    ADDOP                          shift and go to state 38
    PRODOP                         shift and go to state 39
    PAROP                          shift and go to state 40
    VAL                            shift and go to state 41

state 47

    (11) RARGS -> , TYPE . ARG RARGS
    (13) ARG -> . ID
    ID              shift and go to state 19

    ARG                            shift and go to state 65

state 48

    (23) DECLAR -> TYPE POINTERS . IDPRIMA
    (26) IDPRIMA -> . empty ELEM REST
    (33) empty -> .
    ID              reduce using rule 33 (empty -> .)

    IDPRIMA                        shift and go to state 66
    empty                          shift and go to state 67

state 49

    (25) POINTERS -> * . POINTERS
    (24) POINTERS -> .
    (25) POINTERS -> . * POINTERS
    ID              reduce using rule 24 (POINTERS -> .)
    *               shift and go to state 49

    POINTERS                       shift and go to state 68

state 50

    (51) PAROP -> ( OROP . )
    (37) OROP -> OROP . ORSIMB ANDOP
    )               shift and go to state 69
    ORSIMB          shift and go to state 54


state 51

    (53) VAL -> ID .
    /               reduce using rule 53 (VAL -> ID .)
    *               reduce using rule 53 (VAL -> ID .)
    -               reduce using rule 53 (VAL -> ID .)
    +               reduce using rule 53 (VAL -> ID .)
    COMPSIMB        reduce using rule 53 (VAL -> ID .)
    ANDSIMB         reduce using rule 53 (VAL -> ID .)
    )               reduce using rule 53 (VAL -> ID .)
    ORSIMB          reduce using rule 53 (VAL -> ID .)
    ;               reduce using rule 53 (VAL -> ID .)
    ,               reduce using rule 53 (VAL -> ID .)


state 52

    (15) LINES -> LINES LINE ; .
    }               reduce using rule 15 (LINES -> LINES LINE ; .)
    PRINT           reduce using rule 15 (LINES -> LINES LINE ; .)
    TYPE            reduce using rule 15 (LINES -> LINES LINE ; .)
    ID              reduce using rule 15 (LINES -> LINES LINE ; .)
    !               reduce using rule 15 (LINES -> LINES LINE ; .)
    (               reduce using rule 15 (LINES -> LINES LINE ; .)
    &               reduce using rule 15 (LINES -> LINES LINE ; .)
    CHAR            reduce using rule 15 (LINES -> LINES LINE ; .)
    NUMBERF         reduce using rule 15 (LINES -> LINES LINE ; .)
    NUMBER          reduce using rule 15 (LINES -> LINES LINE ; .)


state 53

    (16) LINE -> PRINT ( . STRING PRINTIDS )
    STRING          shift and go to state 70


state 54

    (37) OROP -> OROP ORSIMB . ANDOP
    (38) ANDOP -> . NOTOP
    (39) ANDOP -> . ANDOP ANDSIMB NOTOP
    (40) NOTOP -> . COMPOP
    (41) NOTOP -> . ! NOTOP
    (42) COMPOP -> . ADDOP
    (43) COMPOP -> . COMPOP COMPSIMB ADDOP
    (44) ADDOP -> . PRODOP
    (45) ADDOP -> . ADDOP - PRODOP
    (46) ADDOP -> . ADDOP + PRODOP
    (47) PRODOP -> . PAROP
    (48) PRODOP -> . PRODOP / PAROP
    (49) PRODOP -> . PRODOP * PAROP
    (50) PAROP -> . VAL
    (51) PAROP -> . ( OROP )
    (52) VAL -> . & ID
    (53) VAL -> . ID
    (54) VAL -> . CHAR
    (55) VAL -> . NUMBERF
    (56) VAL -> . NUMBER
    !               shift and go to state 37
    (               shift and go to state 25
    &               shift and go to state 42
    ID              shift and go to state 51
    CHAR            shift and go to state 43
    NUMBERF         shift and go to state 44
    NUMBER          shift and go to state 45

    ANDOP                          shift and go to state 71
    NOTOP                          shift and go to state 35
    COMPOP                         shift and go to state 36
    ADDOP                          shift and go to state 38
    PRODOP                         shift and go to state 39
    PAROP                          shift and go to state 40
    VAL                            shift and go to state 41

state 55

    (39) ANDOP -> ANDOP ANDSIMB . NOTOP
    (40) NOTOP -> . COMPOP
    (41) NOTOP -> . ! NOTOP
    (42) COMPOP -> . ADDOP
    (43) COMPOP -> . COMPOP COMPSIMB ADDOP
    (44) ADDOP -> . PRODOP
    (45) ADDOP -> . ADDOP - PRODOP
    (46) ADDOP -> . ADDOP + PRODOP
    (47) PRODOP -> . PAROP
    (48) PRODOP -> . PRODOP / PAROP
    (49) PRODOP -> . PRODOP * PAROP
    (50) PAROP -> . VAL
    (51) PAROP -> . ( OROP )
    (52) VAL -> . & ID
    (53) VAL -> . ID
    (54) VAL -> . CHAR
    (55) VAL -> . NUMBERF
    (56) VAL -> . NUMBER
    !               shift and go to state 37
    (               shift and go to state 25
    &               shift and go to state 42
    ID              shift and go to state 51
    CHAR            shift and go to state 43
    NUMBERF         shift and go to state 44
    NUMBER          shift and go to state 45

    NOTOP                          shift and go to state 72
    COMPOP                         shift and go to state 36
    ADDOP                          shift and go to state 38
    PRODOP                         shift and go to state 39
    PAROP                          shift and go to state 40
    VAL                            shift and go to state 41

state 56

    (35) ASIG -> ID = . INSTR
    (21) INSTR -> . OROP
    (22) INSTR -> . ASIG
    (36) OROP -> . ANDOP
    (37) OROP -> . OROP ORSIMB ANDOP
    (35) ASIG -> . ID = INSTR
    (38) ANDOP -> . NOTOP
    (39) ANDOP -> . ANDOP ANDSIMB NOTOP
    (40) NOTOP -> . COMPOP
    (41) NOTOP -> . ! NOTOP
    (42) COMPOP -> . ADDOP
    (43) COMPOP -> . COMPOP COMPSIMB ADDOP
    (44) ADDOP -> . PRODOP
    (45) ADDOP -> . ADDOP - PRODOP
    (46) ADDOP -> . ADDOP + PRODOP
    (47) PRODOP -> . PAROP
    (48) PRODOP -> . PRODOP / PAROP
    (49) PRODOP -> . PRODOP * PAROP
    (50) PAROP -> . VAL
    (51) PAROP -> . ( OROP )
    (52) VAL -> . & ID
    (53) VAL -> . ID
    (54) VAL -> . CHAR
    (55) VAL -> . NUMBERF
    (56) VAL -> . NUMBER
    ID              shift and go to state 34
    !               shift and go to state 37
    (               shift and go to state 25
    &               shift and go to state 42
    CHAR            shift and go to state 43
    NUMBERF         shift and go to state 44
    NUMBER          shift and go to state 45

    INSTR                          shift and go to state 73
    OROP                           shift and go to state 31
    ASIG                           shift and go to state 32
    ANDOP                          shift and go to state 33
    NOTOP                          shift and go to state 35
    COMPOP                         shift and go to state 36
    ADDOP                          shift and go to state 38
    PRODOP                         shift and go to state 39
    PAROP                          shift and go to state 40
    VAL                            shift and go to state 41

state 57

    (43) COMPOP -> COMPOP COMPSIMB . ADDOP
    (44) ADDOP -> . PRODOP
    (45) ADDOP -> . ADDOP - PRODOP
    (46) ADDOP -> . ADDOP + PRODOP
    (47) PRODOP -> . PAROP
    (48) PRODOP -> . PRODOP / PAROP
    (49) PRODOP -> . PRODOP * PAROP
    (50) PAROP -> . VAL
    (51) PAROP -> . ( OROP )
    (52) VAL -> . & ID
    (53) VAL -> . ID
    (54) VAL -> . CHAR
    (55) VAL -> . NUMBERF
    (56) VAL -> . NUMBER
    (               shift and go to state 25
    &               shift and go to state 42
    ID              shift and go to state 51
    CHAR            shift and go to state 43
    NUMBERF         shift and go to state 44
    NUMBER          shift and go to state 45

    ADDOP                          shift and go to state 74
    PRODOP                         shift and go to state 39
    PAROP                          shift and go to state 40
    VAL                            shift and go to state 41

state 58

    (41) NOTOP -> ! NOTOP .
    ANDSIMB         reduce using rule 41 (NOTOP -> ! NOTOP .)
    ORSIMB          reduce using rule 41 (NOTOP -> ! NOTOP .)
    ;               reduce using rule 41 (NOTOP -> ! NOTOP .)
    )               reduce using rule 41 (NOTOP -> ! NOTOP .)
    ,               reduce using rule 41 (NOTOP -> ! NOTOP .)


state 59

    (45) ADDOP -> ADDOP - . PRODOP
    (47) PRODOP -> . PAROP
    (48) PRODOP -> . PRODOP / PAROP
    (49) PRODOP -> . PRODOP * PAROP
    (50) PAROP -> . VAL
    (51) PAROP -> . ( OROP )
    (52) VAL -> . & ID
    (53) VAL -> . ID
    (54) VAL -> . CHAR
    (55) VAL -> . NUMBERF
    (56) VAL -> . NUMBER
    (               shift and go to state 25
    &               shift and go to state 42
    ID              shift and go to state 51
    CHAR            shift and go to state 43
    NUMBERF         shift and go to state 44
    NUMBER          shift and go to state 45

    PRODOP                         shift and go to state 75
    PAROP                          shift and go to state 40
    VAL                            shift and go to state 41

state 60

    (46) ADDOP -> ADDOP + . PRODOP
    (47) PRODOP -> . PAROP
    (48) PRODOP -> . PRODOP / PAROP
    (49) PRODOP -> . PRODOP * PAROP
    (50) PAROP -> . VAL
    (51) PAROP -> . ( OROP )
    (52) VAL -> . & ID
    (53) VAL -> . ID
    (54) VAL -> . CHAR
    (55) VAL -> . NUMBERF
    (56) VAL -> . NUMBER
    (               shift and go to state 25
    &               shift and go to state 42
    ID              shift and go to state 51
    CHAR            shift and go to state 43
    NUMBERF         shift and go to state 44
    NUMBER          shift and go to state 45

    PRODOP                         shift and go to state 76
    PAROP                          shift and go to state 40
    VAL                            shift and go to state 41

state 61

    (48) PRODOP -> PRODOP / . PAROP
    (50) PAROP -> . VAL
    (51) PAROP -> . ( OROP )
    (52) VAL -> . & ID
    (53) VAL -> . ID
    (54) VAL -> . CHAR
    (55) VAL -> . NUMBERF
    (56) VAL -> . NUMBER
    (               shift and go to state 25
    &               shift and go to state 42
    ID              shift and go to state 51
    CHAR            shift and go to state 43
    NUMBERF         shift and go to state 44
    NUMBER          shift and go to state 45

    PAROP                          shift and go to state 77
    VAL                            shift and go to state 41

state 62

    (49) PRODOP -> PRODOP * . PAROP
    (50) PAROP -> . VAL
    (51) PAROP -> . ( OROP )
    (52) VAL -> . & ID
    (53) VAL -> . ID
    (54) VAL -> . CHAR
    (55) VAL -> . NUMBERF
    (56) VAL -> . NUMBER
    (               shift and go to state 25
    &               shift and go to state 42
    ID              shift and go to state 51
    CHAR            shift and go to state 43
    NUMBERF         shift and go to state 44
    NUMBER          shift and go to state 45

    PAROP                          shift and go to state 78
    VAL                            shift and go to state 41

state 63

    (52) VAL -> & ID .
    /               reduce using rule 52 (VAL -> & ID .)
    *               reduce using rule 52 (VAL -> & ID .)
    -               reduce using rule 52 (VAL -> & ID .)
    +               reduce using rule 52 (VAL -> & ID .)
    COMPSIMB        reduce using rule 52 (VAL -> & ID .)
    ANDSIMB         reduce using rule 52 (VAL -> & ID .)
    ORSIMB          reduce using rule 52 (VAL -> & ID .)
    ;               reduce using rule 52 (VAL -> & ID .)
    )               reduce using rule 52 (VAL -> & ID .)
    ,               reduce using rule 52 (VAL -> & ID .)


state 64

    (5) FUNCTION -> FUNCTYPE ID emptyF1 ( ARGS ) { LINES } .
    TYPE            reduce using rule 5 (FUNCTION -> FUNCTYPE ID emptyF1 ( ARGS ) { LINES } .)
    VOIDTYPE        reduce using rule 5 (FUNCTION -> FUNCTYPE ID emptyF1 ( ARGS ) { LINES } .)


state 65

    (11) RARGS -> , TYPE ARG . RARGS
    (10) RARGS -> .
    (11) RARGS -> . , TYPE ARG RARGS
    )               reduce using rule 10 (RARGS -> .)
    ,               shift and go to state 23

    RARGS                          shift and go to state 79

state 66

    (23) DECLAR -> TYPE POINTERS IDPRIMA .
    ;               reduce using rule 23 (DECLAR -> TYPE POINTERS IDPRIMA .)


state 67

    (26) IDPRIMA -> empty . ELEM REST
    (29) ELEM -> . ID = INSTR
    (30) ELEM -> . ID ARRAY
    ID              shift and go to state 81

    ELEM                           shift and go to state 80

state 68

    (25) POINTERS -> * POINTERS .
    ID              reduce using rule 25 (POINTERS -> * POINTERS .)


state 69

    (51) PAROP -> ( OROP ) .
    /               reduce using rule 51 (PAROP -> ( OROP ) .)
    *               reduce using rule 51 (PAROP -> ( OROP ) .)
    -               reduce using rule 51 (PAROP -> ( OROP ) .)
    +               reduce using rule 51 (PAROP -> ( OROP ) .)
    COMPSIMB        reduce using rule 51 (PAROP -> ( OROP ) .)
    ANDSIMB         reduce using rule 51 (PAROP -> ( OROP ) .)
    ORSIMB          reduce using rule 51 (PAROP -> ( OROP ) .)
    ;               reduce using rule 51 (PAROP -> ( OROP ) .)
    )               reduce using rule 51 (PAROP -> ( OROP ) .)
    ,               reduce using rule 51 (PAROP -> ( OROP ) .)


state 70

    (16) LINE -> PRINT ( STRING . PRINTIDS )
    (19) PRINTIDS -> .
    (20) PRINTIDS -> . , INSTR PRINTIDS
    )               reduce using rule 19 (PRINTIDS -> .)
    ,               shift and go to state 83

    PRINTIDS                       shift and go to state 82

state 71

    (37) OROP -> OROP ORSIMB ANDOP .
    (39) ANDOP -> ANDOP . ANDSIMB NOTOP
    ORSIMB          reduce using rule 37 (OROP -> OROP ORSIMB ANDOP .)
    ;               reduce using rule 37 (OROP -> OROP ORSIMB ANDOP .)
    )               reduce using rule 37 (OROP -> OROP ORSIMB ANDOP .)
    ,               reduce using rule 37 (OROP -> OROP ORSIMB ANDOP .)
    ANDSIMB         shift and go to state 55


state 72

    (39) ANDOP -> ANDOP ANDSIMB NOTOP .
    ANDSIMB         reduce using rule 39 (ANDOP -> ANDOP ANDSIMB NOTOP .)
    ORSIMB          reduce using rule 39 (ANDOP -> ANDOP ANDSIMB NOTOP .)
    ;               reduce using rule 39 (ANDOP -> ANDOP ANDSIMB NOTOP .)
    )               reduce using rule 39 (ANDOP -> ANDOP ANDSIMB NOTOP .)
    ,               reduce using rule 39 (ANDOP -> ANDOP ANDSIMB NOTOP .)


state 73

    (35) ASIG -> ID = INSTR .
    ;               reduce using rule 35 (ASIG -> ID = INSTR .)
    ,               reduce using rule 35 (ASIG -> ID = INSTR .)
    )               reduce using rule 35 (ASIG -> ID = INSTR .)


state 74

    (43) COMPOP -> COMPOP COMPSIMB ADDOP .
    (45) ADDOP -> ADDOP . - PRODOP
    (46) ADDOP -> ADDOP . + PRODOP
    COMPSIMB        reduce using rule 43 (COMPOP -> COMPOP COMPSIMB ADDOP .)
    ANDSIMB         reduce using rule 43 (COMPOP -> COMPOP COMPSIMB ADDOP .)
    ORSIMB          reduce using rule 43 (COMPOP -> COMPOP COMPSIMB ADDOP .)
    ;               reduce using rule 43 (COMPOP -> COMPOP COMPSIMB ADDOP .)
    )               reduce using rule 43 (COMPOP -> COMPOP COMPSIMB ADDOP .)
    ,               reduce using rule 43 (COMPOP -> COMPOP COMPSIMB ADDOP .)
    -               shift and go to state 59
    +               shift and go to state 60


state 75

    (45) ADDOP -> ADDOP - PRODOP .
    (48) PRODOP -> PRODOP . / PAROP
    (49) PRODOP -> PRODOP . * PAROP
    -               reduce using rule 45 (ADDOP -> ADDOP - PRODOP .)
    +               reduce using rule 45 (ADDOP -> ADDOP - PRODOP .)
    COMPSIMB        reduce using rule 45 (ADDOP -> ADDOP - PRODOP .)
    ANDSIMB         reduce using rule 45 (ADDOP -> ADDOP - PRODOP .)
    ORSIMB          reduce using rule 45 (ADDOP -> ADDOP - PRODOP .)
    ;               reduce using rule 45 (ADDOP -> ADDOP - PRODOP .)
    )               reduce using rule 45 (ADDOP -> ADDOP - PRODOP .)
    ,               reduce using rule 45 (ADDOP -> ADDOP - PRODOP .)
    /               shift and go to state 61
    *               shift and go to state 62


state 76

    (46) ADDOP -> ADDOP + PRODOP .
    (48) PRODOP -> PRODOP . / PAROP
    (49) PRODOP -> PRODOP . * PAROP
    -               reduce using rule 46 (ADDOP -> ADDOP + PRODOP .)
    +               reduce using rule 46 (ADDOP -> ADDOP + PRODOP .)
    COMPSIMB        reduce using rule 46 (ADDOP -> ADDOP + PRODOP .)
    ANDSIMB         reduce using rule 46 (ADDOP -> ADDOP + PRODOP .)
    ORSIMB          reduce using rule 46 (ADDOP -> ADDOP + PRODOP .)
    ;               reduce using rule 46 (ADDOP -> ADDOP + PRODOP .)
    )               reduce using rule 46 (ADDOP -> ADDOP + PRODOP .)
    ,               reduce using rule 46 (ADDOP -> ADDOP + PRODOP .)
    /               shift and go to state 61
    *               shift and go to state 62


state 77

    (48) PRODOP -> PRODOP / PAROP .
    /               reduce using rule 48 (PRODOP -> PRODOP / PAROP .)
    *               reduce using rule 48 (PRODOP -> PRODOP / PAROP .)
    -               reduce using rule 48 (PRODOP -> PRODOP / PAROP .)
    +               reduce using rule 48 (PRODOP -> PRODOP / PAROP .)
    COMPSIMB        reduce using rule 48 (PRODOP -> PRODOP / PAROP .)
    ANDSIMB         reduce using rule 48 (PRODOP -> PRODOP / PAROP .)
    ORSIMB          reduce using rule 48 (PRODOP -> PRODOP / PAROP .)
    ;               reduce using rule 48 (PRODOP -> PRODOP / PAROP .)
    )               reduce using rule 48 (PRODOP -> PRODOP / PAROP .)
    ,               reduce using rule 48 (PRODOP -> PRODOP / PAROP .)


state 78

    (49) PRODOP -> PRODOP * PAROP .
    /               reduce using rule 49 (PRODOP -> PRODOP * PAROP .)
    *               reduce using rule 49 (PRODOP -> PRODOP * PAROP .)
    -               reduce using rule 49 (PRODOP -> PRODOP * PAROP .)
    +               reduce using rule 49 (PRODOP -> PRODOP * PAROP .)
    COMPSIMB        reduce using rule 49 (PRODOP -> PRODOP * PAROP .)
    ANDSIMB         reduce using rule 49 (PRODOP -> PRODOP * PAROP .)
    ORSIMB          reduce using rule 49 (PRODOP -> PRODOP * PAROP .)
    ;               reduce using rule 49 (PRODOP -> PRODOP * PAROP .)
    )               reduce using rule 49 (PRODOP -> PRODOP * PAROP .)
    ,               reduce using rule 49 (PRODOP -> PRODOP * PAROP .)


state 79

    (11) RARGS -> , TYPE ARG RARGS .
    )               reduce using rule 11 (RARGS -> , TYPE ARG RARGS .)


state 80

    (26) IDPRIMA -> empty ELEM . REST
    (27) REST -> .
    (28) REST -> . , empty2 ELEM REST
    ;               reduce using rule 27 (REST -> .)
    ,               shift and go to state 85

    REST                           shift and go to state 84

state 81

    (29) ELEM -> ID . = INSTR
    (30) ELEM -> ID . ARRAY
    (31) ARRAY -> .
    (32) ARRAY -> . [ NUMBER ] ARRAY
    =               shift and go to state 86
    ,               reduce using rule 31 (ARRAY -> .)
    ;               reduce using rule 31 (ARRAY -> .)
    [               shift and go to state 88

    ARRAY                          shift and go to state 87

state 82

    (16) LINE -> PRINT ( STRING PRINTIDS . )
    )               shift and go to state 89


state 83

    (20) PRINTIDS -> , . INSTR PRINTIDS
    (21) INSTR -> . OROP
    (22) INSTR -> . ASIG
    (36) OROP -> . ANDOP
    (37) OROP -> . OROP ORSIMB ANDOP
    (35) ASIG -> . ID = INSTR
    (38) ANDOP -> . NOTOP
    (39) ANDOP -> . ANDOP ANDSIMB NOTOP
    (40) NOTOP -> . COMPOP
    (41) NOTOP -> . ! NOTOP
    (42) COMPOP -> . ADDOP
    (43) COMPOP -> . COMPOP COMPSIMB ADDOP
    (44) ADDOP -> . PRODOP
    (45) ADDOP -> . ADDOP - PRODOP
    (46) ADDOP -> . ADDOP + PRODOP
    (47) PRODOP -> . PAROP
    (48) PRODOP -> . PRODOP / PAROP
    (49) PRODOP -> . PRODOP * PAROP
    (50) PAROP -> . VAL
    (51) PAROP -> . ( OROP )
    (52) VAL -> . & ID
    (53) VAL -> . ID
    (54) VAL -> . CHAR
    (55) VAL -> . NUMBERF
    (56) VAL -> . NUMBER
    ID              shift and go to state 34
    !               shift and go to state 37
    (               shift and go to state 25
    &               shift and go to state 42
    CHAR            shift and go to state 43
    NUMBERF         shift and go to state 44
    NUMBER          shift and go to state 45

    INSTR                          shift and go to state 90
    OROP                           shift and go to state 31
    ASIG                           shift and go to state 32
    ANDOP                          shift and go to state 33
    NOTOP                          shift and go to state 35
    COMPOP                         shift and go to state 36
    ADDOP                          shift and go to state 38
    PRODOP                         shift and go to state 39
    PAROP                          shift and go to state 40
    VAL                            shift and go to state 41

state 84

    (26) IDPRIMA -> empty ELEM REST .
    ;               reduce using rule 26 (IDPRIMA -> empty ELEM REST .)


state 85

    (28) REST -> , . empty2 ELEM REST
    (34) empty2 -> .
    ID              reduce using rule 34 (empty2 -> .)

    empty2                         shift and go to state 91

state 86

    (29) ELEM -> ID = . INSTR
    (21) INSTR -> . OROP
    (22) INSTR -> . ASIG
    (36) OROP -> . ANDOP
    (37) OROP -> . OROP ORSIMB ANDOP
    (35) ASIG -> . ID = INSTR
    (38) ANDOP -> . NOTOP
    (39) ANDOP -> . ANDOP ANDSIMB NOTOP
    (40) NOTOP -> . COMPOP
    (41) NOTOP -> . ! NOTOP
    (42) COMPOP -> . ADDOP
    (43) COMPOP -> . COMPOP COMPSIMB ADDOP
    (44) ADDOP -> . PRODOP
    (45) ADDOP -> . ADDOP - PRODOP
    (46) ADDOP -> . ADDOP + PRODOP
    (47) PRODOP -> . PAROP
    (48) PRODOP -> . PRODOP / PAROP
    (49) PRODOP -> . PRODOP * PAROP
    (50) PAROP -> . VAL
    (51) PAROP -> . ( OROP )
    (52) VAL -> . & ID
    (53) VAL -> . ID
    (54) VAL -> . CHAR
    (55) VAL -> . NUMBERF
    (56) VAL -> . NUMBER
    ID              shift and go to state 34
    !               shift and go to state 37
    (               shift and go to state 25
    &               shift and go to state 42
    CHAR            shift and go to state 43
    NUMBERF         shift and go to state 44
    NUMBER          shift and go to state 45

    INSTR                          shift and go to state 92
    OROP                           shift and go to state 31
    ASIG                           shift and go to state 32
    ANDOP                          shift and go to state 33
    NOTOP                          shift and go to state 35
    COMPOP                         shift and go to state 36
    ADDOP                          shift and go to state 38
    PRODOP                         shift and go to state 39
    PAROP                          shift and go to state 40
    VAL                            shift and go to state 41

state 87

    (30) ELEM -> ID ARRAY .
    ,               reduce using rule 30 (ELEM -> ID ARRAY .)
    ;               reduce using rule 30 (ELEM -> ID ARRAY .)


state 88

    (32) ARRAY -> [ . NUMBER ] ARRAY
    NUMBER          shift and go to state 93


state 89

    (16) LINE -> PRINT ( STRING PRINTIDS ) .
    ;               reduce using rule 16 (LINE -> PRINT ( STRING PRINTIDS ) .)


state 90

    (20) PRINTIDS -> , INSTR . PRINTIDS
    (19) PRINTIDS -> .
    (20) PRINTIDS -> . , INSTR PRINTIDS
    )               reduce using rule 19 (PRINTIDS -> .)
    ,               shift and go to state 83

    PRINTIDS                       shift and go to state 94

state 91

    (28) REST -> , empty2 . ELEM REST
    (29) ELEM -> . ID = INSTR
    (30) ELEM -> . ID ARRAY
    ID              shift and go to state 81

    ELEM                           shift and go to state 95

state 92

    (29) ELEM -> ID = INSTR .
    ,               reduce using rule 29 (ELEM -> ID = INSTR .)
    ;               reduce using rule 29 (ELEM -> ID = INSTR .)


state 93

    (32) ARRAY -> [ NUMBER . ] ARRAY
    ]               shift and go to state 96


state 94

    (20) PRINTIDS -> , INSTR PRINTIDS .
    )               reduce using rule 20 (PRINTIDS -> , INSTR PRINTIDS .)


state 95

    (28) REST -> , empty2 ELEM . REST
    (27) REST -> .
    (28) REST -> . , empty2 ELEM REST
    ;               reduce using rule 27 (REST -> .)
    ,               shift and go to state 85

    REST                           shift and go to state 97

state 96

    (32) ARRAY -> [ NUMBER ] . ARRAY
    (31) ARRAY -> .
    (32) ARRAY -> . [ NUMBER ] ARRAY
    ,               reduce using rule 31 (ARRAY -> .)
    ;               reduce using rule 31 (ARRAY -> .)
    [               shift and go to state 88

    ARRAY                          shift and go to state 98

state 97

    (28) REST -> , empty2 ELEM REST .
    ;               reduce using rule 28 (REST -> , empty2 ELEM REST .)


state 98

    (32) ARRAY -> [ NUMBER ] ARRAY .
    ,               reduce using rule 32 (ARRAY -> [ NUMBER ] ARRAY .)
    ;               reduce using rule 32 (ARRAY -> [ NUMBER ] ARRAY .)
