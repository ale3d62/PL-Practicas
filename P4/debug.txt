Grammar:

Rule 0     S' -> S
Rule 1     S -> S2 TYPE emptymain MAIN ( ) { LINES }
Rule 2     emptymain -> <empty>
Rule 3     S2 -> <empty>
Rule 4     S2 -> S2 FUNCTION
Rule 5     FUNCTION -> FUNCTYPE ID emptyF1 ( ARGS ) { LINES }
Rule 6     FUNCTYPE -> VOIDTYPE
Rule 7     FUNCTYPE -> TYPE
Rule 8     ARGS -> <empty>
Rule 9     ARGS -> TYPE ARG RARGS
Rule 10    RARGS -> <empty>
Rule 11    RARGS -> , TYPE ARG RARGS
Rule 12    emptyF1 -> <empty>
Rule 13    ARG -> ID
Rule 14    LINES -> <empty>
Rule 15    LINES -> LINES LINE ;
Rule 16    LINE -> PRINT ( STRING PRINTIDS )
Rule 17    LINE -> SCANF ( STRING SCANIDS )
Rule 18    LINE -> DECLAR
Rule 19    LINE -> INSTR
Rule 20    SCANIDS -> <empty>
Rule 21    SCANIDS -> , & ID SCANIDS
Rule 22    PRINTIDS -> <empty>
Rule 23    PRINTIDS -> , INSTR PRINTIDS
Rule 24    INSTR -> OROP
Rule 25    INSTR -> ASIG
Rule 26    DECLAR -> TYPE POINTERS IDPRIMA
Rule 27    POINTERS -> <empty>
Rule 28    POINTERS -> * POINTERS
Rule 29    IDPRIMA -> empty ELEM REST
Rule 30    REST -> <empty>
Rule 31    REST -> , empty2 ELEM REST
Rule 32    ELEM -> ID = INSTR
Rule 33    ELEM -> ID ARRAY
Rule 34    ARRAY -> <empty>
Rule 35    ARRAY -> [ NUMBER ] ARRAY
Rule 36    empty -> <empty>
Rule 37    empty2 -> <empty>
Rule 38    ASIG -> ID = INSTR
Rule 39    OROP -> ANDOP
Rule 40    OROP -> OROP ORSIMB ANDOP
Rule 41    ANDOP -> NOTOP
Rule 42    ANDOP -> ANDOP ANDSIMB NOTOP
Rule 43    NOTOP -> COMPOP
Rule 44    NOTOP -> ! NOTOP
Rule 45    COMPOP -> ADDOP
Rule 46    COMPOP -> COMPOP COMPSIMB ADDOP
Rule 47    ADDOP -> PRODOP
Rule 48    ADDOP -> ADDOP - PRODOP
Rule 49    ADDOP -> ADDOP + PRODOP
Rule 50    PRODOP -> PAROP
Rule 51    PRODOP -> PRODOP / PAROP
Rule 52    PRODOP -> PRODOP * PAROP
Rule 53    PAROP -> VAL
Rule 54    PAROP -> ( OROP )
Rule 55    VAL -> & ID
Rule 56    VAL -> ID
Rule 57    VAL -> CHAR
Rule 58    VAL -> NUMBERF
Rule 59    VAL -> NUMBER

Terminals, with rules where they appear:

!                    : 44
&                    : 21 55
(                    : 1 5 16 17 54
)                    : 1 5 16 17 54
*                    : 28 52
+                    : 49
,                    : 11 21 23 31
-                    : 48
/                    : 51
;                    : 15
=                    : 32 38
ANDSIMB              : 42
CHAR                 : 57
COMPSIMB             : 46
ID                   : 5 13 21 32 33 38 55 56
MAIN                 : 1
NUMBER               : 35 59
NUMBERF              : 58
ORSIMB               : 40
PRINT                : 16
SCANF                : 17
STRING               : 16 17
TYPE                 : 1 7 9 11 26
VOIDTYPE             : 6
[                    : 35
]                    : 35
error                : 
{                    : 1 5
}                    : 1 5

Nonterminals, with rules where they appear:

ADDOP                : 45 46 48 49
ANDOP                : 39 40 42
ARG                  : 9 11
ARGS                 : 5
ARRAY                : 33 35
ASIG                 : 25
COMPOP               : 43 46
DECLAR               : 18
ELEM                 : 29 31
FUNCTION             : 4
FUNCTYPE             : 5
IDPRIMA              : 26
INSTR                : 19 23 32 38
LINE                 : 15
LINES                : 1 5 15
NOTOP                : 41 42 44
OROP                 : 24 40 54
PAROP                : 50 51 52
POINTERS             : 26 28
PRINTIDS             : 16 23
PRODOP               : 47 48 49 51 52
RARGS                : 9 11
REST                 : 29 31
S                    : 0
S2                   : 1 4
SCANIDS              : 17 21
VAL                  : 53
empty                : 29
empty2               : 31
emptyF1              : 5
emptymain            : 1


state 0

    (0) S' -> . S
    (1) S -> . S2 TYPE emptymain MAIN ( ) { LINES }
    (3) S2 -> .
    (4) S2 -> . S2 FUNCTION
    TYPE            reduce using rule 3 (S2 -> .)
    VOIDTYPE        reduce using rule 3 (S2 -> .)

    S                              shift and go to state 1
    S2                             shift and go to state 2

state 1

    (0) S' -> S .


state 2

    (1) S -> S2 . TYPE emptymain MAIN ( ) { LINES }
    (4) S2 -> S2 . FUNCTION
    (5) FUNCTION -> . FUNCTYPE ID emptyF1 ( ARGS ) { LINES }
    (6) FUNCTYPE -> . VOIDTYPE
    (7) FUNCTYPE -> . TYPE
    TYPE            shift and go to state 3
    VOIDTYPE        shift and go to state 6

    FUNCTION                       shift and go to state 4
    FUNCTYPE                       shift and go to state 5

state 3

    (1) S -> S2 TYPE . emptymain MAIN ( ) { LINES }
    (7) FUNCTYPE -> TYPE .
    (2) emptymain -> .
    ID              reduce using rule 7 (FUNCTYPE -> TYPE .)
    MAIN            reduce using rule 2 (emptymain -> .)

    emptymain                      shift and go to state 7

state 4

    (4) S2 -> S2 FUNCTION .
    TYPE            reduce using rule 4 (S2 -> S2 FUNCTION .)
    VOIDTYPE        reduce using rule 4 (S2 -> S2 FUNCTION .)


state 5

    (5) FUNCTION -> FUNCTYPE . ID emptyF1 ( ARGS ) { LINES }
    ID              shift and go to state 8


state 6

    (6) FUNCTYPE -> VOIDTYPE .
    ID              reduce using rule 6 (FUNCTYPE -> VOIDTYPE .)


state 7

    (1) S -> S2 TYPE emptymain . MAIN ( ) { LINES }
    MAIN            shift and go to state 9


state 8

    (5) FUNCTION -> FUNCTYPE ID . emptyF1 ( ARGS ) { LINES }
    (12) emptyF1 -> .
    (               reduce using rule 12 (emptyF1 -> .)

    emptyF1                        shift and go to state 10

state 9

    (1) S -> S2 TYPE emptymain MAIN . ( ) { LINES }
    (               shift and go to state 11


state 10

    (5) FUNCTION -> FUNCTYPE ID emptyF1 . ( ARGS ) { LINES }
    (               shift and go to state 12


state 11

    (1) S -> S2 TYPE emptymain MAIN ( . ) { LINES }
    )               shift and go to state 13


state 12

    (5) FUNCTION -> FUNCTYPE ID emptyF1 ( . ARGS ) { LINES }
    (8) ARGS -> .
    (9) ARGS -> . TYPE ARG RARGS
    )               reduce using rule 8 (ARGS -> .)
    TYPE            shift and go to state 15

    ARGS                           shift and go to state 14

state 13

    (1) S -> S2 TYPE emptymain MAIN ( ) . { LINES }
    {               shift and go to state 16


state 14

    (5) FUNCTION -> FUNCTYPE ID emptyF1 ( ARGS . ) { LINES }
    )               shift and go to state 17


state 15

    (9) ARGS -> TYPE . ARG RARGS
    (13) ARG -> . ID
    ID              shift and go to state 19

    ARG                            shift and go to state 18

state 16

    (1) S -> S2 TYPE emptymain MAIN ( ) { . LINES }
    (14) LINES -> .
    (15) LINES -> . LINES LINE ;
    }               reduce using rule 14 (LINES -> .)
    PRINT           reduce using rule 14 (LINES -> .)
    SCANF           reduce using rule 14 (LINES -> .)
    TYPE            reduce using rule 14 (LINES -> .)
    ID              reduce using rule 14 (LINES -> .)
    !               reduce using rule 14 (LINES -> .)
    (               reduce using rule 14 (LINES -> .)
    &               reduce using rule 14 (LINES -> .)
    CHAR            reduce using rule 14 (LINES -> .)
    NUMBERF         reduce using rule 14 (LINES -> .)
    NUMBER          reduce using rule 14 (LINES -> .)

    LINES                          shift and go to state 20

state 17

    (5) FUNCTION -> FUNCTYPE ID emptyF1 ( ARGS ) . { LINES }
    {               shift and go to state 21


state 18

    (9) ARGS -> TYPE ARG . RARGS
    (10) RARGS -> .
    (11) RARGS -> . , TYPE ARG RARGS
    )               reduce using rule 10 (RARGS -> .)
    ,               shift and go to state 23

    RARGS                          shift and go to state 22

state 19

    (13) ARG -> ID .
    ,               reduce using rule 13 (ARG -> ID .)
    )               reduce using rule 13 (ARG -> ID .)


state 20

    (1) S -> S2 TYPE emptymain MAIN ( ) { LINES . }
    (15) LINES -> LINES . LINE ;
    (16) LINE -> . PRINT ( STRING PRINTIDS )
    (17) LINE -> . SCANF ( STRING SCANIDS )
    (18) LINE -> . DECLAR
    (19) LINE -> . INSTR
    (26) DECLAR -> . TYPE POINTERS IDPRIMA
    (24) INSTR -> . OROP
    (25) INSTR -> . ASIG
    (39) OROP -> . ANDOP
    (40) OROP -> . OROP ORSIMB ANDOP
    (38) ASIG -> . ID = INSTR
    (41) ANDOP -> . NOTOP
    (42) ANDOP -> . ANDOP ANDSIMB NOTOP
    (43) NOTOP -> . COMPOP
    (44) NOTOP -> . ! NOTOP
    (45) COMPOP -> . ADDOP
    (46) COMPOP -> . COMPOP COMPSIMB ADDOP
    (47) ADDOP -> . PRODOP
    (48) ADDOP -> . ADDOP - PRODOP
    (49) ADDOP -> . ADDOP + PRODOP
    (50) PRODOP -> . PAROP
    (51) PRODOP -> . PRODOP / PAROP
    (52) PRODOP -> . PRODOP * PAROP
    (53) PAROP -> . VAL
    (54) PAROP -> . ( OROP )
    (55) VAL -> . & ID
    (56) VAL -> . ID
    (57) VAL -> . CHAR
    (58) VAL -> . NUMBERF
    (59) VAL -> . NUMBER
    }               shift and go to state 26
    PRINT           shift and go to state 28
    SCANF           shift and go to state 29
    TYPE            shift and go to state 24
    ID              shift and go to state 35
    !               shift and go to state 38
    (               shift and go to state 25
    &               shift and go to state 43
    CHAR            shift and go to state 44
    NUMBERF         shift and go to state 45
    NUMBER          shift and go to state 46

    LINE                           shift and go to state 27
    DECLAR                         shift and go to state 30
    INSTR                          shift and go to state 31
    OROP                           shift and go to state 32
    ASIG                           shift and go to state 33
    ANDOP                          shift and go to state 34
    NOTOP                          shift and go to state 36
    COMPOP                         shift and go to state 37
    ADDOP                          shift and go to state 39
    PRODOP                         shift and go to state 40
    PAROP                          shift and go to state 41
    VAL                            shift and go to state 42

state 21

    (5) FUNCTION -> FUNCTYPE ID emptyF1 ( ARGS ) { . LINES }
    (14) LINES -> .
    (15) LINES -> . LINES LINE ;
    }               reduce using rule 14 (LINES -> .)
    PRINT           reduce using rule 14 (LINES -> .)
    SCANF           reduce using rule 14 (LINES -> .)
    TYPE            reduce using rule 14 (LINES -> .)
    ID              reduce using rule 14 (LINES -> .)
    !               reduce using rule 14 (LINES -> .)
    (               reduce using rule 14 (LINES -> .)
    &               reduce using rule 14 (LINES -> .)
    CHAR            reduce using rule 14 (LINES -> .)
    NUMBERF         reduce using rule 14 (LINES -> .)
    NUMBER          reduce using rule 14 (LINES -> .)

    LINES                          shift and go to state 47

state 22

    (9) ARGS -> TYPE ARG RARGS .
    )               reduce using rule 9 (ARGS -> TYPE ARG RARGS .)


state 23

    (11) RARGS -> , . TYPE ARG RARGS
    TYPE            shift and go to state 48


state 24

    (26) DECLAR -> TYPE . POINTERS IDPRIMA
    (27) POINTERS -> .
    (28) POINTERS -> . * POINTERS
    ID              reduce using rule 27 (POINTERS -> .)
    *               shift and go to state 50

    POINTERS                       shift and go to state 49

state 25

    (54) PAROP -> ( . OROP )
    (39) OROP -> . ANDOP
    (40) OROP -> . OROP ORSIMB ANDOP
    (41) ANDOP -> . NOTOP
    (42) ANDOP -> . ANDOP ANDSIMB NOTOP
    (43) NOTOP -> . COMPOP
    (44) NOTOP -> . ! NOTOP
    (45) COMPOP -> . ADDOP
    (46) COMPOP -> . COMPOP COMPSIMB ADDOP
    (47) ADDOP -> . PRODOP
    (48) ADDOP -> . ADDOP - PRODOP
    (49) ADDOP -> . ADDOP + PRODOP
    (50) PRODOP -> . PAROP
    (51) PRODOP -> . PRODOP / PAROP
    (52) PRODOP -> . PRODOP * PAROP
    (53) PAROP -> . VAL
    (54) PAROP -> . ( OROP )
    (55) VAL -> . & ID
    (56) VAL -> . ID
    (57) VAL -> . CHAR
    (58) VAL -> . NUMBERF
    (59) VAL -> . NUMBER
    !               shift and go to state 38
    (               shift and go to state 25
    &               shift and go to state 43
    ID              shift and go to state 52
    CHAR            shift and go to state 44
    NUMBERF         shift and go to state 45
    NUMBER          shift and go to state 46

    OROP                           shift and go to state 51
    ANDOP                          shift and go to state 34
    NOTOP                          shift and go to state 36
    COMPOP                         shift and go to state 37
    ADDOP                          shift and go to state 39
    PRODOP                         shift and go to state 40
    PAROP                          shift and go to state 41
    VAL                            shift and go to state 42

state 26

    (1) S -> S2 TYPE emptymain MAIN ( ) { LINES } .
    $end            reduce using rule 1 (S -> S2 TYPE emptymain MAIN ( ) { LINES } .)


state 27

    (15) LINES -> LINES LINE . ;
    ;               shift and go to state 53


state 28

    (16) LINE -> PRINT . ( STRING PRINTIDS )
    (               shift and go to state 54


state 29

    (17) LINE -> SCANF . ( STRING SCANIDS )
    (               shift and go to state 55


state 30

    (18) LINE -> DECLAR .
    ;               reduce using rule 18 (LINE -> DECLAR .)


state 31

    (19) LINE -> INSTR .
    ;               reduce using rule 19 (LINE -> INSTR .)


state 32

    (24) INSTR -> OROP .
    (40) OROP -> OROP . ORSIMB ANDOP
    ;               reduce using rule 24 (INSTR -> OROP .)
    ,               reduce using rule 24 (INSTR -> OROP .)
    )               reduce using rule 24 (INSTR -> OROP .)
    ORSIMB          shift and go to state 56


state 33

    (25) INSTR -> ASIG .
    ;               reduce using rule 25 (INSTR -> ASIG .)
    ,               reduce using rule 25 (INSTR -> ASIG .)
    )               reduce using rule 25 (INSTR -> ASIG .)


state 34

    (39) OROP -> ANDOP .
    (42) ANDOP -> ANDOP . ANDSIMB NOTOP
    ORSIMB          reduce using rule 39 (OROP -> ANDOP .)
    ;               reduce using rule 39 (OROP -> ANDOP .)
    )               reduce using rule 39 (OROP -> ANDOP .)
    ,               reduce using rule 39 (OROP -> ANDOP .)
    ANDSIMB         shift and go to state 57


state 35

    (38) ASIG -> ID . = INSTR
    (56) VAL -> ID .
    =               shift and go to state 58
    /               reduce using rule 56 (VAL -> ID .)
    *               reduce using rule 56 (VAL -> ID .)
    -               reduce using rule 56 (VAL -> ID .)
    +               reduce using rule 56 (VAL -> ID .)
    COMPSIMB        reduce using rule 56 (VAL -> ID .)
    ANDSIMB         reduce using rule 56 (VAL -> ID .)
    ORSIMB          reduce using rule 56 (VAL -> ID .)
    ;               reduce using rule 56 (VAL -> ID .)
    ,               reduce using rule 56 (VAL -> ID .)
    )               reduce using rule 56 (VAL -> ID .)


state 36

    (41) ANDOP -> NOTOP .
    ANDSIMB         reduce using rule 41 (ANDOP -> NOTOP .)
    ORSIMB          reduce using rule 41 (ANDOP -> NOTOP .)
    ;               reduce using rule 41 (ANDOP -> NOTOP .)
    )               reduce using rule 41 (ANDOP -> NOTOP .)
    ,               reduce using rule 41 (ANDOP -> NOTOP .)


state 37

    (43) NOTOP -> COMPOP .
    (46) COMPOP -> COMPOP . COMPSIMB ADDOP
    ANDSIMB         reduce using rule 43 (NOTOP -> COMPOP .)
    ORSIMB          reduce using rule 43 (NOTOP -> COMPOP .)
    ;               reduce using rule 43 (NOTOP -> COMPOP .)
    )               reduce using rule 43 (NOTOP -> COMPOP .)
    ,               reduce using rule 43 (NOTOP -> COMPOP .)
    COMPSIMB        shift and go to state 59


state 38

    (44) NOTOP -> ! . NOTOP
    (43) NOTOP -> . COMPOP
    (44) NOTOP -> . ! NOTOP
    (45) COMPOP -> . ADDOP
    (46) COMPOP -> . COMPOP COMPSIMB ADDOP
    (47) ADDOP -> . PRODOP
    (48) ADDOP -> . ADDOP - PRODOP
    (49) ADDOP -> . ADDOP + PRODOP
    (50) PRODOP -> . PAROP
    (51) PRODOP -> . PRODOP / PAROP
    (52) PRODOP -> . PRODOP * PAROP
    (53) PAROP -> . VAL
    (54) PAROP -> . ( OROP )
    (55) VAL -> . & ID
    (56) VAL -> . ID
    (57) VAL -> . CHAR
    (58) VAL -> . NUMBERF
    (59) VAL -> . NUMBER
    !               shift and go to state 38
    (               shift and go to state 25
    &               shift and go to state 43
    ID              shift and go to state 52
    CHAR            shift and go to state 44
    NUMBERF         shift and go to state 45
    NUMBER          shift and go to state 46

    NOTOP                          shift and go to state 60
    COMPOP                         shift and go to state 37
    ADDOP                          shift and go to state 39
    PRODOP                         shift and go to state 40
    PAROP                          shift and go to state 41
    VAL                            shift and go to state 42

state 39

    (45) COMPOP -> ADDOP .
    (48) ADDOP -> ADDOP . - PRODOP
    (49) ADDOP -> ADDOP . + PRODOP
    COMPSIMB        reduce using rule 45 (COMPOP -> ADDOP .)
    ANDSIMB         reduce using rule 45 (COMPOP -> ADDOP .)
    ORSIMB          reduce using rule 45 (COMPOP -> ADDOP .)
    ;               reduce using rule 45 (COMPOP -> ADDOP .)
    )               reduce using rule 45 (COMPOP -> ADDOP .)
    ,               reduce using rule 45 (COMPOP -> ADDOP .)
    -               shift and go to state 61
    +               shift and go to state 62


state 40

    (47) ADDOP -> PRODOP .
    (51) PRODOP -> PRODOP . / PAROP
    (52) PRODOP -> PRODOP . * PAROP
    -               reduce using rule 47 (ADDOP -> PRODOP .)
    +               reduce using rule 47 (ADDOP -> PRODOP .)
    COMPSIMB        reduce using rule 47 (ADDOP -> PRODOP .)
    ANDSIMB         reduce using rule 47 (ADDOP -> PRODOP .)
    ORSIMB          reduce using rule 47 (ADDOP -> PRODOP .)
    ;               reduce using rule 47 (ADDOP -> PRODOP .)
    )               reduce using rule 47 (ADDOP -> PRODOP .)
    ,               reduce using rule 47 (ADDOP -> PRODOP .)
    /               shift and go to state 63
    *               shift and go to state 64


state 41

    (50) PRODOP -> PAROP .
    /               reduce using rule 50 (PRODOP -> PAROP .)
    *               reduce using rule 50 (PRODOP -> PAROP .)
    -               reduce using rule 50 (PRODOP -> PAROP .)
    +               reduce using rule 50 (PRODOP -> PAROP .)
    COMPSIMB        reduce using rule 50 (PRODOP -> PAROP .)
    ANDSIMB         reduce using rule 50 (PRODOP -> PAROP .)
    ORSIMB          reduce using rule 50 (PRODOP -> PAROP .)
    ;               reduce using rule 50 (PRODOP -> PAROP .)
    )               reduce using rule 50 (PRODOP -> PAROP .)
    ,               reduce using rule 50 (PRODOP -> PAROP .)


state 42

    (53) PAROP -> VAL .
    /               reduce using rule 53 (PAROP -> VAL .)
    *               reduce using rule 53 (PAROP -> VAL .)
    -               reduce using rule 53 (PAROP -> VAL .)
    +               reduce using rule 53 (PAROP -> VAL .)
    COMPSIMB        reduce using rule 53 (PAROP -> VAL .)
    ANDSIMB         reduce using rule 53 (PAROP -> VAL .)
    ORSIMB          reduce using rule 53 (PAROP -> VAL .)
    ;               reduce using rule 53 (PAROP -> VAL .)
    )               reduce using rule 53 (PAROP -> VAL .)
    ,               reduce using rule 53 (PAROP -> VAL .)


state 43

    (55) VAL -> & . ID
    ID              shift and go to state 65


state 44

    (57) VAL -> CHAR .
    /               reduce using rule 57 (VAL -> CHAR .)
    *               reduce using rule 57 (VAL -> CHAR .)
    -               reduce using rule 57 (VAL -> CHAR .)
    +               reduce using rule 57 (VAL -> CHAR .)
    COMPSIMB        reduce using rule 57 (VAL -> CHAR .)
    ANDSIMB         reduce using rule 57 (VAL -> CHAR .)
    ORSIMB          reduce using rule 57 (VAL -> CHAR .)
    ;               reduce using rule 57 (VAL -> CHAR .)
    )               reduce using rule 57 (VAL -> CHAR .)
    ,               reduce using rule 57 (VAL -> CHAR .)


state 45

    (58) VAL -> NUMBERF .
    /               reduce using rule 58 (VAL -> NUMBERF .)
    *               reduce using rule 58 (VAL -> NUMBERF .)
    -               reduce using rule 58 (VAL -> NUMBERF .)
    +               reduce using rule 58 (VAL -> NUMBERF .)
    COMPSIMB        reduce using rule 58 (VAL -> NUMBERF .)
    ANDSIMB         reduce using rule 58 (VAL -> NUMBERF .)
    ORSIMB          reduce using rule 58 (VAL -> NUMBERF .)
    ;               reduce using rule 58 (VAL -> NUMBERF .)
    )               reduce using rule 58 (VAL -> NUMBERF .)
    ,               reduce using rule 58 (VAL -> NUMBERF .)


state 46

    (59) VAL -> NUMBER .
    /               reduce using rule 59 (VAL -> NUMBER .)
    *               reduce using rule 59 (VAL -> NUMBER .)
    -               reduce using rule 59 (VAL -> NUMBER .)
    +               reduce using rule 59 (VAL -> NUMBER .)
    COMPSIMB        reduce using rule 59 (VAL -> NUMBER .)
    ANDSIMB         reduce using rule 59 (VAL -> NUMBER .)
    ORSIMB          reduce using rule 59 (VAL -> NUMBER .)
    ;               reduce using rule 59 (VAL -> NUMBER .)
    )               reduce using rule 59 (VAL -> NUMBER .)
    ,               reduce using rule 59 (VAL -> NUMBER .)


state 47

    (5) FUNCTION -> FUNCTYPE ID emptyF1 ( ARGS ) { LINES . }
    (15) LINES -> LINES . LINE ;
    (16) LINE -> . PRINT ( STRING PRINTIDS )
    (17) LINE -> . SCANF ( STRING SCANIDS )
    (18) LINE -> . DECLAR
    (19) LINE -> . INSTR
    (26) DECLAR -> . TYPE POINTERS IDPRIMA
    (24) INSTR -> . OROP
    (25) INSTR -> . ASIG
    (39) OROP -> . ANDOP
    (40) OROP -> . OROP ORSIMB ANDOP
    (38) ASIG -> . ID = INSTR
    (41) ANDOP -> . NOTOP
    (42) ANDOP -> . ANDOP ANDSIMB NOTOP
    (43) NOTOP -> . COMPOP
    (44) NOTOP -> . ! NOTOP
    (45) COMPOP -> . ADDOP
    (46) COMPOP -> . COMPOP COMPSIMB ADDOP
    (47) ADDOP -> . PRODOP
    (48) ADDOP -> . ADDOP - PRODOP
    (49) ADDOP -> . ADDOP + PRODOP
    (50) PRODOP -> . PAROP
    (51) PRODOP -> . PRODOP / PAROP
    (52) PRODOP -> . PRODOP * PAROP
    (53) PAROP -> . VAL
    (54) PAROP -> . ( OROP )
    (55) VAL -> . & ID
    (56) VAL -> . ID
    (57) VAL -> . CHAR
    (58) VAL -> . NUMBERF
    (59) VAL -> . NUMBER
    }               shift and go to state 66
    PRINT           shift and go to state 28
    SCANF           shift and go to state 29
    TYPE            shift and go to state 24
    ID              shift and go to state 35
    !               shift and go to state 38
    (               shift and go to state 25
    &               shift and go to state 43
    CHAR            shift and go to state 44
    NUMBERF         shift and go to state 45
    NUMBER          shift and go to state 46

    LINE                           shift and go to state 27
    DECLAR                         shift and go to state 30
    INSTR                          shift and go to state 31
    OROP                           shift and go to state 32
    ASIG                           shift and go to state 33
    ANDOP                          shift and go to state 34
    NOTOP                          shift and go to state 36
    COMPOP                         shift and go to state 37
    ADDOP                          shift and go to state 39
    PRODOP                         shift and go to state 40
    PAROP                          shift and go to state 41
    VAL                            shift and go to state 42

state 48

    (11) RARGS -> , TYPE . ARG RARGS
    (13) ARG -> . ID
    ID              shift and go to state 19

    ARG                            shift and go to state 67

state 49

    (26) DECLAR -> TYPE POINTERS . IDPRIMA
    (29) IDPRIMA -> . empty ELEM REST
    (36) empty -> .
    ID              reduce using rule 36 (empty -> .)

    IDPRIMA                        shift and go to state 68
    empty                          shift and go to state 69

state 50

    (28) POINTERS -> * . POINTERS
    (27) POINTERS -> .
    (28) POINTERS -> . * POINTERS
    ID              reduce using rule 27 (POINTERS -> .)
    *               shift and go to state 50

    POINTERS                       shift and go to state 70

state 51

    (54) PAROP -> ( OROP . )
    (40) OROP -> OROP . ORSIMB ANDOP
    )               shift and go to state 71
    ORSIMB          shift and go to state 56


state 52

    (56) VAL -> ID .
    /               reduce using rule 56 (VAL -> ID .)
    *               reduce using rule 56 (VAL -> ID .)
    -               reduce using rule 56 (VAL -> ID .)
    +               reduce using rule 56 (VAL -> ID .)
    COMPSIMB        reduce using rule 56 (VAL -> ID .)
    ANDSIMB         reduce using rule 56 (VAL -> ID .)
    )               reduce using rule 56 (VAL -> ID .)
    ORSIMB          reduce using rule 56 (VAL -> ID .)
    ;               reduce using rule 56 (VAL -> ID .)
    ,               reduce using rule 56 (VAL -> ID .)


state 53

    (15) LINES -> LINES LINE ; .
    }               reduce using rule 15 (LINES -> LINES LINE ; .)
    PRINT           reduce using rule 15 (LINES -> LINES LINE ; .)
    SCANF           reduce using rule 15 (LINES -> LINES LINE ; .)
    TYPE            reduce using rule 15 (LINES -> LINES LINE ; .)
    ID              reduce using rule 15 (LINES -> LINES LINE ; .)
    !               reduce using rule 15 (LINES -> LINES LINE ; .)
    (               reduce using rule 15 (LINES -> LINES LINE ; .)
    &               reduce using rule 15 (LINES -> LINES LINE ; .)
    CHAR            reduce using rule 15 (LINES -> LINES LINE ; .)
    NUMBERF         reduce using rule 15 (LINES -> LINES LINE ; .)
    NUMBER          reduce using rule 15 (LINES -> LINES LINE ; .)


state 54

    (16) LINE -> PRINT ( . STRING PRINTIDS )
    STRING          shift and go to state 72


state 55

    (17) LINE -> SCANF ( . STRING SCANIDS )
    STRING          shift and go to state 73


state 56

    (40) OROP -> OROP ORSIMB . ANDOP
    (41) ANDOP -> . NOTOP
    (42) ANDOP -> . ANDOP ANDSIMB NOTOP
    (43) NOTOP -> . COMPOP
    (44) NOTOP -> . ! NOTOP
    (45) COMPOP -> . ADDOP
    (46) COMPOP -> . COMPOP COMPSIMB ADDOP
    (47) ADDOP -> . PRODOP
    (48) ADDOP -> . ADDOP - PRODOP
    (49) ADDOP -> . ADDOP + PRODOP
    (50) PRODOP -> . PAROP
    (51) PRODOP -> . PRODOP / PAROP
    (52) PRODOP -> . PRODOP * PAROP
    (53) PAROP -> . VAL
    (54) PAROP -> . ( OROP )
    (55) VAL -> . & ID
    (56) VAL -> . ID
    (57) VAL -> . CHAR
    (58) VAL -> . NUMBERF
    (59) VAL -> . NUMBER
    !               shift and go to state 38
    (               shift and go to state 25
    &               shift and go to state 43
    ID              shift and go to state 52
    CHAR            shift and go to state 44
    NUMBERF         shift and go to state 45
    NUMBER          shift and go to state 46

    ANDOP                          shift and go to state 74
    NOTOP                          shift and go to state 36
    COMPOP                         shift and go to state 37
    ADDOP                          shift and go to state 39
    PRODOP                         shift and go to state 40
    PAROP                          shift and go to state 41
    VAL                            shift and go to state 42

state 57

    (42) ANDOP -> ANDOP ANDSIMB . NOTOP
    (43) NOTOP -> . COMPOP
    (44) NOTOP -> . ! NOTOP
    (45) COMPOP -> . ADDOP
    (46) COMPOP -> . COMPOP COMPSIMB ADDOP
    (47) ADDOP -> . PRODOP
    (48) ADDOP -> . ADDOP - PRODOP
    (49) ADDOP -> . ADDOP + PRODOP
    (50) PRODOP -> . PAROP
    (51) PRODOP -> . PRODOP / PAROP
    (52) PRODOP -> . PRODOP * PAROP
    (53) PAROP -> . VAL
    (54) PAROP -> . ( OROP )
    (55) VAL -> . & ID
    (56) VAL -> . ID
    (57) VAL -> . CHAR
    (58) VAL -> . NUMBERF
    (59) VAL -> . NUMBER
    !               shift and go to state 38
    (               shift and go to state 25
    &               shift and go to state 43
    ID              shift and go to state 52
    CHAR            shift and go to state 44
    NUMBERF         shift and go to state 45
    NUMBER          shift and go to state 46

    NOTOP                          shift and go to state 75
    COMPOP                         shift and go to state 37
    ADDOP                          shift and go to state 39
    PRODOP                         shift and go to state 40
    PAROP                          shift and go to state 41
    VAL                            shift and go to state 42

state 58

    (38) ASIG -> ID = . INSTR
    (24) INSTR -> . OROP
    (25) INSTR -> . ASIG
    (39) OROP -> . ANDOP
    (40) OROP -> . OROP ORSIMB ANDOP
    (38) ASIG -> . ID = INSTR
    (41) ANDOP -> . NOTOP
    (42) ANDOP -> . ANDOP ANDSIMB NOTOP
    (43) NOTOP -> . COMPOP
    (44) NOTOP -> . ! NOTOP
    (45) COMPOP -> . ADDOP
    (46) COMPOP -> . COMPOP COMPSIMB ADDOP
    (47) ADDOP -> . PRODOP
    (48) ADDOP -> . ADDOP - PRODOP
    (49) ADDOP -> . ADDOP + PRODOP
    (50) PRODOP -> . PAROP
    (51) PRODOP -> . PRODOP / PAROP
    (52) PRODOP -> . PRODOP * PAROP
    (53) PAROP -> . VAL
    (54) PAROP -> . ( OROP )
    (55) VAL -> . & ID
    (56) VAL -> . ID
    (57) VAL -> . CHAR
    (58) VAL -> . NUMBERF
    (59) VAL -> . NUMBER
    ID              shift and go to state 35
    !               shift and go to state 38
    (               shift and go to state 25
    &               shift and go to state 43
    CHAR            shift and go to state 44
    NUMBERF         shift and go to state 45
    NUMBER          shift and go to state 46

    INSTR                          shift and go to state 76
    OROP                           shift and go to state 32
    ASIG                           shift and go to state 33
    ANDOP                          shift and go to state 34
    NOTOP                          shift and go to state 36
    COMPOP                         shift and go to state 37
    ADDOP                          shift and go to state 39
    PRODOP                         shift and go to state 40
    PAROP                          shift and go to state 41
    VAL                            shift and go to state 42

state 59

    (46) COMPOP -> COMPOP COMPSIMB . ADDOP
    (47) ADDOP -> . PRODOP
    (48) ADDOP -> . ADDOP - PRODOP
    (49) ADDOP -> . ADDOP + PRODOP
    (50) PRODOP -> . PAROP
    (51) PRODOP -> . PRODOP / PAROP
    (52) PRODOP -> . PRODOP * PAROP
    (53) PAROP -> . VAL
    (54) PAROP -> . ( OROP )
    (55) VAL -> . & ID
    (56) VAL -> . ID
    (57) VAL -> . CHAR
    (58) VAL -> . NUMBERF
    (59) VAL -> . NUMBER
    (               shift and go to state 25
    &               shift and go to state 43
    ID              shift and go to state 52
    CHAR            shift and go to state 44
    NUMBERF         shift and go to state 45
    NUMBER          shift and go to state 46

    ADDOP                          shift and go to state 77
    PRODOP                         shift and go to state 40
    PAROP                          shift and go to state 41
    VAL                            shift and go to state 42

state 60

    (44) NOTOP -> ! NOTOP .
    ANDSIMB         reduce using rule 44 (NOTOP -> ! NOTOP .)
    ORSIMB          reduce using rule 44 (NOTOP -> ! NOTOP .)
    ;               reduce using rule 44 (NOTOP -> ! NOTOP .)
    )               reduce using rule 44 (NOTOP -> ! NOTOP .)
    ,               reduce using rule 44 (NOTOP -> ! NOTOP .)


state 61

    (48) ADDOP -> ADDOP - . PRODOP
    (50) PRODOP -> . PAROP
    (51) PRODOP -> . PRODOP / PAROP
    (52) PRODOP -> . PRODOP * PAROP
    (53) PAROP -> . VAL
    (54) PAROP -> . ( OROP )
    (55) VAL -> . & ID
    (56) VAL -> . ID
    (57) VAL -> . CHAR
    (58) VAL -> . NUMBERF
    (59) VAL -> . NUMBER
    (               shift and go to state 25
    &               shift and go to state 43
    ID              shift and go to state 52
    CHAR            shift and go to state 44
    NUMBERF         shift and go to state 45
    NUMBER          shift and go to state 46

    PRODOP                         shift and go to state 78
    PAROP                          shift and go to state 41
    VAL                            shift and go to state 42

state 62

    (49) ADDOP -> ADDOP + . PRODOP
    (50) PRODOP -> . PAROP
    (51) PRODOP -> . PRODOP / PAROP
    (52) PRODOP -> . PRODOP * PAROP
    (53) PAROP -> . VAL
    (54) PAROP -> . ( OROP )
    (55) VAL -> . & ID
    (56) VAL -> . ID
    (57) VAL -> . CHAR
    (58) VAL -> . NUMBERF
    (59) VAL -> . NUMBER
    (               shift and go to state 25
    &               shift and go to state 43
    ID              shift and go to state 52
    CHAR            shift and go to state 44
    NUMBERF         shift and go to state 45
    NUMBER          shift and go to state 46

    PRODOP                         shift and go to state 79
    PAROP                          shift and go to state 41
    VAL                            shift and go to state 42

state 63

    (51) PRODOP -> PRODOP / . PAROP
    (53) PAROP -> . VAL
    (54) PAROP -> . ( OROP )
    (55) VAL -> . & ID
    (56) VAL -> . ID
    (57) VAL -> . CHAR
    (58) VAL -> . NUMBERF
    (59) VAL -> . NUMBER
    (               shift and go to state 25
    &               shift and go to state 43
    ID              shift and go to state 52
    CHAR            shift and go to state 44
    NUMBERF         shift and go to state 45
    NUMBER          shift and go to state 46

    PAROP                          shift and go to state 80
    VAL                            shift and go to state 42

state 64

    (52) PRODOP -> PRODOP * . PAROP
    (53) PAROP -> . VAL
    (54) PAROP -> . ( OROP )
    (55) VAL -> . & ID
    (56) VAL -> . ID
    (57) VAL -> . CHAR
    (58) VAL -> . NUMBERF
    (59) VAL -> . NUMBER
    (               shift and go to state 25
    &               shift and go to state 43
    ID              shift and go to state 52
    CHAR            shift and go to state 44
    NUMBERF         shift and go to state 45
    NUMBER          shift and go to state 46

    PAROP                          shift and go to state 81
    VAL                            shift and go to state 42

state 65

    (55) VAL -> & ID .
    /               reduce using rule 55 (VAL -> & ID .)
    *               reduce using rule 55 (VAL -> & ID .)
    -               reduce using rule 55 (VAL -> & ID .)
    +               reduce using rule 55 (VAL -> & ID .)
    COMPSIMB        reduce using rule 55 (VAL -> & ID .)
    ANDSIMB         reduce using rule 55 (VAL -> & ID .)
    ORSIMB          reduce using rule 55 (VAL -> & ID .)
    ;               reduce using rule 55 (VAL -> & ID .)
    )               reduce using rule 55 (VAL -> & ID .)
    ,               reduce using rule 55 (VAL -> & ID .)


state 66

    (5) FUNCTION -> FUNCTYPE ID emptyF1 ( ARGS ) { LINES } .
    TYPE            reduce using rule 5 (FUNCTION -> FUNCTYPE ID emptyF1 ( ARGS ) { LINES } .)
    VOIDTYPE        reduce using rule 5 (FUNCTION -> FUNCTYPE ID emptyF1 ( ARGS ) { LINES } .)


state 67

    (11) RARGS -> , TYPE ARG . RARGS
    (10) RARGS -> .
    (11) RARGS -> . , TYPE ARG RARGS
    )               reduce using rule 10 (RARGS -> .)
    ,               shift and go to state 23

    RARGS                          shift and go to state 82

state 68

    (26) DECLAR -> TYPE POINTERS IDPRIMA .
    ;               reduce using rule 26 (DECLAR -> TYPE POINTERS IDPRIMA .)


state 69

    (29) IDPRIMA -> empty . ELEM REST
    (32) ELEM -> . ID = INSTR
    (33) ELEM -> . ID ARRAY
    ID              shift and go to state 84

    ELEM                           shift and go to state 83

state 70

    (28) POINTERS -> * POINTERS .
    ID              reduce using rule 28 (POINTERS -> * POINTERS .)


state 71

    (54) PAROP -> ( OROP ) .
    /               reduce using rule 54 (PAROP -> ( OROP ) .)
    *               reduce using rule 54 (PAROP -> ( OROP ) .)
    -               reduce using rule 54 (PAROP -> ( OROP ) .)
    +               reduce using rule 54 (PAROP -> ( OROP ) .)
    COMPSIMB        reduce using rule 54 (PAROP -> ( OROP ) .)
    ANDSIMB         reduce using rule 54 (PAROP -> ( OROP ) .)
    ORSIMB          reduce using rule 54 (PAROP -> ( OROP ) .)
    ;               reduce using rule 54 (PAROP -> ( OROP ) .)
    )               reduce using rule 54 (PAROP -> ( OROP ) .)
    ,               reduce using rule 54 (PAROP -> ( OROP ) .)


state 72

    (16) LINE -> PRINT ( STRING . PRINTIDS )
    (22) PRINTIDS -> .
    (23) PRINTIDS -> . , INSTR PRINTIDS
    )               reduce using rule 22 (PRINTIDS -> .)
    ,               shift and go to state 86

    PRINTIDS                       shift and go to state 85

state 73

    (17) LINE -> SCANF ( STRING . SCANIDS )
    (20) SCANIDS -> .
    (21) SCANIDS -> . , & ID SCANIDS
    )               reduce using rule 20 (SCANIDS -> .)
    ,               shift and go to state 88

    SCANIDS                        shift and go to state 87

state 74

    (40) OROP -> OROP ORSIMB ANDOP .
    (42) ANDOP -> ANDOP . ANDSIMB NOTOP
    ORSIMB          reduce using rule 40 (OROP -> OROP ORSIMB ANDOP .)
    ;               reduce using rule 40 (OROP -> OROP ORSIMB ANDOP .)
    )               reduce using rule 40 (OROP -> OROP ORSIMB ANDOP .)
    ,               reduce using rule 40 (OROP -> OROP ORSIMB ANDOP .)
    ANDSIMB         shift and go to state 57


state 75

    (42) ANDOP -> ANDOP ANDSIMB NOTOP .
    ANDSIMB         reduce using rule 42 (ANDOP -> ANDOP ANDSIMB NOTOP .)
    ORSIMB          reduce using rule 42 (ANDOP -> ANDOP ANDSIMB NOTOP .)
    ;               reduce using rule 42 (ANDOP -> ANDOP ANDSIMB NOTOP .)
    )               reduce using rule 42 (ANDOP -> ANDOP ANDSIMB NOTOP .)
    ,               reduce using rule 42 (ANDOP -> ANDOP ANDSIMB NOTOP .)


state 76

    (38) ASIG -> ID = INSTR .
    ;               reduce using rule 38 (ASIG -> ID = INSTR .)
    ,               reduce using rule 38 (ASIG -> ID = INSTR .)
    )               reduce using rule 38 (ASIG -> ID = INSTR .)


state 77

    (46) COMPOP -> COMPOP COMPSIMB ADDOP .
    (48) ADDOP -> ADDOP . - PRODOP
    (49) ADDOP -> ADDOP . + PRODOP
    COMPSIMB        reduce using rule 46 (COMPOP -> COMPOP COMPSIMB ADDOP .)
    ANDSIMB         reduce using rule 46 (COMPOP -> COMPOP COMPSIMB ADDOP .)
    ORSIMB          reduce using rule 46 (COMPOP -> COMPOP COMPSIMB ADDOP .)
    ;               reduce using rule 46 (COMPOP -> COMPOP COMPSIMB ADDOP .)
    )               reduce using rule 46 (COMPOP -> COMPOP COMPSIMB ADDOP .)
    ,               reduce using rule 46 (COMPOP -> COMPOP COMPSIMB ADDOP .)
    -               shift and go to state 61
    +               shift and go to state 62


state 78

    (48) ADDOP -> ADDOP - PRODOP .
    (51) PRODOP -> PRODOP . / PAROP
    (52) PRODOP -> PRODOP . * PAROP
    -               reduce using rule 48 (ADDOP -> ADDOP - PRODOP .)
    +               reduce using rule 48 (ADDOP -> ADDOP - PRODOP .)
    COMPSIMB        reduce using rule 48 (ADDOP -> ADDOP - PRODOP .)
    ANDSIMB         reduce using rule 48 (ADDOP -> ADDOP - PRODOP .)
    ORSIMB          reduce using rule 48 (ADDOP -> ADDOP - PRODOP .)
    ;               reduce using rule 48 (ADDOP -> ADDOP - PRODOP .)
    )               reduce using rule 48 (ADDOP -> ADDOP - PRODOP .)
    ,               reduce using rule 48 (ADDOP -> ADDOP - PRODOP .)
    /               shift and go to state 63
    *               shift and go to state 64


state 79

    (49) ADDOP -> ADDOP + PRODOP .
    (51) PRODOP -> PRODOP . / PAROP
    (52) PRODOP -> PRODOP . * PAROP
    -               reduce using rule 49 (ADDOP -> ADDOP + PRODOP .)
    +               reduce using rule 49 (ADDOP -> ADDOP + PRODOP .)
    COMPSIMB        reduce using rule 49 (ADDOP -> ADDOP + PRODOP .)
    ANDSIMB         reduce using rule 49 (ADDOP -> ADDOP + PRODOP .)
    ORSIMB          reduce using rule 49 (ADDOP -> ADDOP + PRODOP .)
    ;               reduce using rule 49 (ADDOP -> ADDOP + PRODOP .)
    )               reduce using rule 49 (ADDOP -> ADDOP + PRODOP .)
    ,               reduce using rule 49 (ADDOP -> ADDOP + PRODOP .)
    /               shift and go to state 63
    *               shift and go to state 64


state 80

    (51) PRODOP -> PRODOP / PAROP .
    /               reduce using rule 51 (PRODOP -> PRODOP / PAROP .)
    *               reduce using rule 51 (PRODOP -> PRODOP / PAROP .)
    -               reduce using rule 51 (PRODOP -> PRODOP / PAROP .)
    +               reduce using rule 51 (PRODOP -> PRODOP / PAROP .)
    COMPSIMB        reduce using rule 51 (PRODOP -> PRODOP / PAROP .)
    ANDSIMB         reduce using rule 51 (PRODOP -> PRODOP / PAROP .)
    ORSIMB          reduce using rule 51 (PRODOP -> PRODOP / PAROP .)
    ;               reduce using rule 51 (PRODOP -> PRODOP / PAROP .)
    )               reduce using rule 51 (PRODOP -> PRODOP / PAROP .)
    ,               reduce using rule 51 (PRODOP -> PRODOP / PAROP .)


state 81

    (52) PRODOP -> PRODOP * PAROP .
    /               reduce using rule 52 (PRODOP -> PRODOP * PAROP .)
    *               reduce using rule 52 (PRODOP -> PRODOP * PAROP .)
    -               reduce using rule 52 (PRODOP -> PRODOP * PAROP .)
    +               reduce using rule 52 (PRODOP -> PRODOP * PAROP .)
    COMPSIMB        reduce using rule 52 (PRODOP -> PRODOP * PAROP .)
    ANDSIMB         reduce using rule 52 (PRODOP -> PRODOP * PAROP .)
    ORSIMB          reduce using rule 52 (PRODOP -> PRODOP * PAROP .)
    ;               reduce using rule 52 (PRODOP -> PRODOP * PAROP .)
    )               reduce using rule 52 (PRODOP -> PRODOP * PAROP .)
    ,               reduce using rule 52 (PRODOP -> PRODOP * PAROP .)


state 82

    (11) RARGS -> , TYPE ARG RARGS .
    )               reduce using rule 11 (RARGS -> , TYPE ARG RARGS .)


state 83

    (29) IDPRIMA -> empty ELEM . REST
    (30) REST -> .
    (31) REST -> . , empty2 ELEM REST
    ;               reduce using rule 30 (REST -> .)
    ,               shift and go to state 90

    REST                           shift and go to state 89

state 84

    (32) ELEM -> ID . = INSTR
    (33) ELEM -> ID . ARRAY
    (34) ARRAY -> .
    (35) ARRAY -> . [ NUMBER ] ARRAY
    =               shift and go to state 91
    ,               reduce using rule 34 (ARRAY -> .)
    ;               reduce using rule 34 (ARRAY -> .)
    [               shift and go to state 93

    ARRAY                          shift and go to state 92

state 85

    (16) LINE -> PRINT ( STRING PRINTIDS . )
    )               shift and go to state 94


state 86

    (23) PRINTIDS -> , . INSTR PRINTIDS
    (24) INSTR -> . OROP
    (25) INSTR -> . ASIG
    (39) OROP -> . ANDOP
    (40) OROP -> . OROP ORSIMB ANDOP
    (38) ASIG -> . ID = INSTR
    (41) ANDOP -> . NOTOP
    (42) ANDOP -> . ANDOP ANDSIMB NOTOP
    (43) NOTOP -> . COMPOP
    (44) NOTOP -> . ! NOTOP
    (45) COMPOP -> . ADDOP
    (46) COMPOP -> . COMPOP COMPSIMB ADDOP
    (47) ADDOP -> . PRODOP
    (48) ADDOP -> . ADDOP - PRODOP
    (49) ADDOP -> . ADDOP + PRODOP
    (50) PRODOP -> . PAROP
    (51) PRODOP -> . PRODOP / PAROP
    (52) PRODOP -> . PRODOP * PAROP
    (53) PAROP -> . VAL
    (54) PAROP -> . ( OROP )
    (55) VAL -> . & ID
    (56) VAL -> . ID
    (57) VAL -> . CHAR
    (58) VAL -> . NUMBERF
    (59) VAL -> . NUMBER
    ID              shift and go to state 35
    !               shift and go to state 38
    (               shift and go to state 25
    &               shift and go to state 43
    CHAR            shift and go to state 44
    NUMBERF         shift and go to state 45
    NUMBER          shift and go to state 46

    INSTR                          shift and go to state 95
    OROP                           shift and go to state 32
    ASIG                           shift and go to state 33
    ANDOP                          shift and go to state 34
    NOTOP                          shift and go to state 36
    COMPOP                         shift and go to state 37
    ADDOP                          shift and go to state 39
    PRODOP                         shift and go to state 40
    PAROP                          shift and go to state 41
    VAL                            shift and go to state 42

state 87

    (17) LINE -> SCANF ( STRING SCANIDS . )
    )               shift and go to state 96


state 88

    (21) SCANIDS -> , . & ID SCANIDS
    &               shift and go to state 97


state 89

    (29) IDPRIMA -> empty ELEM REST .
    ;               reduce using rule 29 (IDPRIMA -> empty ELEM REST .)


state 90

    (31) REST -> , . empty2 ELEM REST
    (37) empty2 -> .
    ID              reduce using rule 37 (empty2 -> .)

    empty2                         shift and go to state 98

state 91

    (32) ELEM -> ID = . INSTR
    (24) INSTR -> . OROP
    (25) INSTR -> . ASIG
    (39) OROP -> . ANDOP
    (40) OROP -> . OROP ORSIMB ANDOP
    (38) ASIG -> . ID = INSTR
    (41) ANDOP -> . NOTOP
    (42) ANDOP -> . ANDOP ANDSIMB NOTOP
    (43) NOTOP -> . COMPOP
    (44) NOTOP -> . ! NOTOP
    (45) COMPOP -> . ADDOP
    (46) COMPOP -> . COMPOP COMPSIMB ADDOP
    (47) ADDOP -> . PRODOP
    (48) ADDOP -> . ADDOP - PRODOP
    (49) ADDOP -> . ADDOP + PRODOP
    (50) PRODOP -> . PAROP
    (51) PRODOP -> . PRODOP / PAROP
    (52) PRODOP -> . PRODOP * PAROP
    (53) PAROP -> . VAL
    (54) PAROP -> . ( OROP )
    (55) VAL -> . & ID
    (56) VAL -> . ID
    (57) VAL -> . CHAR
    (58) VAL -> . NUMBERF
    (59) VAL -> . NUMBER
    ID              shift and go to state 35
    !               shift and go to state 38
    (               shift and go to state 25
    &               shift and go to state 43
    CHAR            shift and go to state 44
    NUMBERF         shift and go to state 45
    NUMBER          shift and go to state 46

    INSTR                          shift and go to state 99
    OROP                           shift and go to state 32
    ASIG                           shift and go to state 33
    ANDOP                          shift and go to state 34
    NOTOP                          shift and go to state 36
    COMPOP                         shift and go to state 37
    ADDOP                          shift and go to state 39
    PRODOP                         shift and go to state 40
    PAROP                          shift and go to state 41
    VAL                            shift and go to state 42

state 92

    (33) ELEM -> ID ARRAY .
    ,               reduce using rule 33 (ELEM -> ID ARRAY .)
    ;               reduce using rule 33 (ELEM -> ID ARRAY .)


state 93

    (35) ARRAY -> [ . NUMBER ] ARRAY
    NUMBER          shift and go to state 100


state 94

    (16) LINE -> PRINT ( STRING PRINTIDS ) .
    ;               reduce using rule 16 (LINE -> PRINT ( STRING PRINTIDS ) .)


state 95

    (23) PRINTIDS -> , INSTR . PRINTIDS
    (22) PRINTIDS -> .
    (23) PRINTIDS -> . , INSTR PRINTIDS
    )               reduce using rule 22 (PRINTIDS -> .)
    ,               shift and go to state 86

    PRINTIDS                       shift and go to state 101

state 96

    (17) LINE -> SCANF ( STRING SCANIDS ) .
    ;               reduce using rule 17 (LINE -> SCANF ( STRING SCANIDS ) .)


state 97

    (21) SCANIDS -> , & . ID SCANIDS
    ID              shift and go to state 102


state 98

    (31) REST -> , empty2 . ELEM REST
    (32) ELEM -> . ID = INSTR
    (33) ELEM -> . ID ARRAY
    ID              shift and go to state 84

    ELEM                           shift and go to state 103

state 99

    (32) ELEM -> ID = INSTR .
    ,               reduce using rule 32 (ELEM -> ID = INSTR .)
    ;               reduce using rule 32 (ELEM -> ID = INSTR .)


state 100

    (35) ARRAY -> [ NUMBER . ] ARRAY
    ]               shift and go to state 104


state 101

    (23) PRINTIDS -> , INSTR PRINTIDS .
    )               reduce using rule 23 (PRINTIDS -> , INSTR PRINTIDS .)


state 102

    (21) SCANIDS -> , & ID . SCANIDS
    (20) SCANIDS -> .
    (21) SCANIDS -> . , & ID SCANIDS
    )               reduce using rule 20 (SCANIDS -> .)
    ,               shift and go to state 88

    SCANIDS                        shift and go to state 105

state 103

    (31) REST -> , empty2 ELEM . REST
    (30) REST -> .
    (31) REST -> . , empty2 ELEM REST
    ;               reduce using rule 30 (REST -> .)
    ,               shift and go to state 90

    REST                           shift and go to state 106

state 104

    (35) ARRAY -> [ NUMBER ] . ARRAY
    (34) ARRAY -> .
    (35) ARRAY -> . [ NUMBER ] ARRAY
    ,               reduce using rule 34 (ARRAY -> .)
    ;               reduce using rule 34 (ARRAY -> .)
    [               shift and go to state 93

    ARRAY                          shift and go to state 107

state 105

    (21) SCANIDS -> , & ID SCANIDS .
    )               reduce using rule 21 (SCANIDS -> , & ID SCANIDS .)


state 106

    (31) REST -> , empty2 ELEM REST .
    ;               reduce using rule 31 (REST -> , empty2 ELEM REST .)


state 107

    (35) ARRAY -> [ NUMBER ] ARRAY .
    ,               reduce using rule 35 (ARRAY -> [ NUMBER ] ARRAY .)
    ;               reduce using rule 35 (ARRAY -> [ NUMBER ] ARRAY .)
