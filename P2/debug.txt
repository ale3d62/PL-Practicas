Grammar:

Rule 0     S' -> S
Rule 1     S -> <empty>
Rule 2     S -> S FUNCTION
Rule 3     FUNCTION -> TYPE ID emptyF1 ( ARGS ) { LINES }
Rule 4     ARGS -> TYPE ARG RARGS
Rule 5     RARGS -> <empty>
Rule 6     RARGS -> , TYPE ARG RARGS
Rule 7     emptyF1 -> <empty>
Rule 8     ARG -> ID
Rule 9     LINES -> <empty>
Rule 10    LINES -> LINES LINE ;
Rule 11    LINE -> DECLAR
Rule 12    LINE -> INSTR
Rule 13    INSTR -> OROP
Rule 14    INSTR -> ASIG
Rule 15    DECLAR -> TYPE IDPRIMA
Rule 16    IDPRIMA -> empty ELEM REST
Rule 17    REST -> <empty>
Rule 18    REST -> , empty2 ELEM REST
Rule 19    ELEM -> ID = INSTR
Rule 20    ELEM -> ID
Rule 21    empty -> <empty>
Rule 22    empty2 -> <empty>
Rule 23    ASIG -> ID = INSTR
Rule 24    OROP -> ANDOP
Rule 25    OROP -> OROP ORSIMB ANDOP
Rule 26    ANDOP -> NOTOP
Rule 27    ANDOP -> ANDOP ANDSIMB NOTOP
Rule 28    NOTOP -> COMPOP
Rule 29    NOTOP -> ! NOTOP
Rule 30    COMPOP -> ADDOP
Rule 31    COMPOP -> COMPOP COMPSIMB ADDOP
Rule 32    ADDOP -> PRODOP
Rule 33    ADDOP -> ADDOP - PRODOP
Rule 34    ADDOP -> ADDOP + PRODOP
Rule 35    PRODOP -> PAROP
Rule 36    PRODOP -> PRODOP / PAROP
Rule 37    PRODOP -> PRODOP * PAROP
Rule 38    PAROP -> VAL
Rule 39    PAROP -> ( OROP )
Rule 40    VAL -> ID
Rule 41    VAL -> CHAR
Rule 42    VAL -> NUMBERF
Rule 43    VAL -> NUMBER

Terminals, with rules where they appear:

!                    : 29
(                    : 3 39
)                    : 3 39
*                    : 37
+                    : 34
,                    : 6 18
-                    : 33
/                    : 36
;                    : 10
=                    : 19 23
ANDSIMB              : 27
CHAR                 : 41
COMPSIMB             : 31
ID                   : 3 8 19 20 23 40
NUMBER               : 43
NUMBERF              : 42
ORSIMB               : 25
TYPE                 : 3 4 6 15
error                : 
{                    : 3
}                    : 3

Nonterminals, with rules where they appear:

ADDOP                : 30 31 33 34
ANDOP                : 24 25 27
ARG                  : 4 6
ARGS                 : 3
ASIG                 : 14
COMPOP               : 28 31
DECLAR               : 11
ELEM                 : 16 18
FUNCTION             : 2
IDPRIMA              : 15
INSTR                : 12 19 23
LINE                 : 10
LINES                : 3 10
NOTOP                : 26 27 29
OROP                 : 13 25 39
PAROP                : 35 36 37
PRODOP               : 32 33 34 36 37
RARGS                : 4 6
REST                 : 16 18
S                    : 2 0
VAL                  : 38
empty                : 16
empty2               : 18
emptyF1              : 3


state 0

    (0) S' -> . S
    (1) S -> .
    (2) S -> . S FUNCTION
    TYPE            reduce using rule 1 (S -> .)
    $end            reduce using rule 1 (S -> .)

    S                              shift and go to state 1

state 1

    (0) S' -> S .
    (2) S -> S . FUNCTION
    (3) FUNCTION -> . TYPE ID emptyF1 ( ARGS ) { LINES }
    TYPE            shift and go to state 3

    FUNCTION                       shift and go to state 2

state 2

    (2) S -> S FUNCTION .
    TYPE            reduce using rule 2 (S -> S FUNCTION .)
    $end            reduce using rule 2 (S -> S FUNCTION .)


state 3

    (3) FUNCTION -> TYPE . ID emptyF1 ( ARGS ) { LINES }
    ID              shift and go to state 4


state 4

    (3) FUNCTION -> TYPE ID . emptyF1 ( ARGS ) { LINES }
    (7) emptyF1 -> .
    (               reduce using rule 7 (emptyF1 -> .)

    emptyF1                        shift and go to state 5

state 5

    (3) FUNCTION -> TYPE ID emptyF1 . ( ARGS ) { LINES }
    (               shift and go to state 6


state 6

    (3) FUNCTION -> TYPE ID emptyF1 ( . ARGS ) { LINES }
    (4) ARGS -> . TYPE ARG RARGS
    TYPE            shift and go to state 7

    ARGS                           shift and go to state 8

state 7

    (4) ARGS -> TYPE . ARG RARGS
    (8) ARG -> . ID
    ID              shift and go to state 10

    ARG                            shift and go to state 9

state 8

    (3) FUNCTION -> TYPE ID emptyF1 ( ARGS . ) { LINES }
    )               shift and go to state 11


state 9

    (4) ARGS -> TYPE ARG . RARGS
    (5) RARGS -> .
    (6) RARGS -> . , TYPE ARG RARGS
    )               reduce using rule 5 (RARGS -> .)
    ,               shift and go to state 13

    RARGS                          shift and go to state 12

state 10

    (8) ARG -> ID .
    ,               reduce using rule 8 (ARG -> ID .)
    )               reduce using rule 8 (ARG -> ID .)


state 11

    (3) FUNCTION -> TYPE ID emptyF1 ( ARGS ) . { LINES }
    {               shift and go to state 14


state 12

    (4) ARGS -> TYPE ARG RARGS .
    )               reduce using rule 4 (ARGS -> TYPE ARG RARGS .)


state 13

    (6) RARGS -> , . TYPE ARG RARGS
    TYPE            shift and go to state 15


state 14

    (3) FUNCTION -> TYPE ID emptyF1 ( ARGS ) { . LINES }
    (9) LINES -> .
    (10) LINES -> . LINES LINE ;
    }               reduce using rule 9 (LINES -> .)
    TYPE            reduce using rule 9 (LINES -> .)
    ID              reduce using rule 9 (LINES -> .)
    !               reduce using rule 9 (LINES -> .)
    (               reduce using rule 9 (LINES -> .)
    CHAR            reduce using rule 9 (LINES -> .)
    NUMBERF         reduce using rule 9 (LINES -> .)
    NUMBER          reduce using rule 9 (LINES -> .)

    LINES                          shift and go to state 16

state 15

    (6) RARGS -> , TYPE . ARG RARGS
    (8) ARG -> . ID
    ID              shift and go to state 10

    ARG                            shift and go to state 17

state 16

    (3) FUNCTION -> TYPE ID emptyF1 ( ARGS ) { LINES . }
    (10) LINES -> LINES . LINE ;
    (11) LINE -> . DECLAR
    (12) LINE -> . INSTR
    (15) DECLAR -> . TYPE IDPRIMA
    (13) INSTR -> . OROP
    (14) INSTR -> . ASIG
    (24) OROP -> . ANDOP
    (25) OROP -> . OROP ORSIMB ANDOP
    (23) ASIG -> . ID = INSTR
    (26) ANDOP -> . NOTOP
    (27) ANDOP -> . ANDOP ANDSIMB NOTOP
    (28) NOTOP -> . COMPOP
    (29) NOTOP -> . ! NOTOP
    (30) COMPOP -> . ADDOP
    (31) COMPOP -> . COMPOP COMPSIMB ADDOP
    (32) ADDOP -> . PRODOP
    (33) ADDOP -> . ADDOP - PRODOP
    (34) ADDOP -> . ADDOP + PRODOP
    (35) PRODOP -> . PAROP
    (36) PRODOP -> . PRODOP / PAROP
    (37) PRODOP -> . PRODOP * PAROP
    (38) PAROP -> . VAL
    (39) PAROP -> . ( OROP )
    (40) VAL -> . ID
    (41) VAL -> . CHAR
    (42) VAL -> . NUMBERF
    (43) VAL -> . NUMBER
    }               shift and go to state 21
    TYPE            shift and go to state 18
    ID              shift and go to state 19
    !               shift and go to state 30
    (               shift and go to state 20
    CHAR            shift and go to state 35
    NUMBERF         shift and go to state 36
    NUMBER          shift and go to state 37

    LINE                           shift and go to state 22
    DECLAR                         shift and go to state 23
    INSTR                          shift and go to state 24
    OROP                           shift and go to state 25
    ASIG                           shift and go to state 26
    ANDOP                          shift and go to state 27
    NOTOP                          shift and go to state 28
    COMPOP                         shift and go to state 29
    ADDOP                          shift and go to state 31
    PRODOP                         shift and go to state 32
    PAROP                          shift and go to state 33
    VAL                            shift and go to state 34

state 17

    (6) RARGS -> , TYPE ARG . RARGS
    (5) RARGS -> .
    (6) RARGS -> . , TYPE ARG RARGS
    )               reduce using rule 5 (RARGS -> .)
    ,               shift and go to state 13

    RARGS                          shift and go to state 38

state 18

    (15) DECLAR -> TYPE . IDPRIMA
    (16) IDPRIMA -> . empty ELEM REST
    (21) empty -> .
    ID              reduce using rule 21 (empty -> .)

    IDPRIMA                        shift and go to state 39
    empty                          shift and go to state 40

state 19

    (23) ASIG -> ID . = INSTR
    (40) VAL -> ID .
    =               shift and go to state 41
    /               reduce using rule 40 (VAL -> ID .)
    *               reduce using rule 40 (VAL -> ID .)
    -               reduce using rule 40 (VAL -> ID .)
    +               reduce using rule 40 (VAL -> ID .)
    COMPSIMB        reduce using rule 40 (VAL -> ID .)
    ANDSIMB         reduce using rule 40 (VAL -> ID .)
    ORSIMB          reduce using rule 40 (VAL -> ID .)
    ;               reduce using rule 40 (VAL -> ID .)
    ,               reduce using rule 40 (VAL -> ID .)


state 20

    (39) PAROP -> ( . OROP )
    (24) OROP -> . ANDOP
    (25) OROP -> . OROP ORSIMB ANDOP
    (26) ANDOP -> . NOTOP
    (27) ANDOP -> . ANDOP ANDSIMB NOTOP
    (28) NOTOP -> . COMPOP
    (29) NOTOP -> . ! NOTOP
    (30) COMPOP -> . ADDOP
    (31) COMPOP -> . COMPOP COMPSIMB ADDOP
    (32) ADDOP -> . PRODOP
    (33) ADDOP -> . ADDOP - PRODOP
    (34) ADDOP -> . ADDOP + PRODOP
    (35) PRODOP -> . PAROP
    (36) PRODOP -> . PRODOP / PAROP
    (37) PRODOP -> . PRODOP * PAROP
    (38) PAROP -> . VAL
    (39) PAROP -> . ( OROP )
    (40) VAL -> . ID
    (41) VAL -> . CHAR
    (42) VAL -> . NUMBERF
    (43) VAL -> . NUMBER
    !               shift and go to state 30
    (               shift and go to state 20
    ID              shift and go to state 43
    CHAR            shift and go to state 35
    NUMBERF         shift and go to state 36
    NUMBER          shift and go to state 37

    OROP                           shift and go to state 42
    ANDOP                          shift and go to state 27
    NOTOP                          shift and go to state 28
    COMPOP                         shift and go to state 29
    ADDOP                          shift and go to state 31
    PRODOP                         shift and go to state 32
    PAROP                          shift and go to state 33
    VAL                            shift and go to state 34

state 21

    (3) FUNCTION -> TYPE ID emptyF1 ( ARGS ) { LINES } .
    TYPE            reduce using rule 3 (FUNCTION -> TYPE ID emptyF1 ( ARGS ) { LINES } .)
    $end            reduce using rule 3 (FUNCTION -> TYPE ID emptyF1 ( ARGS ) { LINES } .)


state 22

    (10) LINES -> LINES LINE . ;
    ;               shift and go to state 44


state 23

    (11) LINE -> DECLAR .
    ;               reduce using rule 11 (LINE -> DECLAR .)


state 24

    (12) LINE -> INSTR .
    ;               reduce using rule 12 (LINE -> INSTR .)


state 25

    (13) INSTR -> OROP .
    (25) OROP -> OROP . ORSIMB ANDOP
    ;               reduce using rule 13 (INSTR -> OROP .)
    ,               reduce using rule 13 (INSTR -> OROP .)
    ORSIMB          shift and go to state 45


state 26

    (14) INSTR -> ASIG .
    ;               reduce using rule 14 (INSTR -> ASIG .)
    ,               reduce using rule 14 (INSTR -> ASIG .)


state 27

    (24) OROP -> ANDOP .
    (27) ANDOP -> ANDOP . ANDSIMB NOTOP
    ORSIMB          reduce using rule 24 (OROP -> ANDOP .)
    ;               reduce using rule 24 (OROP -> ANDOP .)
    )               reduce using rule 24 (OROP -> ANDOP .)
    ,               reduce using rule 24 (OROP -> ANDOP .)
    ANDSIMB         shift and go to state 46


state 28

    (26) ANDOP -> NOTOP .
    ANDSIMB         reduce using rule 26 (ANDOP -> NOTOP .)
    ORSIMB          reduce using rule 26 (ANDOP -> NOTOP .)
    ;               reduce using rule 26 (ANDOP -> NOTOP .)
    )               reduce using rule 26 (ANDOP -> NOTOP .)
    ,               reduce using rule 26 (ANDOP -> NOTOP .)


state 29

    (28) NOTOP -> COMPOP .
    (31) COMPOP -> COMPOP . COMPSIMB ADDOP
    ANDSIMB         reduce using rule 28 (NOTOP -> COMPOP .)
    ORSIMB          reduce using rule 28 (NOTOP -> COMPOP .)
    ;               reduce using rule 28 (NOTOP -> COMPOP .)
    )               reduce using rule 28 (NOTOP -> COMPOP .)
    ,               reduce using rule 28 (NOTOP -> COMPOP .)
    COMPSIMB        shift and go to state 47


state 30

    (29) NOTOP -> ! . NOTOP
    (28) NOTOP -> . COMPOP
    (29) NOTOP -> . ! NOTOP
    (30) COMPOP -> . ADDOP
    (31) COMPOP -> . COMPOP COMPSIMB ADDOP
    (32) ADDOP -> . PRODOP
    (33) ADDOP -> . ADDOP - PRODOP
    (34) ADDOP -> . ADDOP + PRODOP
    (35) PRODOP -> . PAROP
    (36) PRODOP -> . PRODOP / PAROP
    (37) PRODOP -> . PRODOP * PAROP
    (38) PAROP -> . VAL
    (39) PAROP -> . ( OROP )
    (40) VAL -> . ID
    (41) VAL -> . CHAR
    (42) VAL -> . NUMBERF
    (43) VAL -> . NUMBER
    !               shift and go to state 30
    (               shift and go to state 20
    ID              shift and go to state 43
    CHAR            shift and go to state 35
    NUMBERF         shift and go to state 36
    NUMBER          shift and go to state 37

    NOTOP                          shift and go to state 48
    COMPOP                         shift and go to state 29
    ADDOP                          shift and go to state 31
    PRODOP                         shift and go to state 32
    PAROP                          shift and go to state 33
    VAL                            shift and go to state 34

state 31

    (30) COMPOP -> ADDOP .
    (33) ADDOP -> ADDOP . - PRODOP
    (34) ADDOP -> ADDOP . + PRODOP
    COMPSIMB        reduce using rule 30 (COMPOP -> ADDOP .)
    ANDSIMB         reduce using rule 30 (COMPOP -> ADDOP .)
    ORSIMB          reduce using rule 30 (COMPOP -> ADDOP .)
    ;               reduce using rule 30 (COMPOP -> ADDOP .)
    )               reduce using rule 30 (COMPOP -> ADDOP .)
    ,               reduce using rule 30 (COMPOP -> ADDOP .)
    -               shift and go to state 49
    +               shift and go to state 50


state 32

    (32) ADDOP -> PRODOP .
    (36) PRODOP -> PRODOP . / PAROP
    (37) PRODOP -> PRODOP . * PAROP
    -               reduce using rule 32 (ADDOP -> PRODOP .)
    +               reduce using rule 32 (ADDOP -> PRODOP .)
    COMPSIMB        reduce using rule 32 (ADDOP -> PRODOP .)
    ANDSIMB         reduce using rule 32 (ADDOP -> PRODOP .)
    ORSIMB          reduce using rule 32 (ADDOP -> PRODOP .)
    ;               reduce using rule 32 (ADDOP -> PRODOP .)
    )               reduce using rule 32 (ADDOP -> PRODOP .)
    ,               reduce using rule 32 (ADDOP -> PRODOP .)
    /               shift and go to state 51
    *               shift and go to state 52


state 33

    (35) PRODOP -> PAROP .
    /               reduce using rule 35 (PRODOP -> PAROP .)
    *               reduce using rule 35 (PRODOP -> PAROP .)
    -               reduce using rule 35 (PRODOP -> PAROP .)
    +               reduce using rule 35 (PRODOP -> PAROP .)
    COMPSIMB        reduce using rule 35 (PRODOP -> PAROP .)
    ANDSIMB         reduce using rule 35 (PRODOP -> PAROP .)
    ORSIMB          reduce using rule 35 (PRODOP -> PAROP .)
    ;               reduce using rule 35 (PRODOP -> PAROP .)
    )               reduce using rule 35 (PRODOP -> PAROP .)
    ,               reduce using rule 35 (PRODOP -> PAROP .)


state 34

    (38) PAROP -> VAL .
    /               reduce using rule 38 (PAROP -> VAL .)
    *               reduce using rule 38 (PAROP -> VAL .)
    -               reduce using rule 38 (PAROP -> VAL .)
    +               reduce using rule 38 (PAROP -> VAL .)
    COMPSIMB        reduce using rule 38 (PAROP -> VAL .)
    ANDSIMB         reduce using rule 38 (PAROP -> VAL .)
    ORSIMB          reduce using rule 38 (PAROP -> VAL .)
    ;               reduce using rule 38 (PAROP -> VAL .)
    )               reduce using rule 38 (PAROP -> VAL .)
    ,               reduce using rule 38 (PAROP -> VAL .)


state 35

    (41) VAL -> CHAR .
    /               reduce using rule 41 (VAL -> CHAR .)
    *               reduce using rule 41 (VAL -> CHAR .)
    -               reduce using rule 41 (VAL -> CHAR .)
    +               reduce using rule 41 (VAL -> CHAR .)
    COMPSIMB        reduce using rule 41 (VAL -> CHAR .)
    ANDSIMB         reduce using rule 41 (VAL -> CHAR .)
    ORSIMB          reduce using rule 41 (VAL -> CHAR .)
    ;               reduce using rule 41 (VAL -> CHAR .)
    )               reduce using rule 41 (VAL -> CHAR .)
    ,               reduce using rule 41 (VAL -> CHAR .)


state 36

    (42) VAL -> NUMBERF .
    /               reduce using rule 42 (VAL -> NUMBERF .)
    *               reduce using rule 42 (VAL -> NUMBERF .)
    -               reduce using rule 42 (VAL -> NUMBERF .)
    +               reduce using rule 42 (VAL -> NUMBERF .)
    COMPSIMB        reduce using rule 42 (VAL -> NUMBERF .)
    ANDSIMB         reduce using rule 42 (VAL -> NUMBERF .)
    ORSIMB          reduce using rule 42 (VAL -> NUMBERF .)
    ;               reduce using rule 42 (VAL -> NUMBERF .)
    )               reduce using rule 42 (VAL -> NUMBERF .)
    ,               reduce using rule 42 (VAL -> NUMBERF .)


state 37

    (43) VAL -> NUMBER .
    /               reduce using rule 43 (VAL -> NUMBER .)
    *               reduce using rule 43 (VAL -> NUMBER .)
    -               reduce using rule 43 (VAL -> NUMBER .)
    +               reduce using rule 43 (VAL -> NUMBER .)
    COMPSIMB        reduce using rule 43 (VAL -> NUMBER .)
    ANDSIMB         reduce using rule 43 (VAL -> NUMBER .)
    ORSIMB          reduce using rule 43 (VAL -> NUMBER .)
    ;               reduce using rule 43 (VAL -> NUMBER .)
    )               reduce using rule 43 (VAL -> NUMBER .)
    ,               reduce using rule 43 (VAL -> NUMBER .)


state 38

    (6) RARGS -> , TYPE ARG RARGS .
    )               reduce using rule 6 (RARGS -> , TYPE ARG RARGS .)


state 39

    (15) DECLAR -> TYPE IDPRIMA .
    ;               reduce using rule 15 (DECLAR -> TYPE IDPRIMA .)


state 40

    (16) IDPRIMA -> empty . ELEM REST
    (19) ELEM -> . ID = INSTR
    (20) ELEM -> . ID
    ID              shift and go to state 54

    ELEM                           shift and go to state 53

state 41

    (23) ASIG -> ID = . INSTR
    (13) INSTR -> . OROP
    (14) INSTR -> . ASIG
    (24) OROP -> . ANDOP
    (25) OROP -> . OROP ORSIMB ANDOP
    (23) ASIG -> . ID = INSTR
    (26) ANDOP -> . NOTOP
    (27) ANDOP -> . ANDOP ANDSIMB NOTOP
    (28) NOTOP -> . COMPOP
    (29) NOTOP -> . ! NOTOP
    (30) COMPOP -> . ADDOP
    (31) COMPOP -> . COMPOP COMPSIMB ADDOP
    (32) ADDOP -> . PRODOP
    (33) ADDOP -> . ADDOP - PRODOP
    (34) ADDOP -> . ADDOP + PRODOP
    (35) PRODOP -> . PAROP
    (36) PRODOP -> . PRODOP / PAROP
    (37) PRODOP -> . PRODOP * PAROP
    (38) PAROP -> . VAL
    (39) PAROP -> . ( OROP )
    (40) VAL -> . ID
    (41) VAL -> . CHAR
    (42) VAL -> . NUMBERF
    (43) VAL -> . NUMBER
    ID              shift and go to state 19
    !               shift and go to state 30
    (               shift and go to state 20
    CHAR            shift and go to state 35
    NUMBERF         shift and go to state 36
    NUMBER          shift and go to state 37

    INSTR                          shift and go to state 55
    OROP                           shift and go to state 25
    ASIG                           shift and go to state 26
    ANDOP                          shift and go to state 27
    NOTOP                          shift and go to state 28
    COMPOP                         shift and go to state 29
    ADDOP                          shift and go to state 31
    PRODOP                         shift and go to state 32
    PAROP                          shift and go to state 33
    VAL                            shift and go to state 34

state 42

    (39) PAROP -> ( OROP . )
    (25) OROP -> OROP . ORSIMB ANDOP
    )               shift and go to state 56
    ORSIMB          shift and go to state 45


state 43

    (40) VAL -> ID .
    /               reduce using rule 40 (VAL -> ID .)
    *               reduce using rule 40 (VAL -> ID .)
    -               reduce using rule 40 (VAL -> ID .)
    +               reduce using rule 40 (VAL -> ID .)
    COMPSIMB        reduce using rule 40 (VAL -> ID .)
    ANDSIMB         reduce using rule 40 (VAL -> ID .)
    )               reduce using rule 40 (VAL -> ID .)
    ORSIMB          reduce using rule 40 (VAL -> ID .)
    ;               reduce using rule 40 (VAL -> ID .)
    ,               reduce using rule 40 (VAL -> ID .)


state 44

    (10) LINES -> LINES LINE ; .
    }               reduce using rule 10 (LINES -> LINES LINE ; .)
    TYPE            reduce using rule 10 (LINES -> LINES LINE ; .)
    ID              reduce using rule 10 (LINES -> LINES LINE ; .)
    !               reduce using rule 10 (LINES -> LINES LINE ; .)
    (               reduce using rule 10 (LINES -> LINES LINE ; .)
    CHAR            reduce using rule 10 (LINES -> LINES LINE ; .)
    NUMBERF         reduce using rule 10 (LINES -> LINES LINE ; .)
    NUMBER          reduce using rule 10 (LINES -> LINES LINE ; .)


state 45

    (25) OROP -> OROP ORSIMB . ANDOP
    (26) ANDOP -> . NOTOP
    (27) ANDOP -> . ANDOP ANDSIMB NOTOP
    (28) NOTOP -> . COMPOP
    (29) NOTOP -> . ! NOTOP
    (30) COMPOP -> . ADDOP
    (31) COMPOP -> . COMPOP COMPSIMB ADDOP
    (32) ADDOP -> . PRODOP
    (33) ADDOP -> . ADDOP - PRODOP
    (34) ADDOP -> . ADDOP + PRODOP
    (35) PRODOP -> . PAROP
    (36) PRODOP -> . PRODOP / PAROP
    (37) PRODOP -> . PRODOP * PAROP
    (38) PAROP -> . VAL
    (39) PAROP -> . ( OROP )
    (40) VAL -> . ID
    (41) VAL -> . CHAR
    (42) VAL -> . NUMBERF
    (43) VAL -> . NUMBER
    !               shift and go to state 30
    (               shift and go to state 20
    ID              shift and go to state 43
    CHAR            shift and go to state 35
    NUMBERF         shift and go to state 36
    NUMBER          shift and go to state 37

    ANDOP                          shift and go to state 57
    NOTOP                          shift and go to state 28
    COMPOP                         shift and go to state 29
    ADDOP                          shift and go to state 31
    PRODOP                         shift and go to state 32
    PAROP                          shift and go to state 33
    VAL                            shift and go to state 34

state 46

    (27) ANDOP -> ANDOP ANDSIMB . NOTOP
    (28) NOTOP -> . COMPOP
    (29) NOTOP -> . ! NOTOP
    (30) COMPOP -> . ADDOP
    (31) COMPOP -> . COMPOP COMPSIMB ADDOP
    (32) ADDOP -> . PRODOP
    (33) ADDOP -> . ADDOP - PRODOP
    (34) ADDOP -> . ADDOP + PRODOP
    (35) PRODOP -> . PAROP
    (36) PRODOP -> . PRODOP / PAROP
    (37) PRODOP -> . PRODOP * PAROP
    (38) PAROP -> . VAL
    (39) PAROP -> . ( OROP )
    (40) VAL -> . ID
    (41) VAL -> . CHAR
    (42) VAL -> . NUMBERF
    (43) VAL -> . NUMBER
    !               shift and go to state 30
    (               shift and go to state 20
    ID              shift and go to state 43
    CHAR            shift and go to state 35
    NUMBERF         shift and go to state 36
    NUMBER          shift and go to state 37

    NOTOP                          shift and go to state 58
    COMPOP                         shift and go to state 29
    ADDOP                          shift and go to state 31
    PRODOP                         shift and go to state 32
    PAROP                          shift and go to state 33
    VAL                            shift and go to state 34

state 47

    (31) COMPOP -> COMPOP COMPSIMB . ADDOP
    (32) ADDOP -> . PRODOP
    (33) ADDOP -> . ADDOP - PRODOP
    (34) ADDOP -> . ADDOP + PRODOP
    (35) PRODOP -> . PAROP
    (36) PRODOP -> . PRODOP / PAROP
    (37) PRODOP -> . PRODOP * PAROP
    (38) PAROP -> . VAL
    (39) PAROP -> . ( OROP )
    (40) VAL -> . ID
    (41) VAL -> . CHAR
    (42) VAL -> . NUMBERF
    (43) VAL -> . NUMBER
    (               shift and go to state 20
    ID              shift and go to state 43
    CHAR            shift and go to state 35
    NUMBERF         shift and go to state 36
    NUMBER          shift and go to state 37

    ADDOP                          shift and go to state 59
    PRODOP                         shift and go to state 32
    PAROP                          shift and go to state 33
    VAL                            shift and go to state 34

state 48

    (29) NOTOP -> ! NOTOP .
    ANDSIMB         reduce using rule 29 (NOTOP -> ! NOTOP .)
    ORSIMB          reduce using rule 29 (NOTOP -> ! NOTOP .)
    ;               reduce using rule 29 (NOTOP -> ! NOTOP .)
    )               reduce using rule 29 (NOTOP -> ! NOTOP .)
    ,               reduce using rule 29 (NOTOP -> ! NOTOP .)


state 49

    (33) ADDOP -> ADDOP - . PRODOP
    (35) PRODOP -> . PAROP
    (36) PRODOP -> . PRODOP / PAROP
    (37) PRODOP -> . PRODOP * PAROP
    (38) PAROP -> . VAL
    (39) PAROP -> . ( OROP )
    (40) VAL -> . ID
    (41) VAL -> . CHAR
    (42) VAL -> . NUMBERF
    (43) VAL -> . NUMBER
    (               shift and go to state 20
    ID              shift and go to state 43
    CHAR            shift and go to state 35
    NUMBERF         shift and go to state 36
    NUMBER          shift and go to state 37

    PRODOP                         shift and go to state 60
    PAROP                          shift and go to state 33
    VAL                            shift and go to state 34

state 50

    (34) ADDOP -> ADDOP + . PRODOP
    (35) PRODOP -> . PAROP
    (36) PRODOP -> . PRODOP / PAROP
    (37) PRODOP -> . PRODOP * PAROP
    (38) PAROP -> . VAL
    (39) PAROP -> . ( OROP )
    (40) VAL -> . ID
    (41) VAL -> . CHAR
    (42) VAL -> . NUMBERF
    (43) VAL -> . NUMBER
    (               shift and go to state 20
    ID              shift and go to state 43
    CHAR            shift and go to state 35
    NUMBERF         shift and go to state 36
    NUMBER          shift and go to state 37

    PRODOP                         shift and go to state 61
    PAROP                          shift and go to state 33
    VAL                            shift and go to state 34

state 51

    (36) PRODOP -> PRODOP / . PAROP
    (38) PAROP -> . VAL
    (39) PAROP -> . ( OROP )
    (40) VAL -> . ID
    (41) VAL -> . CHAR
    (42) VAL -> . NUMBERF
    (43) VAL -> . NUMBER
    (               shift and go to state 20
    ID              shift and go to state 43
    CHAR            shift and go to state 35
    NUMBERF         shift and go to state 36
    NUMBER          shift and go to state 37

    PAROP                          shift and go to state 62
    VAL                            shift and go to state 34

state 52

    (37) PRODOP -> PRODOP * . PAROP
    (38) PAROP -> . VAL
    (39) PAROP -> . ( OROP )
    (40) VAL -> . ID
    (41) VAL -> . CHAR
    (42) VAL -> . NUMBERF
    (43) VAL -> . NUMBER
    (               shift and go to state 20
    ID              shift and go to state 43
    CHAR            shift and go to state 35
    NUMBERF         shift and go to state 36
    NUMBER          shift and go to state 37

    PAROP                          shift and go to state 63
    VAL                            shift and go to state 34

state 53

    (16) IDPRIMA -> empty ELEM . REST
    (17) REST -> .
    (18) REST -> . , empty2 ELEM REST
    ;               reduce using rule 17 (REST -> .)
    ,               shift and go to state 65

    REST                           shift and go to state 64

state 54

    (19) ELEM -> ID . = INSTR
    (20) ELEM -> ID .
    =               shift and go to state 66
    ,               reduce using rule 20 (ELEM -> ID .)
    ;               reduce using rule 20 (ELEM -> ID .)


state 55

    (23) ASIG -> ID = INSTR .
    ;               reduce using rule 23 (ASIG -> ID = INSTR .)
    ,               reduce using rule 23 (ASIG -> ID = INSTR .)


state 56

    (39) PAROP -> ( OROP ) .
    /               reduce using rule 39 (PAROP -> ( OROP ) .)
    *               reduce using rule 39 (PAROP -> ( OROP ) .)
    -               reduce using rule 39 (PAROP -> ( OROP ) .)
    +               reduce using rule 39 (PAROP -> ( OROP ) .)
    COMPSIMB        reduce using rule 39 (PAROP -> ( OROP ) .)
    ANDSIMB         reduce using rule 39 (PAROP -> ( OROP ) .)
    ORSIMB          reduce using rule 39 (PAROP -> ( OROP ) .)
    ;               reduce using rule 39 (PAROP -> ( OROP ) .)
    )               reduce using rule 39 (PAROP -> ( OROP ) .)
    ,               reduce using rule 39 (PAROP -> ( OROP ) .)


state 57

    (25) OROP -> OROP ORSIMB ANDOP .
    (27) ANDOP -> ANDOP . ANDSIMB NOTOP
    ORSIMB          reduce using rule 25 (OROP -> OROP ORSIMB ANDOP .)
    ;               reduce using rule 25 (OROP -> OROP ORSIMB ANDOP .)
    )               reduce using rule 25 (OROP -> OROP ORSIMB ANDOP .)
    ,               reduce using rule 25 (OROP -> OROP ORSIMB ANDOP .)
    ANDSIMB         shift and go to state 46


state 58

    (27) ANDOP -> ANDOP ANDSIMB NOTOP .
    ANDSIMB         reduce using rule 27 (ANDOP -> ANDOP ANDSIMB NOTOP .)
    ORSIMB          reduce using rule 27 (ANDOP -> ANDOP ANDSIMB NOTOP .)
    ;               reduce using rule 27 (ANDOP -> ANDOP ANDSIMB NOTOP .)
    )               reduce using rule 27 (ANDOP -> ANDOP ANDSIMB NOTOP .)
    ,               reduce using rule 27 (ANDOP -> ANDOP ANDSIMB NOTOP .)


state 59

    (31) COMPOP -> COMPOP COMPSIMB ADDOP .
    (33) ADDOP -> ADDOP . - PRODOP
    (34) ADDOP -> ADDOP . + PRODOP
    COMPSIMB        reduce using rule 31 (COMPOP -> COMPOP COMPSIMB ADDOP .)
    ANDSIMB         reduce using rule 31 (COMPOP -> COMPOP COMPSIMB ADDOP .)
    ORSIMB          reduce using rule 31 (COMPOP -> COMPOP COMPSIMB ADDOP .)
    ;               reduce using rule 31 (COMPOP -> COMPOP COMPSIMB ADDOP .)
    )               reduce using rule 31 (COMPOP -> COMPOP COMPSIMB ADDOP .)
    ,               reduce using rule 31 (COMPOP -> COMPOP COMPSIMB ADDOP .)
    -               shift and go to state 49
    +               shift and go to state 50


state 60

    (33) ADDOP -> ADDOP - PRODOP .
    (36) PRODOP -> PRODOP . / PAROP
    (37) PRODOP -> PRODOP . * PAROP
    -               reduce using rule 33 (ADDOP -> ADDOP - PRODOP .)
    +               reduce using rule 33 (ADDOP -> ADDOP - PRODOP .)
    COMPSIMB        reduce using rule 33 (ADDOP -> ADDOP - PRODOP .)
    ANDSIMB         reduce using rule 33 (ADDOP -> ADDOP - PRODOP .)
    ORSIMB          reduce using rule 33 (ADDOP -> ADDOP - PRODOP .)
    ;               reduce using rule 33 (ADDOP -> ADDOP - PRODOP .)
    )               reduce using rule 33 (ADDOP -> ADDOP - PRODOP .)
    ,               reduce using rule 33 (ADDOP -> ADDOP - PRODOP .)
    /               shift and go to state 51
    *               shift and go to state 52


state 61

    (34) ADDOP -> ADDOP + PRODOP .
    (36) PRODOP -> PRODOP . / PAROP
    (37) PRODOP -> PRODOP . * PAROP
    -               reduce using rule 34 (ADDOP -> ADDOP + PRODOP .)
    +               reduce using rule 34 (ADDOP -> ADDOP + PRODOP .)
    COMPSIMB        reduce using rule 34 (ADDOP -> ADDOP + PRODOP .)
    ANDSIMB         reduce using rule 34 (ADDOP -> ADDOP + PRODOP .)
    ORSIMB          reduce using rule 34 (ADDOP -> ADDOP + PRODOP .)
    ;               reduce using rule 34 (ADDOP -> ADDOP + PRODOP .)
    )               reduce using rule 34 (ADDOP -> ADDOP + PRODOP .)
    ,               reduce using rule 34 (ADDOP -> ADDOP + PRODOP .)
    /               shift and go to state 51
    *               shift and go to state 52


state 62

    (36) PRODOP -> PRODOP / PAROP .
    /               reduce using rule 36 (PRODOP -> PRODOP / PAROP .)
    *               reduce using rule 36 (PRODOP -> PRODOP / PAROP .)
    -               reduce using rule 36 (PRODOP -> PRODOP / PAROP .)
    +               reduce using rule 36 (PRODOP -> PRODOP / PAROP .)
    COMPSIMB        reduce using rule 36 (PRODOP -> PRODOP / PAROP .)
    ANDSIMB         reduce using rule 36 (PRODOP -> PRODOP / PAROP .)
    ORSIMB          reduce using rule 36 (PRODOP -> PRODOP / PAROP .)
    ;               reduce using rule 36 (PRODOP -> PRODOP / PAROP .)
    )               reduce using rule 36 (PRODOP -> PRODOP / PAROP .)
    ,               reduce using rule 36 (PRODOP -> PRODOP / PAROP .)


state 63

    (37) PRODOP -> PRODOP * PAROP .
    /               reduce using rule 37 (PRODOP -> PRODOP * PAROP .)
    *               reduce using rule 37 (PRODOP -> PRODOP * PAROP .)
    -               reduce using rule 37 (PRODOP -> PRODOP * PAROP .)
    +               reduce using rule 37 (PRODOP -> PRODOP * PAROP .)
    COMPSIMB        reduce using rule 37 (PRODOP -> PRODOP * PAROP .)
    ANDSIMB         reduce using rule 37 (PRODOP -> PRODOP * PAROP .)
    ORSIMB          reduce using rule 37 (PRODOP -> PRODOP * PAROP .)
    ;               reduce using rule 37 (PRODOP -> PRODOP * PAROP .)
    )               reduce using rule 37 (PRODOP -> PRODOP * PAROP .)
    ,               reduce using rule 37 (PRODOP -> PRODOP * PAROP .)


state 64

    (16) IDPRIMA -> empty ELEM REST .
    ;               reduce using rule 16 (IDPRIMA -> empty ELEM REST .)


state 65

    (18) REST -> , . empty2 ELEM REST
    (22) empty2 -> .
    ID              reduce using rule 22 (empty2 -> .)

    empty2                         shift and go to state 67

state 66

    (19) ELEM -> ID = . INSTR
    (13) INSTR -> . OROP
    (14) INSTR -> . ASIG
    (24) OROP -> . ANDOP
    (25) OROP -> . OROP ORSIMB ANDOP
    (23) ASIG -> . ID = INSTR
    (26) ANDOP -> . NOTOP
    (27) ANDOP -> . ANDOP ANDSIMB NOTOP
    (28) NOTOP -> . COMPOP
    (29) NOTOP -> . ! NOTOP
    (30) COMPOP -> . ADDOP
    (31) COMPOP -> . COMPOP COMPSIMB ADDOP
    (32) ADDOP -> . PRODOP
    (33) ADDOP -> . ADDOP - PRODOP
    (34) ADDOP -> . ADDOP + PRODOP
    (35) PRODOP -> . PAROP
    (36) PRODOP -> . PRODOP / PAROP
    (37) PRODOP -> . PRODOP * PAROP
    (38) PAROP -> . VAL
    (39) PAROP -> . ( OROP )
    (40) VAL -> . ID
    (41) VAL -> . CHAR
    (42) VAL -> . NUMBERF
    (43) VAL -> . NUMBER
    ID              shift and go to state 19
    !               shift and go to state 30
    (               shift and go to state 20
    CHAR            shift and go to state 35
    NUMBERF         shift and go to state 36
    NUMBER          shift and go to state 37

    INSTR                          shift and go to state 68
    OROP                           shift and go to state 25
    ASIG                           shift and go to state 26
    ANDOP                          shift and go to state 27
    NOTOP                          shift and go to state 28
    COMPOP                         shift and go to state 29
    ADDOP                          shift and go to state 31
    PRODOP                         shift and go to state 32
    PAROP                          shift and go to state 33
    VAL                            shift and go to state 34

state 67

    (18) REST -> , empty2 . ELEM REST
    (19) ELEM -> . ID = INSTR
    (20) ELEM -> . ID
    ID              shift and go to state 54

    ELEM                           shift and go to state 69

state 68

    (19) ELEM -> ID = INSTR .
    ,               reduce using rule 19 (ELEM -> ID = INSTR .)
    ;               reduce using rule 19 (ELEM -> ID = INSTR .)


state 69

    (18) REST -> , empty2 ELEM . REST
    (17) REST -> .
    (18) REST -> . , empty2 ELEM REST
    ;               reduce using rule 17 (REST -> .)
    ,               shift and go to state 65

    REST                           shift and go to state 70

state 70

    (18) REST -> , empty2 ELEM REST .
    ;               reduce using rule 18 (REST -> , empty2 ELEM REST .)
